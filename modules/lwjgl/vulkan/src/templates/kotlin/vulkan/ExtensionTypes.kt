/*
 * Copyright LWJGL. All rights reserved.
 * License terms: https://www.lwjgl.org/license
 * MACHINE GENERATED FILE, DO NOT EDIT
 */
package vulkan

import org.lwjgl.generator.*
import core.linux.*
import core.macos.*
import core.windows.*

// Handle types
val VkSurfaceKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkSurfaceKHR")
val VkSwapchainKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkSwapchainKHR")
val VkDisplayKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDisplayKHR")
val VkDisplayModeKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDisplayModeKHR")
val VkDebugReportCallbackEXT = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDebugReportCallbackEXT")
val VkVideoSessionKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkVideoSessionKHR")
val VkVideoSessionParametersKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkVideoSessionParametersKHR")
val VkCuModuleNVX = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkCuModuleNVX")
val VkCuFunctionNVX = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkCuFunctionNVX")
val VkDescriptorUpdateTemplateKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDescriptorUpdateTemplateKHR")
val VkDebugUtilsMessengerEXT = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDebugUtilsMessengerEXT")
val VkAccelerationStructureKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkAccelerationStructureKHR")
val VkDeferredOperationKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkDeferredOperationKHR")
val VkSamplerYcbcrConversionKHR = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkSamplerYcbcrConversionKHR")
val VkValidationCacheEXT = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkValidationCacheEXT")
val VkAccelerationStructureNV = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkAccelerationStructureNV")
val VkPerformanceConfigurationINTEL = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkPerformanceConfigurationINTEL")
val VkIndirectCommandsLayoutNV = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkIndirectCommandsLayoutNV")
val VkPrivateDataSlotEXT = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkPrivateDataSlotEXT")
val VkMicromapEXT = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkMicromapEXT")
val VkOpticalFlowSessionNV = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkOpticalFlowSessionNV")
val VkShaderEXT = VK_DEFINE_NON_DISPATCHABLE_HANDLE("VkShaderEXT")

// Enum types
val VkSurfaceTransformFlagBitsKHR = "VkSurfaceTransformFlagBitsKHR".enumType
val VkPresentModeKHR = "VkPresentModeKHR".enumType
val VkColorSpaceKHR = "VkColorSpaceKHR".enumType
val VkCompositeAlphaFlagBitsKHR = "VkCompositeAlphaFlagBitsKHR".enumType
val VkSwapchainCreateFlagBitsKHR = "VkSwapchainCreateFlagBitsKHR".enumType
val VkDeviceGroupPresentModeFlagBitsKHR = "VkDeviceGroupPresentModeFlagBitsKHR".enumType
val VkDisplayPlaneAlphaFlagBitsKHR = "VkDisplayPlaneAlphaFlagBitsKHR".enumType
val VkDebugReportObjectTypeEXT = "VkDebugReportObjectTypeEXT".enumType
val VkDebugReportFlagBitsEXT = "VkDebugReportFlagBitsEXT".enumType
val VkRasterizationOrderAMD = "VkRasterizationOrderAMD".enumType
val VkVideoCodecOperationFlagBitsKHR = "VkVideoCodecOperationFlagBitsKHR".enumType
val VkVideoChromaSubsamplingFlagBitsKHR = "VkVideoChromaSubsamplingFlagBitsKHR".enumType
val VkVideoComponentBitDepthFlagBitsKHR = "VkVideoComponentBitDepthFlagBitsKHR".enumType
val VkVideoCapabilityFlagBitsKHR = "VkVideoCapabilityFlagBitsKHR".enumType
val VkVideoSessionCreateFlagBitsKHR = "VkVideoSessionCreateFlagBitsKHR".enumType
val VkVideoCodingControlFlagBitsKHR = "VkVideoCodingControlFlagBitsKHR".enumType
val VkQueryResultStatusKHR = "VkQueryResultStatusKHR".enumType
val VkVideoDecodeCapabilityFlagBitsKHR = "VkVideoDecodeCapabilityFlagBitsKHR".enumType
val VkVideoDecodeUsageFlagBitsKHR = "VkVideoDecodeUsageFlagBitsKHR".enumType
val VkVideoEncodeH264CapabilityFlagBitsEXT = "VkVideoEncodeH264CapabilityFlagBitsEXT".enumType
val VkVideoEncodeH264StdFlagBitsEXT = "VkVideoEncodeH264StdFlagBitsEXT".enumType
val VkVideoEncodeH264RateControlFlagBitsEXT = "VkVideoEncodeH264RateControlFlagBitsEXT".enumType
val VkVideoEncodeH265CapabilityFlagBitsEXT = "VkVideoEncodeH265CapabilityFlagBitsEXT".enumType
val VkVideoEncodeH265StdFlagBitsEXT = "VkVideoEncodeH265StdFlagBitsEXT".enumType
val VkVideoEncodeH265CtbSizeFlagBitsEXT = "VkVideoEncodeH265CtbSizeFlagBitsEXT".enumType
val VkVideoEncodeH265TransformBlockSizeFlagBitsEXT = "VkVideoEncodeH265TransformBlockSizeFlagBitsEXT".enumType
val VkVideoEncodeH265RateControlFlagBitsEXT = "VkVideoEncodeH265RateControlFlagBitsEXT".enumType
val VkVideoDecodeH264PictureLayoutFlagBitsKHR = "VkVideoDecodeH264PictureLayoutFlagBitsKHR".enumType
val VkShaderInfoTypeAMD = "VkShaderInfoTypeAMD".enumType
val VkRenderingFlagBitsKHR = "VkRenderingFlagBitsKHR".enumType
val VkExternalMemoryHandleTypeFlagBitsNV = "VkExternalMemoryHandleTypeFlagBitsNV".enumType
val VkExternalMemoryFeatureFlagBitsNV = "VkExternalMemoryFeatureFlagBitsNV".enumType
val VkPeerMemoryFeatureFlagBitsKHR = "VkPeerMemoryFeatureFlagBitsKHR".enumType
val VkMemoryAllocateFlagBitsKHR = "VkMemoryAllocateFlagBitsKHR".enumType
val VkValidationCheckEXT = "VkValidationCheckEXT".enumType
val VkPipelineRobustnessBufferBehaviorEXT = "VkPipelineRobustnessBufferBehaviorEXT".enumType
val VkPipelineRobustnessImageBehaviorEXT = "VkPipelineRobustnessImageBehaviorEXT".enumType
val VkExternalMemoryHandleTypeFlagBitsKHR = "VkExternalMemoryHandleTypeFlagBitsKHR".enumType
val VkExternalMemoryFeatureFlagBitsKHR = "VkExternalMemoryFeatureFlagBitsKHR".enumType
val VkExternalSemaphoreHandleTypeFlagBitsKHR = "VkExternalSemaphoreHandleTypeFlagBitsKHR".enumType
val VkExternalSemaphoreFeatureFlagBitsKHR = "VkExternalSemaphoreFeatureFlagBitsKHR".enumType
val VkSemaphoreImportFlagBitsKHR = "VkSemaphoreImportFlagBitsKHR".enumType
val VkConditionalRenderingFlagBitsEXT = "VkConditionalRenderingFlagBitsEXT".enumType
val VkDescriptorUpdateTemplateTypeKHR = "VkDescriptorUpdateTemplateTypeKHR".enumType
val VkSurfaceCounterFlagBitsEXT = "VkSurfaceCounterFlagBitsEXT".enumType
val VkDisplayPowerStateEXT = "VkDisplayPowerStateEXT".enumType
val VkDeviceEventTypeEXT = "VkDeviceEventTypeEXT".enumType
val VkDisplayEventTypeEXT = "VkDisplayEventTypeEXT".enumType
val VkViewportCoordinateSwizzleNV = "VkViewportCoordinateSwizzleNV".enumType
val VkDiscardRectangleModeEXT = "VkDiscardRectangleModeEXT".enumType
val VkConservativeRasterizationModeEXT = "VkConservativeRasterizationModeEXT".enumType
val VkExternalFenceHandleTypeFlagBitsKHR = "VkExternalFenceHandleTypeFlagBitsKHR".enumType
val VkExternalFenceFeatureFlagBitsKHR = "VkExternalFenceFeatureFlagBitsKHR".enumType
val VkFenceImportFlagBitsKHR = "VkFenceImportFlagBitsKHR".enumType
val VkPerformanceCounterUnitKHR = "VkPerformanceCounterUnitKHR".enumType
val VkPerformanceCounterScopeKHR = "VkPerformanceCounterScopeKHR".enumType
val VkPerformanceCounterStorageKHR = "VkPerformanceCounterStorageKHR".enumType
val VkPerformanceCounterDescriptionFlagBitsKHR = "VkPerformanceCounterDescriptionFlagBitsKHR".enumType
val VkAcquireProfilingLockFlagBitsKHR = "VkAcquireProfilingLockFlagBitsKHR".enumType
val VkPointClippingBehaviorKHR = "VkPointClippingBehaviorKHR".enumType
val VkTessellationDomainOriginKHR = "VkTessellationDomainOriginKHR".enumType
val VkDebugUtilsMessageSeverityFlagBitsEXT = "VkDebugUtilsMessageSeverityFlagBitsEXT".enumType
val VkDebugUtilsMessageTypeFlagBitsEXT = "VkDebugUtilsMessageTypeFlagBitsEXT".enumType
val VkSamplerReductionModeEXT = "VkSamplerReductionModeEXT".enumType
val VkBlendOverlapEXT = "VkBlendOverlapEXT".enumType
val VkAccelerationStructureTypeKHR = "VkAccelerationStructureTypeKHR".enumType
val VkBuildAccelerationStructureModeKHR = "VkBuildAccelerationStructureModeKHR".enumType
val VkGeometryTypeKHR = "VkGeometryTypeKHR".enumType
val VkAccelerationStructureBuildTypeKHR = "VkAccelerationStructureBuildTypeKHR".enumType
val VkGeometryFlagBitsKHR = "VkGeometryFlagBitsKHR".enumType
val VkGeometryInstanceFlagBitsKHR = "VkGeometryInstanceFlagBitsKHR".enumType
val VkBuildAccelerationStructureFlagBitsKHR = "VkBuildAccelerationStructureFlagBitsKHR".enumType
val VkCopyAccelerationStructureModeKHR = "VkCopyAccelerationStructureModeKHR".enumType
val VkAccelerationStructureCompatibilityKHR = "VkAccelerationStructureCompatibilityKHR".enumType
val VkAccelerationStructureCreateFlagBitsKHR = "VkAccelerationStructureCreateFlagBitsKHR".enumType
val VkRayTracingShaderGroupTypeKHR = "VkRayTracingShaderGroupTypeKHR".enumType
val VkShaderGroupShaderKHR = "VkShaderGroupShaderKHR".enumType
val VkCoverageModulationModeNV = "VkCoverageModulationModeNV".enumType
val VkSamplerYcbcrModelConversionKHR = "VkSamplerYcbcrModelConversionKHR".enumType
val VkSamplerYcbcrRangeKHR = "VkSamplerYcbcrRangeKHR".enumType
val VkChromaLocationKHR = "VkChromaLocationKHR".enumType
val VkValidationCacheHeaderVersionEXT = "VkValidationCacheHeaderVersionEXT".enumType
val VkDescriptorBindingFlagBitsEXT = "VkDescriptorBindingFlagBitsEXT".enumType
val VkShadingRatePaletteEntryNV = "VkShadingRatePaletteEntryNV".enumType
val VkCoarseSampleOrderTypeNV = "VkCoarseSampleOrderTypeNV".enumType
val VkRayTracingShaderGroupTypeNV = "VkRayTracingShaderGroupTypeNV".enumType
val VkGeometryTypeNV = "VkGeometryTypeNV".enumType
val VkAccelerationStructureTypeNV = "VkAccelerationStructureTypeNV".enumType
val VkGeometryFlagBitsNV = "VkGeometryFlagBitsNV".enumType
val VkGeometryInstanceFlagBitsNV = "VkGeometryInstanceFlagBitsNV".enumType
val VkBuildAccelerationStructureFlagBitsNV = "VkBuildAccelerationStructureFlagBitsNV".enumType
val VkCopyAccelerationStructureModeNV = "VkCopyAccelerationStructureModeNV".enumType
val VkAccelerationStructureMemoryRequirementsTypeNV = "VkAccelerationStructureMemoryRequirementsTypeNV".enumType
val VkQueueGlobalPriorityKHR = "VkQueueGlobalPriorityKHR".enumType
val VkQueueGlobalPriorityEXT = "VkQueueGlobalPriorityEXT".enumType
val VkPipelineCompilerControlFlagBitsAMD = "VkPipelineCompilerControlFlagBitsAMD".enumType
val VkTimeDomainEXT = "VkTimeDomainEXT".enumType
val VkMemoryOverallocationBehaviorAMD = "VkMemoryOverallocationBehaviorAMD".enumType
val VkPipelineCreationFeedbackFlagBitsEXT = "VkPipelineCreationFeedbackFlagBitsEXT".enumType
val VkDriverIdKHR = "VkDriverIdKHR".enumType
val VkShaderFloatControlsIndependenceKHR = "VkShaderFloatControlsIndependenceKHR".enumType
val VkResolveModeFlagBitsKHR = "VkResolveModeFlagBitsKHR".enumType
val VkSemaphoreTypeKHR = "VkSemaphoreTypeKHR".enumType
val VkSemaphoreWaitFlagBitsKHR = "VkSemaphoreWaitFlagBitsKHR".enumType
val VkPerformanceConfigurationTypeINTEL = "VkPerformanceConfigurationTypeINTEL".enumType
val VkQueryPoolSamplingModeINTEL = "VkQueryPoolSamplingModeINTEL".enumType
val VkPerformanceOverrideTypeINTEL = "VkPerformanceOverrideTypeINTEL".enumType
val VkPerformanceParameterTypeINTEL = "VkPerformanceParameterTypeINTEL".enumType
val VkPerformanceValueTypeINTEL = "VkPerformanceValueTypeINTEL".enumType
val VkFragmentShadingRateCombinerOpKHR = "VkFragmentShadingRateCombinerOpKHR".enumType
val VkShaderCorePropertiesFlagBitsAMD = "VkShaderCorePropertiesFlagBitsAMD".enumType
val VkToolPurposeFlagBitsEXT = "VkToolPurposeFlagBitsEXT".enumType
val VkValidationFeatureEnableEXT = "VkValidationFeatureEnableEXT".enumType
val VkValidationFeatureDisableEXT = "VkValidationFeatureDisableEXT".enumType
val VkComponentTypeNV = "VkComponentTypeNV".enumType
val VkScopeNV = "VkScopeNV".enumType
val VkCoverageReductionModeNV = "VkCoverageReductionModeNV".enumType
val VkProvokingVertexModeEXT = "VkProvokingVertexModeEXT".enumType
val VkFullScreenExclusiveEXT = "VkFullScreenExclusiveEXT".enumType
val VkLineRasterizationModeEXT = "VkLineRasterizationModeEXT".enumType
val VkPipelineExecutableStatisticFormatKHR = "VkPipelineExecutableStatisticFormatKHR".enumType
val VkHostImageCopyFlagBitsEXT = "VkHostImageCopyFlagBitsEXT".enumType
val VkPresentScalingFlagBitsEXT = "VkPresentScalingFlagBitsEXT".enumType
val VkPresentGravityFlagBitsEXT = "VkPresentGravityFlagBitsEXT".enumType
val VkIndirectStateFlagBitsNV = "VkIndirectStateFlagBitsNV".enumType
val VkIndirectCommandsTokenTypeNV = "VkIndirectCommandsTokenTypeNV".enumType
val VkIndirectCommandsLayoutUsageFlagBitsNV = "VkIndirectCommandsLayoutUsageFlagBitsNV".enumType
val VkDepthBiasRepresentationEXT = "VkDepthBiasRepresentationEXT".enumType
val VkDeviceMemoryReportEventTypeEXT = "VkDeviceMemoryReportEventTypeEXT".enumType
val VkPipelineCacheCreateFlagBits = "VkPipelineCacheCreateFlagBits".enumType
val VkVideoEncodeCapabilityFlagBitsKHR = "VkVideoEncodeCapabilityFlagBitsKHR".enumType
val VkVideoEncodeFeedbackFlagBitsKHR = "VkVideoEncodeFeedbackFlagBitsKHR".enumType
val VkVideoEncodeUsageFlagBitsKHR = "VkVideoEncodeUsageFlagBitsKHR".enumType
val VkVideoEncodeContentFlagBitsKHR = "VkVideoEncodeContentFlagBitsKHR".enumType
val VkVideoEncodeTuningModeKHR = "VkVideoEncodeTuningModeKHR".enumType
val VkVideoEncodeRateControlModeFlagBitsKHR = "VkVideoEncodeRateControlModeFlagBitsKHR".enumType
val VkDeviceDiagnosticsConfigFlagBitsNV = "VkDeviceDiagnosticsConfigFlagBitsNV".enumType
val VkExportMetalObjectTypeFlagBitsEXT = "VkExportMetalObjectTypeFlagBitsEXT".enumType
val VkPipelineStageFlagBits2KHR = "VkPipelineStageFlagBits2KHR".enumType
val VkAccessFlagBits2KHR = "VkAccessFlagBits2KHR".enumType
val VkSubmitFlagBitsKHR = "VkSubmitFlagBitsKHR".enumType
val VkGraphicsPipelineLibraryFlagBitsEXT = "VkGraphicsPipelineLibraryFlagBitsEXT".enumType
val VkPipelineLayoutCreateFlagBits = "VkPipelineLayoutCreateFlagBits".enumType
val VkFragmentShadingRateTypeNV = "VkFragmentShadingRateTypeNV".enumType
val VkFragmentShadingRateNV = "VkFragmentShadingRateNV".enumType
val VkAccelerationStructureMotionInstanceTypeNV = "VkAccelerationStructureMotionInstanceTypeNV".enumType
val VkImageCompressionFlagBitsEXT = "VkImageCompressionFlagBitsEXT".enumType
val VkImageCompressionFixedRateFlagBitsEXT = "VkImageCompressionFixedRateFlagBitsEXT".enumType
val VkDeviceFaultAddressTypeEXT = "VkDeviceFaultAddressTypeEXT".enumType
val VkDeviceFaultVendorBinaryHeaderVersionEXT = "VkDeviceFaultVendorBinaryHeaderVersionEXT".enumType
val VkDeviceAddressBindingTypeEXT = "VkDeviceAddressBindingTypeEXT".enumType
val VkDeviceAddressBindingFlagBitsEXT = "VkDeviceAddressBindingFlagBitsEXT".enumType
val VkFormatFeatureFlagBits2KHR = "VkFormatFeatureFlagBits2KHR".enumType
val VkFrameBoundaryFlagBitsEXT = "VkFrameBoundaryFlagBitsEXT".enumType
val VkMicromapTypeEXT = "VkMicromapTypeEXT".enumType
val VkBuildMicromapModeEXT = "VkBuildMicromapModeEXT".enumType
val VkBuildMicromapFlagBitsEXT = "VkBuildMicromapFlagBitsEXT".enumType
val VkCopyMicromapModeEXT = "VkCopyMicromapModeEXT".enumType
val VkMicromapCreateFlagBitsEXT = "VkMicromapCreateFlagBitsEXT".enumType
val VkOpacityMicromapFormatEXT = "VkOpacityMicromapFormatEXT".enumType
val VkOpacityMicromapSpecialIndexEXT = "VkOpacityMicromapSpecialIndexEXT".enumType
val VkDisplacementMicromapFormatNV = "VkDisplacementMicromapFormatNV".enumType
val VkMemoryDecompressionMethodFlagBitsNV = "VkMemoryDecompressionMethodFlagBitsNV".enumType
val VkSubpassMergeStatusEXT = "VkSubpassMergeStatusEXT".enumType
val VkDirectDriverLoadingModeLUNARG = "VkDirectDriverLoadingModeLUNARG".enumType
val VkPipelineColorBlendStateCreateFlagBits = "VkPipelineColorBlendStateCreateFlagBits".enumType
val VkPipelineDepthStencilStateCreateFlagBits = "VkPipelineDepthStencilStateCreateFlagBits".enumType
val VkOpticalFlowUsageFlagBitsNV = "VkOpticalFlowUsageFlagBitsNV".enumType
val VkOpticalFlowGridSizeFlagBitsNV = "VkOpticalFlowGridSizeFlagBitsNV".enumType
val VkOpticalFlowPerformanceLevelNV = "VkOpticalFlowPerformanceLevelNV".enumType
val VkOpticalFlowSessionBindingPointNV = "VkOpticalFlowSessionBindingPointNV".enumType
val VkOpticalFlowSessionCreateFlagBitsNV = "VkOpticalFlowSessionCreateFlagBitsNV".enumType
val VkOpticalFlowExecuteFlagBitsNV = "VkOpticalFlowExecuteFlagBitsNV".enumType
val VkPipelineCreateFlagBits2KHR = "VkPipelineCreateFlagBits2KHR".enumType
val VkBufferUsageFlagBits2KHR = "VkBufferUsageFlagBits2KHR".enumType
val VkShaderCreateFlagBitsEXT = "VkShaderCreateFlagBitsEXT".enumType
val VkShaderCodeTypeEXT = "VkShaderCodeTypeEXT".enumType
val VkRayTracingInvocationReorderModeNV = "VkRayTracingInvocationReorderModeNV".enumType
val VkComponentTypeKHR = "VkComponentTypeKHR".enumType
val VkScopeKHR = "VkScopeKHR".enumType
val VkBlockMatchWindowCompareModeQCOM = "VkBlockMatchWindowCompareModeQCOM".enumType
val VkCubicFilterWeightsQCOM = "VkCubicFilterWeightsQCOM".enumType
val VkLayeredDriverUnderlyingApiMSFT = "VkLayeredDriverUnderlyingApiMSFT".enumType

// Bitmask types
val VkCompositeAlphaFlagsKHR = typedef(VkFlags, "VkCompositeAlphaFlagsKHR")
val VkSurfaceTransformFlagsKHR = typedef(VkFlags, "VkSurfaceTransformFlagsKHR")
val VkSwapchainCreateFlagsKHR = typedef(VkFlags, "VkSwapchainCreateFlagsKHR")
val VkDeviceGroupPresentModeFlagsKHR = typedef(VkFlags, "VkDeviceGroupPresentModeFlagsKHR")
val VkDisplayModeCreateFlagsKHR = typedef(VkFlags, "VkDisplayModeCreateFlagsKHR")
val VkDisplayPlaneAlphaFlagsKHR = typedef(VkFlags, "VkDisplayPlaneAlphaFlagsKHR")
val VkDisplaySurfaceCreateFlagsKHR = typedef(VkFlags, "VkDisplaySurfaceCreateFlagsKHR")
val VkXlibSurfaceCreateFlagsKHR = typedef(VkFlags, "VkXlibSurfaceCreateFlagsKHR")
val VkXcbSurfaceCreateFlagsKHR = typedef(VkFlags, "VkXcbSurfaceCreateFlagsKHR")
val VkWaylandSurfaceCreateFlagsKHR = typedef(VkFlags, "VkWaylandSurfaceCreateFlagsKHR")
val VkAndroidSurfaceCreateFlagsKHR = typedef(VkFlags, "VkAndroidSurfaceCreateFlagsKHR")
val VkWin32SurfaceCreateFlagsKHR = typedef(VkFlags, "VkWin32SurfaceCreateFlagsKHR")
val VkDebugReportFlagsEXT = typedef(VkFlags, "VkDebugReportFlagsEXT")
val VkVideoCodecOperationFlagsKHR = typedef(VkFlags, "VkVideoCodecOperationFlagsKHR")
val VkVideoChromaSubsamplingFlagsKHR = typedef(VkFlags, "VkVideoChromaSubsamplingFlagsKHR")
val VkVideoComponentBitDepthFlagsKHR = typedef(VkFlags, "VkVideoComponentBitDepthFlagsKHR")
val VkVideoCapabilityFlagsKHR = typedef(VkFlags, "VkVideoCapabilityFlagsKHR")
val VkVideoSessionCreateFlagsKHR = typedef(VkFlags, "VkVideoSessionCreateFlagsKHR")
val VkVideoSessionParametersCreateFlagsKHR = typedef(VkFlags, "VkVideoSessionParametersCreateFlagsKHR")
val VkVideoBeginCodingFlagsKHR = typedef(VkFlags, "VkVideoBeginCodingFlagsKHR")
val VkVideoEndCodingFlagsKHR = typedef(VkFlags, "VkVideoEndCodingFlagsKHR")
val VkVideoCodingControlFlagsKHR = typedef(VkFlags, "VkVideoCodingControlFlagsKHR")
val VkVideoDecodeCapabilityFlagsKHR = typedef(VkFlags, "VkVideoDecodeCapabilityFlagsKHR")
val VkVideoDecodeUsageFlagsKHR = typedef(VkFlags, "VkVideoDecodeUsageFlagsKHR")
val VkVideoDecodeFlagsKHR = typedef(VkFlags, "VkVideoDecodeFlagsKHR")
val VkPipelineRasterizationStateStreamCreateFlagsEXT = typedef(VkFlags, "VkPipelineRasterizationStateStreamCreateFlagsEXT")
val VkVideoEncodeH264CapabilityFlagsEXT = typedef(VkFlags, "VkVideoEncodeH264CapabilityFlagsEXT")
val VkVideoEncodeH264StdFlagsEXT = typedef(VkFlags, "VkVideoEncodeH264StdFlagsEXT")
val VkVideoEncodeH264RateControlFlagsEXT = typedef(VkFlags, "VkVideoEncodeH264RateControlFlagsEXT")
val VkVideoEncodeH265CapabilityFlagsEXT = typedef(VkFlags, "VkVideoEncodeH265CapabilityFlagsEXT")
val VkVideoEncodeH265StdFlagsEXT = typedef(VkFlags, "VkVideoEncodeH265StdFlagsEXT")
val VkVideoEncodeH265CtbSizeFlagsEXT = typedef(VkFlags, "VkVideoEncodeH265CtbSizeFlagsEXT")
val VkVideoEncodeH265TransformBlockSizeFlagsEXT = typedef(VkFlags, "VkVideoEncodeH265TransformBlockSizeFlagsEXT")
val VkVideoEncodeH265RateControlFlagsEXT = typedef(VkFlags, "VkVideoEncodeH265RateControlFlagsEXT")
val VkVideoDecodeH264PictureLayoutFlagsKHR = typedef(VkFlags, "VkVideoDecodeH264PictureLayoutFlagsKHR")
val VkRenderingFlagsKHR = typedef(VkFlags, "VkRenderingFlagsKHR")
val VkExternalMemoryHandleTypeFlagsNV = typedef(VkFlags, "VkExternalMemoryHandleTypeFlagsNV")
val VkExternalMemoryFeatureFlagsNV = typedef(VkFlags, "VkExternalMemoryFeatureFlagsNV")
val VkPeerMemoryFeatureFlagsKHR = typedef(VkFlags, "VkPeerMemoryFeatureFlagsKHR")
val VkMemoryAllocateFlagsKHR = typedef(VkFlags, "VkMemoryAllocateFlagsKHR")
val VkCommandPoolTrimFlagsKHR = typedef(VkFlags, "VkCommandPoolTrimFlagsKHR")
val VkExternalMemoryHandleTypeFlagsKHR = typedef(VkFlags, "VkExternalMemoryHandleTypeFlagsKHR")
val VkExternalMemoryFeatureFlagsKHR = typedef(VkFlags, "VkExternalMemoryFeatureFlagsKHR")
val VkExternalSemaphoreHandleTypeFlagsKHR = typedef(VkFlags, "VkExternalSemaphoreHandleTypeFlagsKHR")
val VkExternalSemaphoreFeatureFlagsKHR = typedef(VkFlags, "VkExternalSemaphoreFeatureFlagsKHR")
val VkSemaphoreImportFlagsKHR = typedef(VkFlags, "VkSemaphoreImportFlagsKHR")
val VkConditionalRenderingFlagsEXT = typedef(VkFlags, "VkConditionalRenderingFlagsEXT")
val VkDescriptorUpdateTemplateCreateFlagsKHR = typedef(VkFlags, "VkDescriptorUpdateTemplateCreateFlagsKHR")
val VkSurfaceCounterFlagsEXT = typedef(VkFlags, "VkSurfaceCounterFlagsEXT")
val VkPipelineViewportSwizzleStateCreateFlagsNV = typedef(VkFlags, "VkPipelineViewportSwizzleStateCreateFlagsNV")
val VkPipelineDiscardRectangleStateCreateFlagsEXT = typedef(VkFlags, "VkPipelineDiscardRectangleStateCreateFlagsEXT")
val VkPipelineRasterizationConservativeStateCreateFlagsEXT = typedef(VkFlags, "VkPipelineRasterizationConservativeStateCreateFlagsEXT")
val VkPipelineRasterizationDepthClipStateCreateFlagsEXT = typedef(VkFlags, "VkPipelineRasterizationDepthClipStateCreateFlagsEXT")
val VkExternalFenceHandleTypeFlagsKHR = typedef(VkFlags, "VkExternalFenceHandleTypeFlagsKHR")
val VkExternalFenceFeatureFlagsKHR = typedef(VkFlags, "VkExternalFenceFeatureFlagsKHR")
val VkFenceImportFlagsKHR = typedef(VkFlags, "VkFenceImportFlagsKHR")
val VkPerformanceCounterDescriptionFlagsKHR = typedef(VkFlags, "VkPerformanceCounterDescriptionFlagsKHR")
val VkAcquireProfilingLockFlagsKHR = typedef(VkFlags, "VkAcquireProfilingLockFlagsKHR")
val VkMacOSSurfaceCreateFlagsMVK = typedef(VkFlags, "VkMacOSSurfaceCreateFlagsMVK")
val VkDebugUtilsMessageTypeFlagsEXT = typedef(VkFlags, "VkDebugUtilsMessageTypeFlagsEXT")
val VkDebugUtilsMessengerCallbackDataFlagsEXT = typedef(VkFlags, "VkDebugUtilsMessengerCallbackDataFlagsEXT")
val VkDebugUtilsMessageSeverityFlagsEXT = typedef(VkFlags, "VkDebugUtilsMessageSeverityFlagsEXT")
val VkDebugUtilsMessengerCreateFlagsEXT = typedef(VkFlags, "VkDebugUtilsMessengerCreateFlagsEXT")
val VkPipelineCoverageToColorStateCreateFlagsNV = typedef(VkFlags, "VkPipelineCoverageToColorStateCreateFlagsNV")
val VkBuildAccelerationStructureFlagsKHR = typedef(VkFlags, "VkBuildAccelerationStructureFlagsKHR")
val VkGeometryFlagsKHR = typedef(VkFlags, "VkGeometryFlagsKHR")
val VkGeometryInstanceFlagsKHR = typedef(VkFlags, "VkGeometryInstanceFlagsKHR")
val VkAccelerationStructureCreateFlagsKHR = typedef(VkFlags, "VkAccelerationStructureCreateFlagsKHR")
val VkPipelineCoverageModulationStateCreateFlagsNV = typedef(VkFlags, "VkPipelineCoverageModulationStateCreateFlagsNV")
val VkValidationCacheCreateFlagsEXT = typedef(VkFlags, "VkValidationCacheCreateFlagsEXT")
val VkDescriptorBindingFlagsEXT = typedef(VkFlags, "VkDescriptorBindingFlagsEXT")
val VkGeometryFlagsNV = typedef(VkFlags, "VkGeometryFlagsNV")
val VkGeometryInstanceFlagsNV = typedef(VkFlags, "VkGeometryInstanceFlagsNV")
val VkBuildAccelerationStructureFlagsNV = typedef(VkFlags, "VkBuildAccelerationStructureFlagsNV")
val VkPipelineCompilerControlFlagsAMD = typedef(VkFlags, "VkPipelineCompilerControlFlagsAMD")
val VkPipelineCreationFeedbackFlagsEXT = typedef(VkFlags, "VkPipelineCreationFeedbackFlagsEXT")
val VkResolveModeFlagsKHR = typedef(VkFlags, "VkResolveModeFlagsKHR")
val VkSemaphoreWaitFlagsKHR = typedef(VkFlags, "VkSemaphoreWaitFlagsKHR")
val VkMetalSurfaceCreateFlagsEXT = typedef(VkFlags, "VkMetalSurfaceCreateFlagsEXT")
val VkShaderCorePropertiesFlagsAMD = typedef(VkFlags, "VkShaderCorePropertiesFlagsAMD")
val VkToolPurposeFlagsEXT = typedef(VkFlags, "VkToolPurposeFlagsEXT")
val VkPipelineCoverageReductionStateCreateFlagsNV = typedef(VkFlags, "VkPipelineCoverageReductionStateCreateFlagsNV")
val VkHeadlessSurfaceCreateFlagsEXT = typedef(VkFlags, "VkHeadlessSurfaceCreateFlagsEXT")
val VkHostImageCopyFlagsEXT = typedef(VkFlags, "VkHostImageCopyFlagsEXT")
val VkMemoryUnmapFlagsKHR = typedef(VkFlags, "VkMemoryUnmapFlagsKHR")
val VkPresentScalingFlagsEXT = typedef(VkFlags, "VkPresentScalingFlagsEXT")
val VkPresentGravityFlagsEXT = typedef(VkFlags, "VkPresentGravityFlagsEXT")
val VkIndirectStateFlagsNV = typedef(VkFlags, "VkIndirectStateFlagsNV")
val VkIndirectCommandsLayoutUsageFlagsNV = typedef(VkFlags, "VkIndirectCommandsLayoutUsageFlagsNV")
val VkDeviceMemoryReportFlagsEXT = typedef(VkFlags, "VkDeviceMemoryReportFlagsEXT")
val VkPrivateDataSlotCreateFlagsEXT = typedef(VkFlags, "VkPrivateDataSlotCreateFlagsEXT")
val VkVideoEncodeFlagsKHR = typedef(VkFlags, "VkVideoEncodeFlagsKHR")
val VkVideoEncodeCapabilityFlagsKHR = typedef(VkFlags, "VkVideoEncodeCapabilityFlagsKHR")
val VkVideoEncodeRateControlModeFlagsKHR = typedef(VkFlags, "VkVideoEncodeRateControlModeFlagsKHR")
val VkVideoEncodeFeedbackFlagsKHR = typedef(VkFlags, "VkVideoEncodeFeedbackFlagsKHR")
val VkVideoEncodeUsageFlagsKHR = typedef(VkFlags, "VkVideoEncodeUsageFlagsKHR")
val VkVideoEncodeContentFlagsKHR = typedef(VkFlags, "VkVideoEncodeContentFlagsKHR")
val VkVideoEncodeRateControlFlagsKHR = typedef(VkFlags, "VkVideoEncodeRateControlFlagsKHR")
val VkDeviceDiagnosticsConfigFlagsNV = typedef(VkFlags, "VkDeviceDiagnosticsConfigFlagsNV")
val VkExportMetalObjectTypeFlagsEXT = typedef(VkFlags, "VkExportMetalObjectTypeFlagsEXT")
val VkPipelineStageFlags2KHR = typedef(VkFlags64, "VkPipelineStageFlags2KHR")
val VkAccessFlags2KHR = typedef(VkFlags64, "VkAccessFlags2KHR")
val VkSubmitFlagsKHR = typedef(VkFlags, "VkSubmitFlagsKHR")
val VkGraphicsPipelineLibraryFlagsEXT = typedef(VkFlags, "VkGraphicsPipelineLibraryFlagsEXT")
val VkAccelerationStructureMotionInfoFlagsNV = typedef(VkFlags, "VkAccelerationStructureMotionInfoFlagsNV")
val VkAccelerationStructureMotionInstanceFlagsNV = typedef(VkFlags, "VkAccelerationStructureMotionInstanceFlagsNV")
val VkImageCompressionFlagsEXT = typedef(VkFlags, "VkImageCompressionFlagsEXT")
val VkImageCompressionFixedRateFlagsEXT = typedef(VkFlags, "VkImageCompressionFixedRateFlagsEXT")
val VkDirectFBSurfaceCreateFlagsEXT = typedef(VkFlags, "VkDirectFBSurfaceCreateFlagsEXT")
val VkDeviceAddressBindingFlagsEXT = typedef(VkFlags, "VkDeviceAddressBindingFlagsEXT")
val VkFormatFeatureFlags2KHR = typedef(VkFlags64, "VkFormatFeatureFlags2KHR")
val VkFrameBoundaryFlagsEXT = typedef(VkFlags, "VkFrameBoundaryFlagsEXT")
val VkBuildMicromapFlagsEXT = typedef(VkFlags, "VkBuildMicromapFlagsEXT")
val VkMicromapCreateFlagsEXT = typedef(VkFlags, "VkMicromapCreateFlagsEXT")
val VkMemoryDecompressionMethodFlagsNV = typedef(VkFlags64, "VkMemoryDecompressionMethodFlagsNV")
val VkDirectDriverLoadingFlagsLUNARG = typedef(VkFlags, "VkDirectDriverLoadingFlagsLUNARG")
val VkOpticalFlowGridSizeFlagsNV = typedef(VkFlags, "VkOpticalFlowGridSizeFlagsNV")
val VkOpticalFlowUsageFlagsNV = typedef(VkFlags, "VkOpticalFlowUsageFlagsNV")
val VkOpticalFlowSessionCreateFlagsNV = typedef(VkFlags, "VkOpticalFlowSessionCreateFlagsNV")
val VkOpticalFlowExecuteFlagsNV = typedef(VkFlags, "VkOpticalFlowExecuteFlagsNV")
val VkPipelineCreateFlags2KHR = typedef(VkFlags64, "VkPipelineCreateFlags2KHR")
val VkBufferUsageFlags2KHR = typedef(VkFlags64, "VkBufferUsageFlags2KHR")
val VkShaderCreateFlagsEXT = typedef(VkFlags, "VkShaderCreateFlagsEXT")

// Function pointer types
val PFN_vkDebugReportCallbackEXT = Module.VULKAN.callback {
    VkBool32(
        "VkDebugReportCallbackEXT",
        "Application-defined debug report callback function.",

        VkDebugReportFlagsEXT("flags", "specifies the {@code VkDebugReportFlagBitsEXT} that triggered this callback."),
        VkDebugReportObjectTypeEXT("objectType", "a {@code VkDebugReportObjectTypeEXT} value specifying the type of object being used or created at the time the event was triggered."),
        uint64_t("object", "the object where the issue was detected. If {@code objectType} is #DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT, {@code object} is undefined."),
        size_t("location", "a component (layer, driver, loader) defined value specifying the <em>location</em> of the trigger. This is an <b>optional</b> value."),
        int32_t("messageCode", "a layer-defined value indicating what test triggered this callback."),
        charUTF8.const.p("pLayerPrefix", "a null-terminated string that is an abbreviation of the name of the component making the callback. {@code pLayerPrefix} is only valid for the duration of the callback."),
        charUTF8.const.p("pMessage", "a null-terminated string detailing the trigger conditions. {@code pMessage} is only valid for the duration of the callback."),
        opaque_p("pUserData", "the user data given when the {@code VkDebugReportCallbackEXT} was created."),

        nativeType = "PFN_vkDebugReportCallbackEXT"
    ) {
        documentation =
        """
        Application-defined debug report callback function.

        <h5>C Specification</h5>
        The prototype for the ##VkDebugReportCallbackCreateInfoEXT{@code ::pfnCallback} function implemented by the application is:

        <pre><code>
￿typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
￿    VkDebugReportFlagsEXT                       flags,
￿    VkDebugReportObjectTypeEXT                  objectType,
￿    uint64_t                                    object,
￿    size_t                                      location,
￿    int32_t                                     messageCode,
￿    const char*                                 pLayerPrefix,
￿    const char*                                 pMessage,
￿    void*                                       pUserData);</code></pre>

        <h5>Description</h5>
        The callback <b>must</b> not call {@code vkDestroyDebugReportCallbackEXT}.

        The callback returns a {@code VkBool32}, which is interpreted in a layer-specified manner. The application <b>should</b> always return #FALSE. The #TRUE value is reserved for use in layer development.

        {@code object} <b>must</b> be a Vulkan object or #NULL_HANDLE. If {@code objectType} is not #DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT and {@code object} is not #NULL_HANDLE, {@code object} <b>must</b> be a Vulkan object of the corresponding type associated with {@code objectType} as defined in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#debug-report-object-types">{@code VkDebugReportObjectTypeEXT} and Vulkan Handle Relationship</a>.

        <h5>See Also</h5>
        ##VkDebugReportCallbackCreateInfoEXT
        """
    }
}

val _VkDebugUtilsMessengerCallbackDataEXT = struct(Module.VULKAN, "VkDebugUtilsMessengerCallbackDataEXT")
val PFN_vkDebugUtilsMessengerCallbackEXT = Module.VULKAN.callback {
    VkBool32(
        "VkDebugUtilsMessengerCallbackEXT",
        "Application-defined debug messenger callback function.",

        VkDebugUtilsMessageSeverityFlagBitsEXT("messageSeverity", "specifies the {@code VkDebugUtilsMessageSeverityFlagBitsEXT} that triggered this callback."),
        VkDebugUtilsMessageTypeFlagsEXT("messageTypes", "a bitmask of {@code VkDebugUtilsMessageTypeFlagBitsEXT} specifying which type of event(s) triggered this callback."),
        _VkDebugUtilsMessengerCallbackDataEXT.const.p("pCallbackData", "contains all the callback related data in the ##VkDebugUtilsMessengerCallbackDataEXT structure."),
        opaque_p("pUserData", "the user data provided when the {@code VkDebugUtilsMessengerEXT} was created."),

        nativeType = "PFN_vkDebugUtilsMessengerCallbackEXT"
    ) {
        documentation =
        """
        Application-defined debug messenger callback function.

        <h5>C Specification</h5>
        The prototype for the ##VkDebugUtilsMessengerCreateInfoEXT{@code ::pfnUserCallback} function implemented by the application is:

        <pre><code>
￿typedef VkBool32 (VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)(
￿    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,
￿    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,
￿    const VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,
￿    void*                                            pUserData);</code></pre>

        <h5>Description</h5>
        The callback returns a {@code VkBool32}, which is interpreted in a layer-specified manner. The application <b>should</b> always return #FALSE. The #TRUE value is reserved for use in layer development.

        <h5>Valid Usage</h5>
        <ul>
            <li>The callback <b>must</b> not make calls to any Vulkan commands</li>
        </ul>

        <h5>See Also</h5>
        ##VkDebugUtilsMessengerCreateInfoEXT
        """
    }
}

val _VkDeviceMemoryReportCallbackDataEXT = struct(Module.VULKAN, "VkDeviceMemoryReportCallbackDataEXT")
val PFN_vkDeviceMemoryReportCallbackEXT = Module.VULKAN.callback {
    void(
        "VkDeviceMemoryReportCallbackEXT",
        "Application-defined device memory report callback function.",

        _VkDeviceMemoryReportCallbackDataEXT.const.p("pCallbackData", "contains all the callback related data in the ##VkDeviceMemoryReportCallbackDataEXT structure."),
        opaque_p("pUserData", "the user data provided when the ##VkDeviceDeviceMemoryReportCreateInfoEXT was created."),

        nativeType = "PFN_vkDeviceMemoryReportCallbackEXT"
    ) {
        documentation =
        """
        Application-defined device memory report callback function.

        <h5>C Specification</h5>
        The prototype for the ##VkDeviceDeviceMemoryReportCreateInfoEXT{@code ::pfnUserCallback} function implemented by the application is:

        <pre><code>
￿typedef void (VKAPI_PTR *PFN_vkDeviceMemoryReportCallbackEXT)(
￿    const VkDeviceMemoryReportCallbackDataEXT*  pCallbackData,
￿    void*                                       pUserData);</code></pre>

        <h5>Description</h5>
        The callback <b>must</b> not make calls to any Vulkan commands.

        <h5>See Also</h5>
        ##VkDeviceDeviceMemoryReportCreateInfoEXT
        """
    }
}

// Struct types
val VkSurfaceCapabilitiesKHR = struct(Module.VULKAN, "VkSurfaceCapabilitiesKHR", mutable = false) {
    documentation =
        """
        Structure describing capabilities of a surface.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Supported usage flags of a presentable image when using #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR presentation mode are provided by ##VkSharedPresentSurfaceCapabilitiesKHR{@code ::sharedPresentSupportedUsageFlags}.
        </div>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Formulas such as <code>min(N, maxImageCount)</code> are not correct, since {@code maxImageCount} <b>may</b> be zero.
        </div>

        <h5>See Also</h5>
        ##VkExtent2D, ##VkSurfaceCapabilities2KHR, #GetPhysicalDeviceSurfaceCapabilitiesKHR()
        """

    uint32_t("minImageCount", "the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.")
    uint32_t("maxImageCount", "the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to {@code minImageCount}. A value of 0 means that there is no limit on the number of images, though there <b>may</b> be limits related to the total amount of memory used by presentable images.")
    VkExtent2D("currentExtent", "the current width and height of the surface, or the special value <code>(0xFFFFFFFF, 0xFFFFFFFF)</code> indicating that the surface size will be determined by the extent of a swapchain targeting the surface.")
    VkExtent2D("minImageExtent", "contains the smallest valid swapchain extent for the surface on the specified device. The {@code width} and {@code height} of the extent will each be less than or equal to the corresponding {@code width} and {@code height} of {@code currentExtent}, unless {@code currentExtent} has the special value described above.")
    VkExtent2D("maxImageExtent", "contains the largest valid swapchain extent for the surface on the specified device. The {@code width} and {@code height} of the extent will each be greater than or equal to the corresponding {@code width} and {@code height} of {@code minImageExtent}. The {@code width} and {@code height} of the extent will each be greater than or equal to the corresponding {@code width} and {@code height} of {@code currentExtent}, unless {@code currentExtent} has the special value described above.")
    uint32_t("maxImageArrayLayers", "the maximum number of layers presentable images <b>can</b> have for a swapchain created for this device and surface, and will be at least one.")
    VkSurfaceTransformFlagsKHR("supportedTransforms", "a bitmask of {@code VkSurfaceTransformFlagBitsKHR} indicating the presentation transforms supported for the surface on the specified device. At least one bit will be set.")
    VkSurfaceTransformFlagBitsKHR("currentTransform", "{@code VkSurfaceTransformFlagBitsKHR} value indicating the surface’s current transform relative to the presentation engine’s natural orientation.")
    VkCompositeAlphaFlagsKHR("supportedCompositeAlpha", "a bitmask of {@code VkCompositeAlphaFlagBitsKHR}, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition <b>can</b> be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.")
    VkImageUsageFlags("supportedUsageFlags", "a bitmask of {@code VkImageUsageFlagBits} representing the ways the application <b>can</b> use the presentable images of a swapchain created with {@code VkPresentModeKHR} set to #PRESENT_MODE_IMMEDIATE_KHR, #PRESENT_MODE_MAILBOX_KHR, #PRESENT_MODE_FIFO_KHR or #PRESENT_MODE_FIFO_RELAXED_KHR for the surface on the specified device. #IMAGE_USAGE_COLOR_ATTACHMENT_BIT <b>must</b> be included in the set. Implementations <b>may</b> support additional usages.")
}

val VkSurfaceFormatKHR = struct(Module.VULKAN, "VkSurfaceFormatKHR", mutable = false) {
    documentation =
        """
        Structure describing a supported swapchain format-color space pair.

        <h5>See Also</h5>
        ##VkSurfaceFormat2KHR, #GetPhysicalDeviceSurfaceFormatsKHR()
        """

    VkFormat("format", "a {@code VkFormat} that is compatible with the specified surface.")
    VkColorSpaceKHR("colorSpace", "a presentation {@code VkColorSpaceKHR} that is compatible with the surface.")
}

val VkSwapchainCreateInfoKHR = struct(Module.VULKAN, "VkSwapchainCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created swapchain object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code surface} <b>must</b> be a surface that is supported by the device as determined using #GetPhysicalDeviceSurfaceSupportKHR()</li>
            <li>{@code minImageCount} <b>must</b> be less than or equal to the value returned in the {@code maxImageCount} member of the ##VkSurfaceCapabilitiesKHR structure returned by {@code vkGetPhysicalDeviceSurfaceCapabilitiesKHR} for the surface if the returned {@code maxImageCount} is not zero</li>
            <li>If {@code presentMode} is not #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR nor #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, then {@code minImageCount} <b>must</b> be greater than or equal to the value returned in the {@code minImageCount} member of the ##VkSurfaceCapabilitiesKHR structure returned by #GetPhysicalDeviceSurfaceCapabilitiesKHR() for the surface</li>
            <li>{@code minImageCount} <b>must</b> be 1 if {@code presentMode} is either #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR</li>
            <li>{@code imageFormat} and {@code imageColorSpace} <b>must</b> match the {@code format} and {@code colorSpace} members, respectively, of one of the ##VkSurfaceFormatKHR structures returned by {@code vkGetPhysicalDeviceSurfaceFormatsKHR} for the surface</li>
            <li>If a ##VkSwapchainPresentScalingCreateInfoEXT structure was not included in the {@code pNext} chain, or it is included and ##VkSwapchainPresentScalingCreateInfoEXT{@code ::scalingBehavior} is zero then {@code imageExtent} <b>must</b> be between {@code minImageExtent} and {@code maxImageExtent}, inclusive, where {@code minImageExtent} and {@code maxImageExtent} are members of the ##VkSurfaceCapabilitiesKHR structure returned by {@code vkGetPhysicalDeviceSurfaceCapabilitiesKHR} for the surface</li>
            <li>If a ##VkSwapchainPresentScalingCreateInfoEXT structure was included in the {@code pNext} chain and ##VkSwapchainPresentScalingCreateInfoEXT{@code ::scalingBehavior} is not zero then {@code imageExtent} <b>must</b> be between {@code minScaledImageExtent} and {@code maxScaledImageExtent}, inclusive, where {@code minScaledImageExtent} and {@code maxScaledImageExtent} are members of the ##VkSurfacePresentScalingCapabilitiesEXT structure returned by {@code vkGetPhysicalDeviceSurfaceCapabilities2KHR} for the surface and {@code presentMode}</li>
            <li>{@code imageExtent} members {@code width} and {@code height} <b>must</b> both be non-zero</li>
            <li>{@code imageArrayLayers} <b>must</b> be greater than 0 and less than or equal to the {@code maxImageArrayLayers} member of the ##VkSurfaceCapabilitiesKHR structure returned by {@code vkGetPhysicalDeviceSurfaceCapabilitiesKHR} for the surface</li>
            <li>If {@code presentMode} is #PRESENT_MODE_IMMEDIATE_KHR, #PRESENT_MODE_MAILBOX_KHR, #PRESENT_MODE_FIFO_KHR or #PRESENT_MODE_FIFO_RELAXED_KHR, {@code imageUsage} <b>must</b> be a subset of the supported usage flags present in the {@code supportedUsageFlags} member of the ##VkSurfaceCapabilitiesKHR structure returned by #GetPhysicalDeviceSurfaceCapabilitiesKHR() for {@code surface}</li>
            <li>If {@code presentMode} is #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, {@code imageUsage} <b>must</b> be a subset of the supported usage flags present in the {@code sharedPresentSupportedUsageFlags} member of the ##VkSharedPresentSurfaceCapabilitiesKHR structure returned by #GetPhysicalDeviceSurfaceCapabilities2KHR() for {@code surface}</li>
            <li>If {@code imageSharingMode} is #SHARING_MODE_CONCURRENT, {@code pQueueFamilyIndices} <b>must</b> be a valid pointer to an array of {@code queueFamilyIndexCount} {@code uint32_t} values</li>
            <li>If {@code imageSharingMode} is #SHARING_MODE_CONCURRENT, {@code queueFamilyIndexCount} <b>must</b> be greater than 1</li>
            <li>If {@code imageSharingMode} is #SHARING_MODE_CONCURRENT, each element of {@code pQueueFamilyIndices} <b>must</b> be unique and <b>must</b> be less than {@code pQueueFamilyPropertyCount} returned by either #GetPhysicalDeviceQueueFamilyProperties() or #GetPhysicalDeviceQueueFamilyProperties2() for the {@code physicalDevice} that was used to create {@code device}</li>
            <li>{@code preTransform} <b>must</b> be one of the bits present in the {@code supportedTransforms} member of the ##VkSurfaceCapabilitiesKHR structure returned by {@code vkGetPhysicalDeviceSurfaceCapabilitiesKHR} for the surface</li>
            <li>{@code compositeAlpha} <b>must</b> be one of the bits present in the {@code supportedCompositeAlpha} member of the ##VkSurfaceCapabilitiesKHR structure returned by {@code vkGetPhysicalDeviceSurfaceCapabilitiesKHR} for the surface</li>
            <li>{@code presentMode} <b>must</b> be one of the {@code VkPresentModeKHR} values returned by {@code vkGetPhysicalDeviceSurfacePresentModesKHR} for the surface</li>
            <li>If the logical device was created with ##VkDeviceGroupDeviceCreateInfo{@code ::physicalDeviceCount} equal to 1, {@code flags} <b>must</b> not contain #SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR</li>
            <li>If {@code oldSwapchain} is not #NULL_HANDLE, {@code oldSwapchain} <b>must</b> be a non-retired swapchain associated with native window referred to by {@code surface}</li>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#swapchain-wsi-image-create-info">implied image creation parameters</a> of the swapchain <b>must</b> be supported as reported by #GetPhysicalDeviceImageFormatProperties()</li>
            <li>If {@code flags} contains #SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR then the {@code pNext} chain <b>must</b> include a ##VkImageFormatListCreateInfo structure with a {@code viewFormatCount} greater than zero and {@code pViewFormats} <b>must</b> have an element equal to {@code imageFormat}</li>
            <li>If a ##VkImageFormatListCreateInfo structure was included in the {@code pNext} chain and ##VkImageFormatListCreateInfo{@code ::viewFormatCount} is not zero then all of the formats in ##VkImageFormatListCreateInfo{@code ::pViewFormats} <b>must</b> be compatible with the {@code format} as described in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility">compatibility table</a></li>
            <li>If {@code flags} does not contain #SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR and the {@code pNext} chain include a ##VkImageFormatListCreateInfo structure then ##VkImageFormatListCreateInfo{@code ::viewFormatCount} <b>must</b> be 0 or 1</li>
            <li>If {@code flags} contains #SWAPCHAIN_CREATE_PROTECTED_BIT_KHR, then ##VkSurfaceProtectedCapabilitiesKHR{@code ::supportsProtected} <b>must</b> be #TRUE in the ##VkSurfaceProtectedCapabilitiesKHR structure returned by #GetPhysicalDeviceSurfaceCapabilities2KHR() for {@code surface}</li>
            <li>If the {@code pNext} chain includes a ##VkSurfaceFullScreenExclusiveInfoEXT structure with its {@code fullScreenExclusive} member set to #FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and {@code surface} was created using #CreateWin32SurfaceKHR(), a ##VkSurfaceFullScreenExclusiveWin32InfoEXT structure <b>must</b> be included in the {@code pNext} chain</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-imageCompressionControlSwapchain">{@code imageCompressionControlSwapchain}</a> feature is not enabled, the {@code pNext} chain <b>must</b> not include an ##VkImageCompressionControlEXT structure</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkDeviceGroupSwapchainCreateInfoKHR, ##VkImageCompressionControlEXT, ##VkImageFormatListCreateInfo, ##VkSurfaceFullScreenExclusiveInfoEXT, ##VkSurfaceFullScreenExclusiveWin32InfoEXT, ##VkSwapchainCounterCreateInfoEXT, ##VkSwapchainDisplayNativeHdrCreateInfoAMD, ##VkSwapchainPresentBarrierCreateInfoNV, ##VkSwapchainPresentModesCreateInfoEXT, or ##VkSwapchainPresentScalingCreateInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkSwapchainCreateFlagBitsKHR} values</li>
            <li>{@code surface} <b>must</b> be a valid {@code VkSurfaceKHR} handle</li>
            <li>{@code imageFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code imageColorSpace} <b>must</b> be a valid {@code VkColorSpaceKHR} value</li>
            <li>{@code imageUsage} <b>must</b> be a valid combination of {@code VkImageUsageFlagBits} values</li>
            <li>{@code imageUsage} <b>must</b> not be 0</li>
            <li>{@code imageSharingMode} <b>must</b> be a valid {@code VkSharingMode} value</li>
            <li>{@code preTransform} <b>must</b> be a valid {@code VkSurfaceTransformFlagBitsKHR} value</li>
            <li>{@code compositeAlpha} <b>must</b> be a valid {@code VkCompositeAlphaFlagBitsKHR} value</li>
            <li>{@code presentMode} <b>must</b> be a valid {@code VkPresentModeKHR} value</li>
            <li>If {@code oldSwapchain} is not #NULL_HANDLE, {@code oldSwapchain} <b>must</b> be a valid {@code VkSwapchainKHR} handle</li>
            <li>Both of {@code oldSwapchain}, and {@code surface} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkInstance}</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, #CreateSharedSwapchainsKHR(), #CreateSwapchainKHR()
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkDeviceGroupSwapchainCreateInfoKHR", "VkImageCompressionControlEXT", "VkImageFormatListCreateInfo", "VkImageFormatListCreateInfoKHR", "VkSurfaceFullScreenExclusiveInfoEXT", "VkSurfaceFullScreenExclusiveWin32InfoEXT", "VkSwapchainCounterCreateInfoEXT", "VkSwapchainDisplayNativeHdrCreateInfoAMD", "VkSwapchainPresentBarrierCreateInfoNV", "VkSwapchainPresentModesCreateInfoEXT", "VkSwapchainPresentScalingCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSwapchainCreateFlagsKHR("flags", "a bitmask of {@code VkSwapchainCreateFlagBitsKHR} indicating parameters of the swapchain creation.")
    VkSurfaceKHR("surface", "the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with {@code surface}.")
    uint32_t("minImageCount", "the minimum number of presentable images that the application needs. The implementation will either create the swapchain with at least that many images, or it will fail to create the swapchain.")
    VkFormat("imageFormat", "a {@code VkFormat} value specifying the format the swapchain image(s) will be created with.")
    VkColorSpaceKHR("imageColorSpace", "a {@code VkColorSpaceKHR} value specifying the way the swapchain interprets image data.")
    VkExtent2D("imageExtent", """the size (in pixels) of the swapchain image(s). The behavior is platform-dependent if the image extent does not match the surface’s {@code currentExtent} as returned by {@code vkGetPhysicalDeviceSurfaceCapabilitiesKHR}.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        On some platforms, it is normal that {@code maxImageExtent} <b>may</b> become {@code (0, 0)}, for example when the window is minimized. In such a case, it is not possible to create a swapchain due to the Valid Usage requirements , unless scaling is selected through ##VkSwapchainPresentScalingCreateInfoEXT, if supported .
        </div>""")
    uint32_t("imageArrayLayers", "the number of views in a multiview/stereo surface. For non-stereoscopic-3D applications, this value is 1.")
    VkImageUsageFlags("imageUsage", "a bitmask of {@code VkImageUsageFlagBits} describing the intended usage of the (acquired) swapchain images.")
    VkSharingMode("imageSharingMode", "the sharing mode used for the image(s) of the swapchain.")
    AutoSize("pQueueFamilyIndices", optional = true)..uint32_t("queueFamilyIndexCount", "the number of queue families having access to the image(s) of the swapchain when {@code imageSharingMode} is #SHARING_MODE_CONCURRENT.")
    nullable..uint32_t.const.p("pQueueFamilyIndices", "a pointer to an array of queue family indices having access to the images(s) of the swapchain when {@code imageSharingMode} is #SHARING_MODE_CONCURRENT.")
    VkSurfaceTransformFlagBitsKHR("preTransform", "a {@code VkSurfaceTransformFlagBitsKHR} value describing the transform, relative to the presentation engine’s natural orientation, applied to the image content prior to presentation. If it does not match the {@code currentTransform} value returned by {@code vkGetPhysicalDeviceSurfaceCapabilitiesKHR}, the presentation engine will transform the image content as part of the presentation operation.")
    VkCompositeAlphaFlagBitsKHR("compositeAlpha", "a {@code VkCompositeAlphaFlagBitsKHR} value indicating the alpha compositing mode to use when this surface is composited together with other surfaces on certain window systems.")
    VkPresentModeKHR("presentMode", "the presentation mode the swapchain will use. A swapchain’s present mode determines how incoming present requests will be processed and queued internally.")
    VkBool32("clipped", """specifies whether the Vulkan implementation is allowed to discard rendering operations that affect regions of the surface that are not visible.

        <ul>
            <li>If set to #TRUE, the presentable images associated with the swapchain <b>may</b> not own all of their pixels. Pixels in the presentable images that correspond to regions of the target surface obscured by another window on the desktop, or subject to some other clipping mechanism will have undefined content when read back. Fragment shaders <b>may</b> not execute for these pixels, and thus any side effects they would have had will not occur. Setting #TRUE does not guarantee any clipping will occur, but allows more efficient presentation methods to be used on some platforms.</li>
            <li>
                If set to #FALSE, presentable images associated with the swapchain will own all of the pixels they contain.
                <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Applications <b>should</b> set this value to #TRUE if they do not expect to read back the content of presentable images before presenting them or after reacquiring them, and if their fragment shaders do not have any side effects that require them to run for all pixels in the presentable image.
                </div>
            </li>
        </ul>""")
    VkSwapchainKHR("oldSwapchain", """#NULL_HANDLE, or the existing non-retired swapchain currently associated with {@code surface}. Providing a valid {@code oldSwapchain} <b>may</b> aid in the resource reuse, and also allows the application to still present any images that are already acquired from it.

        Upon calling {@code vkCreateSwapchainKHR} with an {@code oldSwapchain} that is not #NULL_HANDLE, {@code oldSwapchain} is retired — even if creation of the new swapchain fails. The new swapchain is created in the non-retired state whether or not {@code oldSwapchain} is #NULL_HANDLE.

        Upon calling {@code vkCreateSwapchainKHR} with an {@code oldSwapchain} that is not #NULL_HANDLE, any images from {@code oldSwapchain} that are not acquired by the application <b>may</b> be freed by the implementation, which <b>may</b> occur even if creation of the new swapchain fails. The application <b>can</b> destroy {@code oldSwapchain} to free all memory associated with {@code oldSwapchain}.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Multiple retired swapchains <b>can</b> be associated with the same {@code VkSurfaceKHR} through multiple uses of {@code oldSwapchain} that outnumber calls to #DestroySwapchainKHR().

        After {@code oldSwapchain} is retired, the application <b>can</b> pass to #QueuePresentKHR() any images it had already acquired from {@code oldSwapchain}. E.g., an application may present an image from the old swapchain before an image from the new swapchain is ready to be presented. As usual, #QueuePresentKHR() <b>may</b> fail if {@code oldSwapchain} has entered a state that causes #ERROR_OUT_OF_DATE_KHR to be returned.

        The application <b>can</b> continue to use a shared presentable image obtained from {@code oldSwapchain} until a presentable image is acquired from the new swapchain, as long as it has not entered a state that causes it to return #ERROR_OUT_OF_DATE_KHR.
        </div>""")
}

val VkPresentInfoKHR = struct(Module.VULKAN, "VkPresentInfoKHR") {
    documentation =
        """
        Structure describing parameters of a queue presentation.

        <h5>Description</h5>
        Before an application <b>can</b> present an image, the image’s layout <b>must</b> be transitioned to the #IMAGE_LAYOUT_PRESENT_SRC_KHR layout, or for a shared presentable image the #IMAGE_LAYOUT_SHARED_PRESENT_KHR layout.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        When transitioning the image to #IMAGE_LAYOUT_SHARED_PRESENT_KHR or #IMAGE_LAYOUT_PRESENT_SRC_KHR, there is no need to delay subsequent processing, or perform any visibility operations (as #QueuePresentKHR() performs automatic visibility operations). To achieve this, the {@code dstAccessMask} member of the ##VkImageMemoryBarrier <b>should</b> be set to 0, and the {@code dstStageMask} parameter <b>should</b> be set to #PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>Elements of {@code pSwapchain} <b>must</b> be unique</li>
            <li>Each element of {@code pImageIndices} <b>must</b> be the index of a presentable image acquired from the swapchain specified by the corresponding element of the {@code pSwapchains} array, and the presented image subresource <b>must</b> be in the #IMAGE_LAYOUT_PRESENT_SRC_KHR or #IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a {@code VkDevice}</li>
            <li>If a ##VkPresentIdKHR structure is included in the {@code pNext} chain, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-presentId">{@code presentId}</a> feature is not enabled, each {@code presentIds} entry in that structure <b>must</b> be NULL</li>
            <li>If any element of the {@code pSwapchains} array has been created with ##VkSwapchainPresentModesCreateInfoEXT, all of the elements of this array <b>must</b> be created with ##VkSwapchainPresentModesCreateInfoEXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PRESENT_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkDeviceGroupPresentInfoKHR, ##VkDisplayPresentInfoKHR, ##VkFrameBoundaryEXT, ##VkPresentIdKHR, ##VkPresentRegionsKHR, ##VkPresentTimesInfoGOOGLE, ##VkSwapchainPresentFenceInfoEXT, or ##VkSwapchainPresentModeInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>If {@code waitSemaphoreCount} is not 0, {@code pWaitSemaphores} <b>must</b> be a valid pointer to an array of {@code waitSemaphoreCount} valid {@code VkSemaphore} handles</li>
            <li>{@code pSwapchains} <b>must</b> be a valid pointer to an array of {@code swapchainCount} valid {@code VkSwapchainKHR} handles</li>
            <li>{@code pImageIndices} <b>must</b> be a valid pointer to an array of {@code swapchainCount} {@code uint32_t} values</li>
            <li>If {@code pResults} is not {@code NULL}, {@code pResults} <b>must</b> be a valid pointer to an array of {@code swapchainCount} {@code VkResult} values</li>
            <li>{@code swapchainCount} <b>must</b> be greater than 0</li>
            <li>Both of the elements of {@code pSwapchains}, and the elements of {@code pWaitSemaphores} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #QueuePresentKHR()
        """

    Expression("#STRUCTURE_TYPE_PRESENT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkDeviceGroupPresentInfoKHR", "VkDisplayPresentInfoKHR", "VkFrameBoundaryEXT", "VkPresentIdKHR", "VkPresentRegionsKHR", "VkPresentTimesInfoGOOGLE", "VkSwapchainPresentFenceInfoEXT", "VkSwapchainPresentModeInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pWaitSemaphores", optional = true)..uint32_t("waitSemaphoreCount", "the number of semaphores to wait for before issuing the present request. The number <b>may</b> be zero.")
    VkSemaphore.const.p("pWaitSemaphores", "{@code NULL} or a pointer to an array of {@code VkSemaphore} objects with {@code waitSemaphoreCount} entries, and specifies the semaphores to wait for before issuing the present request.")
    AutoSize("pSwapchains", "pImageIndices", "pResults")..uint32_t("swapchainCount", "the number of swapchains being presented to by this command.")
    VkSwapchainKHR.const.p("pSwapchains", "a pointer to an array of {@code VkSwapchainKHR} objects with {@code swapchainCount} entries.")
    uint32_t.const.p("pImageIndices", "a pointer to an array of indices into the array of each swapchain’s presentable images, with {@code swapchainCount} entries. Each entry in this array identifies the image to present on the corresponding entry in the {@code pSwapchains} array.")
    nullable..VkResult.p("pResults", "a pointer to an array of {@code VkResult} typed elements with {@code swapchainCount} entries. Applications that do not need per-swapchain results <b>can</b> use {@code NULL} for {@code pResults}. If non-{@code NULL}, each entry in {@code pResults} will be set to the {@code VkResult} for presenting the swapchain corresponding to the same index in {@code pSwapchains}.")
}

val VkImageSwapchainCreateInfoKHR = struct(Module.VULKAN, "VkImageSwapchainCreateInfoKHR") {
    documentation =
        """
        Specify that an image will be bound to swapchain memory.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code swapchain} is not #NULL_HANDLE, the fields of ##VkImageCreateInfo <b>must</b> match the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#swapchain-wsi-image-create-info">implied image creation parameters</a> of the swapchain</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR</li>
            <li>If {@code swapchain} is not #NULL_HANDLE, {@code swapchain} <b>must</b> be a valid {@code VkSwapchainKHR} handle</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSwapchainKHR("swapchain", "#NULL_HANDLE or a handle of a swapchain that the image will be bound to.")
}

val VkBindImageMemorySwapchainInfoKHR = struct(Module.VULKAN, "VkBindImageMemorySwapchainInfoKHR") {
    documentation =
        """
        Structure specifying swapchain image memory to bind to.

        <h5>Description</h5>
        If {@code swapchain} is not {@code NULL}, the {@code swapchain} and {@code imageIndex} are used to determine the memory that the image is bound to, instead of {@code memory} and {@code memoryOffset}.

        Memory <b>can</b> be bound to a swapchain and use the {@code pDeviceIndices} or {@code pSplitInstanceBindRegions} members of ##VkBindImageMemoryDeviceGroupInfo.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code imageIndex} <b>must</b> be less than the number of images in {@code swapchain}</li>
            <li>If the {@code swapchain} has been created with #SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT, {@code imageIndex} <b>must</b> be one that has previously been returned by #AcquireNextImageKHR() or #AcquireNextImage2KHR()</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR</li>
            <li>{@code swapchain} <b>must</b> be a valid {@code VkSwapchainKHR} handle</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code swapchain} <b>must</b> be externally synchronized</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSwapchainKHR("swapchain", "#NULL_HANDLE or a swapchain handle.")
    uint32_t("imageIndex", "an image index within {@code swapchain}.")
}

val VkAcquireNextImageInfoKHR = struct(Module.VULKAN, "VkAcquireNextImageInfoKHR") {
    documentation =
        """
        Structure specifying parameters of the acquire.

        <h5>Description</h5>
        If #AcquireNextImageKHR() is used, the device mask is considered to include all physical devices in the logical device.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        #AcquireNextImage2KHR() signals at most one semaphore, even if the application requests waiting for multiple physical devices to be ready via the {@code deviceMask}. However, only a single physical device <b>can</b> wait on that semaphore, since the semaphore becomes unsignaled when the wait succeeds. For other physical devices to wait for the image to be ready, it is necessary for the application to submit semaphore signal operation(s) to that first physical device to signal additional semaphore(s) after the wait succeeds, which the other physical device(s) <b>can</b> wait upon.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code swapchain} <b>must</b> not be in the retired state</li>
            <li>If {@code semaphore} is not #NULL_HANDLE it <b>must</b> be unsignaled</li>
            <li>If {@code semaphore} is not #NULL_HANDLE it <b>must</b> not have any uncompleted signal or wait operations pending</li>
            <li>If {@code fence} is not #NULL_HANDLE it <b>must</b> be unsignaled and <b>must</b> not be associated with any other queue command that has not yet completed execution on that queue</li>
            <li>{@code semaphore} and {@code fence} <b>must</b> not both be equal to #NULL_HANDLE</li>
            <li>{@code deviceMask} <b>must</b> be a valid device mask</li>
            <li>{@code deviceMask} <b>must</b> not be zero</li>
            <li>{@code semaphore} <b>must</b> have a {@code VkSemaphoreType} of #SEMAPHORE_TYPE_BINARY</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code swapchain} <b>must</b> be a valid {@code VkSwapchainKHR} handle</li>
            <li>If {@code semaphore} is not #NULL_HANDLE, {@code semaphore} <b>must</b> be a valid {@code VkSemaphore} handle</li>
            <li>If {@code fence} is not #NULL_HANDLE, {@code fence} <b>must</b> be a valid {@code VkFence} handle</li>
            <li>Each of {@code fence}, {@code semaphore}, and {@code swapchain} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code swapchain} <b>must</b> be externally synchronized</li>
            <li>Host access to {@code semaphore} <b>must</b> be externally synchronized</li>
            <li>Host access to {@code fence} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #AcquireNextImage2KHR()
        """

    Expression("#STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSwapchainKHR("swapchain", "a non-retired swapchain from which an image is acquired.")
    uint64_t("timeout", "specifies how long the function waits, in nanoseconds, if no image is available.")
    VkSemaphore("semaphore", "#NULL_HANDLE or a semaphore to signal.")
    VkFence("fence", "#NULL_HANDLE or a fence to signal.")
    uint32_t("deviceMask", "a mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.")
}

val VkDeviceGroupPresentCapabilitiesKHR = struct(Module.VULKAN, "VkDeviceGroupPresentCapabilitiesKHR", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Present capabilities from other physical devices.

        <h5>Description</h5>
        {@code modes} always has #DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR set.

        The present mode flags are also used when presenting an image, in ##VkDeviceGroupPresentInfoKHR{@code ::mode}.

        If a device group only includes a single physical device, then {@code modes} <b>must</b> equal #DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetDeviceGroupPresentCapabilitiesKHR()
        """

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("presentMask", "an array of #MAX_DEVICE_GROUP_SIZE {@code uint32_t} masks, where the mask at element <code>i</code> is non-zero if physical device <code>i</code> has a presentation engine, and where bit <code>j</code> is set in element <code>i</code> if physical device <code>i</code> <b>can</b> present swapchain images from physical device <code>j</code>. If element <code>i</code> is non-zero, then bit <code>i</code> <b>must</b> be set.")["VK_MAX_DEVICE_GROUP_SIZE"]
    VkDeviceGroupPresentModeFlagsKHR("modes", "a bitmask of {@code VkDeviceGroupPresentModeFlagBitsKHR} indicating which device group presentation modes are supported.")
}

val VkDeviceGroupPresentInfoKHR = struct(Module.VULKAN, "VkDeviceGroupPresentInfoKHR") {
    documentation =
        """
        Mode and mask controlling which physical devices' images are presented.

        <h5>Description</h5>
        If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each element of {@code pDeviceMasks} selects which instance of the swapchain image is presented. Each element of {@code pDeviceMasks} <b>must</b> have exactly one bit set, and the corresponding physical device <b>must</b> have a presentation engine as reported by ##VkDeviceGroupPresentCapabilitiesKHR.

        If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then each element of {@code pDeviceMasks} selects which instance of the swapchain image is presented. Each element of {@code pDeviceMasks} <b>must</b> have exactly one bit set, and some physical device in the logical device <b>must</b> include that bit in its ##VkDeviceGroupPresentCapabilitiesKHR{@code ::presentMask}.

        If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each element of {@code pDeviceMasks} selects which instances of the swapchain image are component-wise summed and the sum of those images is presented. If the sum in any component is outside the representable range, the value of that component is undefined. Each element of {@code pDeviceMasks} <b>must</b> have a value for which all set bits are set in one of the elements of ##VkDeviceGroupPresentCapabilitiesKHR{@code ::presentMask}.

        If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then each element of {@code pDeviceMasks} selects which instance(s) of the swapchain images are presented. For each bit set in each element of {@code pDeviceMasks}, the corresponding physical device <b>must</b> have a presentation engine as reported by ##VkDeviceGroupPresentCapabilitiesKHR.

        If ##VkDeviceGroupPresentInfoKHR is not provided or {@code swapchainCount} is zero then the masks are considered to be 1. If ##VkDeviceGroupPresentInfoKHR is not provided, {@code mode} is considered to be #DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code swapchainCount} <b>must</b> equal 0 or ##VkPresentInfoKHR{@code ::swapchainCount}</li>
            <li>If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each element of {@code pDeviceMasks} <b>must</b> have exactly one bit set, and the corresponding element of ##VkDeviceGroupPresentCapabilitiesKHR{@code ::presentMask} <b>must</b> be non-zero</li>
            <li>If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then each element of {@code pDeviceMasks} <b>must</b> have exactly one bit set, and some physical device in the logical device <b>must</b> include that bit in its ##VkDeviceGroupPresentCapabilitiesKHR{@code ::presentMask}</li>
            <li>If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each element of {@code pDeviceMasks} <b>must</b> have a value for which all set bits are set in one of the elements of ##VkDeviceGroupPresentCapabilitiesKHR{@code ::presentMask}</li>
            <li>If {@code mode} is #DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then for each bit set in each element of {@code pDeviceMasks}, the corresponding element of ##VkDeviceGroupPresentCapabilitiesKHR{@code ::presentMask} <b>must</b> be non-zero</li>
            <li>The value of each element of {@code pDeviceMasks} <b>must</b> be equal to the device mask passed in ##VkAcquireNextImageInfoKHR{@code ::deviceMask} when the image index was last acquired</li>
            <li>{@code mode} <b>must</b> have exactly one bit set, and that bit <b>must</b> have been included in ##VkDeviceGroupSwapchainCreateInfoKHR{@code ::modes}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR</li>
            <li>If {@code swapchainCount} is not 0, {@code pDeviceMasks} <b>must</b> be a valid pointer to an array of {@code swapchainCount} {@code uint32_t} values</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkDeviceGroupPresentModeFlagBitsKHR} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pDeviceMasks", optional = true)..uint32_t("swapchainCount", "zero or the number of elements in {@code pDeviceMasks}.")
    uint32_t.const.p("pDeviceMasks", "a pointer to an array of device masks, one for each element of ##VkPresentInfoKHR{@code ::pSwapchains}.")
    VkDeviceGroupPresentModeFlagBitsKHR("mode", "a {@code VkDeviceGroupPresentModeFlagBitsKHR} value specifying the device group present mode that will be used for this present.")
}

val VkDeviceGroupSwapchainCreateInfoKHR = struct(Module.VULKAN, "VkDeviceGroupSwapchainCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created swapchain object.

        <h5>Description</h5>
        If this structure is not present, {@code modes} is considered to be #DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR</li>
            <li>{@code modes} <b>must</b> be a valid combination of {@code VkDeviceGroupPresentModeFlagBitsKHR} values</li>
            <li>{@code modes} <b>must</b> not be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceGroupPresentModeFlagsKHR("modes", "a bitfield of modes that the swapchain <b>can</b> be used with.")
}

val VkDisplayModeParametersKHR = struct(Module.VULKAN, "VkDisplayModeParametersKHR") {
    documentation =
        """
        Structure describing display parameters associated with a display mode.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        For example, a 60Hz display mode would report a {@code refreshRate} of 60,000.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code width} member of {@code visibleRegion} <b>must</b> be greater than 0</li>
            <li>The {@code height} member of {@code visibleRegion} <b>must</b> be greater than 0</li>
            <li>{@code refreshRate} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkDisplayModeCreateInfoKHR, ##VkDisplayModePropertiesKHR, ##VkExtent2D
        """

    VkExtent2D("visibleRegion", "the 2D extents of the visible region.")
    uint32_t("refreshRate", "a {@code uint32_t} that is the number of times the display is refreshed each second multiplied by 1000.")
}

val VkDisplayModeCreateInfoKHR = struct(Module.VULKAN, "VkDisplayModeCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created display mode object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code parameters} <b>must</b> be a valid ##VkDisplayModeParametersKHR structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkDisplayModeParametersKHR, #CreateDisplayModeKHR()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDisplayModeCreateFlagsKHR("flags", "reserved for future use, and <b>must</b> be zero.")
    VkDisplayModeParametersKHR("parameters", "a ##VkDisplayModeParametersKHR structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation <b>must</b> return #ERROR_INITIALIZATION_FAILED.")
}

val VkDisplayModePropertiesKHR = struct(Module.VULKAN, "VkDisplayModePropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing display mode properties.

        <h5>See Also</h5>
        ##VkDisplayModeParametersKHR, ##VkDisplayModeProperties2KHR, #GetDisplayModePropertiesKHR()
        """

    VkDisplayModeKHR("displayMode", "a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.")
    VkDisplayModeParametersKHR("parameters", "a ##VkDisplayModeParametersKHR structure describing the display parameters associated with {@code displayMode}.")
}

val VkDisplayPlaneCapabilitiesKHR = struct(Module.VULKAN, "VkDisplayPlaneCapabilitiesKHR", mutable = false) {
    documentation =
        """
        Structure describing capabilities of a mode and plane combination.

        <h5>Description</h5>
        The minimum and maximum position and extent fields describe the implementation limits, if any, as they apply to the specified display mode and plane. Vendors <b>may</b> support displaying a subset of a swapchain’s presentable images on the specified display plane. This is expressed by returning {@code minSrcPosition}, {@code maxSrcPosition}, {@code minSrcExtent}, and {@code maxSrcExtent} values that indicate a range of possible positions and sizes which <b>may</b> be used to specify the region within the presentable images that source pixels will be read from when creating a swapchain on the specified display mode and plane.

        Vendors <b>may</b> also support mapping the presentable images’ content to a subset or superset of the visible region in the specified display mode. This is expressed by returning {@code minDstPosition}, {@code maxDstPosition}, {@code minDstExtent} and {@code maxDstExtent} values that indicate a range of possible positions and sizes which <b>may</b> be used to describe the region within the display mode that the source pixels will be mapped to.

        Other vendors <b>may</b> support only a 1-1 mapping between pixels in the presentable images and the display mode. This <b>may</b> be indicated by returning <code>(0,0)</code> for {@code minSrcPosition}, {@code maxSrcPosition}, {@code minDstPosition}, and {@code maxDstPosition}, and (display mode width, display mode height) for {@code minSrcExtent}, {@code maxSrcExtent}, {@code minDstExtent}, and {@code maxDstExtent}.

        The value {@code supportedAlpha} <b>must</b> contain at least one valid {@code VkDisplayPlaneAlphaFlagBitsKHR} bit.

        These values indicate the limits of the implementation’s individual fields. Not all combinations of values within the offset and extent ranges returned in ##VkDisplayPlaneCapabilitiesKHR are guaranteed to be supported. Presentation requests specifying unsupported combinations <b>may</b> fail.

        <h5>See Also</h5>
        ##VkDisplayPlaneCapabilities2KHR, ##VkExtent2D, ##VkOffset2D, #GetDisplayPlaneCapabilitiesKHR()
        """

    VkDisplayPlaneAlphaFlagsKHR("supportedAlpha", "a bitmask of {@code VkDisplayPlaneAlphaFlagBitsKHR} describing the supported alpha blending modes.")
    VkOffset2D("minSrcPosition", "the minimum source rectangle offset supported by this plane using the specified mode.")
    VkOffset2D("maxSrcPosition", "the maximum source rectangle offset supported by this plane using the specified mode. The {@code x} and {@code y} components of {@code maxSrcPosition} <b>must</b> each be greater than or equal to the {@code x} and {@code y} components of {@code minSrcPosition}, respectively.")
    VkExtent2D("minSrcExtent", "the minimum source rectangle size supported by this plane using the specified mode.")
    VkExtent2D("maxSrcExtent", "the maximum source rectangle size supported by this plane using the specified mode.")
    VkOffset2D("minDstPosition", "{@code minDstPosition}, {@code maxDstPosition}, {@code minDstExtent}, {@code maxDstExtent} all have similar semantics to their corresponding {@code *Src*} equivalents, but apply to the output region within the mode rather than the input region within the source image. Unlike the {@code *Src*} offsets, {@code minDstPosition} and {@code maxDstPosition} <b>may</b> contain negative values.")
    VkOffset2D("maxDstPosition", "see {@code minDstPosition}")
    VkExtent2D("minDstExtent", "see {@code minDstPosition}")
    VkExtent2D("maxDstExtent", "see {@code minDstPosition}")
}

val VkDisplayPlanePropertiesKHR = struct(Module.VULKAN, "VkDisplayPlanePropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing display plane properties.

        <h5>See Also</h5>
        ##VkDisplayPlaneProperties2KHR, #GetPhysicalDeviceDisplayPlanePropertiesKHR()
        """

    VkDisplayKHR("currentDisplay", "the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be #NULL_HANDLE.")
    uint32_t("currentStackIndex", "the current z-order of the plane. This will be between 0 and the value returned by {@code vkGetPhysicalDeviceDisplayPlanePropertiesKHR} in {@code pPropertyCount}.")
}

val VkDisplayPropertiesKHR = struct(Module.VULKAN, "VkDisplayPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing an available display device.

        <h5>See Also</h5>
        ##VkDisplayProperties2KHR, ##VkExtent2D, #GetPhysicalDeviceDisplayPropertiesKHR()
        """

    VkDisplayKHR("display", "a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.")
    charUTF8.const.p("displayName", "{@code NULL} or a pointer to a null-terminated UTF-8 string containing the name of the display. Generally, this will be the name provided by the display’s EDID. If {@code NULL}, no suitable name is available. If not {@code NULL}, the string pointed to <b>must</b> remain accessible and unmodified as long as {@code display} is valid.")
    VkExtent2D("physicalDimensions", "describes the physical width and height of the visible portion of the display, in millimeters.")
    VkExtent2D("physicalResolution", """describes the physical, native, or preferred resolution of the display.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        For devices which have no natural value to return here, implementations <b>should</b> return the maximum resolution supported.
        </div>""")
    VkSurfaceTransformFlagsKHR("supportedTransforms", "a bitmask of {@code VkSurfaceTransformFlagBitsKHR} describing which transforms are supported by this display.")
    VkBool32("planeReorderPossible", "tells whether the planes on this display <b>can</b> have their z order changed. If this is #TRUE, the application <b>can</b> re-arrange the planes on this display in any order relative to each other.")
    VkBool32("persistentContent", """tells whether the display supports self-refresh/internal buffering. If this is true, the application <b>can</b> submit persistent present operations on swapchains created against this display.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Persistent presents <b>may</b> have higher latency, and <b>may</b> use less power when the screen content is updated infrequently, or when only a portion of the screen needs to be updated in most frames.
        </div>""")
}

val VkDisplaySurfaceCreateInfoKHR = struct(Module.VULKAN, "VkDisplaySurfaceCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created display plane surface object.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Creating a display surface <b>must</b> not modify the state of the displays, planes, or other resources it names. For example, it <b>must</b> not apply the specified mode to be set on the associated display. Application of display configuration occurs as a side effect of presenting to a display surface.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code planeIndex} <b>must</b> be less than the number of display planes supported by the device as determined by calling {@code vkGetPhysicalDeviceDisplayPlanePropertiesKHR}</li>
            <li>If the {@code planeReorderPossible} member of the ##VkDisplayPropertiesKHR structure returned by {@code vkGetPhysicalDeviceDisplayPropertiesKHR} for the display corresponding to {@code displayMode} is #TRUE then {@code planeStackIndex} <b>must</b> be less than the number of display planes supported by the device as determined by calling {@code vkGetPhysicalDeviceDisplayPlanePropertiesKHR}; otherwise {@code planeStackIndex} <b>must</b> equal the {@code currentStackIndex} member of ##VkDisplayPlanePropertiesKHR returned by {@code vkGetPhysicalDeviceDisplayPlanePropertiesKHR} for the display plane corresponding to {@code displayMode}</li>
            <li>If {@code alphaMode} is #DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then {@code globalAlpha} <b>must</b> be between 0 and 1, inclusive</li>
            <li>{@code alphaMode} <b>must</b> be one of the bits present in the {@code supportedAlpha} member of ##VkDisplayPlaneCapabilitiesKHR for the display plane corresponding to {@code displayMode}</li>
            <li>{@code transform} <b>must</b> be one of the bits present in the {@code supportedTransforms} member of ##VkDisplayPropertiesKHR for the display corresponding to {@code displayMode}</li>
            <li>The {@code width} and {@code height} members of {@code imageExtent} <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxImageDimension2D}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code displayMode} <b>must</b> be a valid {@code VkDisplayModeKHR} handle</li>
            <li>{@code transform} <b>must</b> be a valid {@code VkSurfaceTransformFlagBitsKHR} value</li>
            <li>{@code alphaMode} <b>must</b> be a valid {@code VkDisplayPlaneAlphaFlagBitsKHR} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, #CreateDisplayPlaneSurfaceKHR()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDisplaySurfaceCreateFlagsKHR("flags", "reserved for future use, and <b>must</b> be zero.")
    VkDisplayModeKHR("displayMode", "a {@code VkDisplayModeKHR} handle specifying the mode to use when displaying this surface.")
    uint32_t("planeIndex", "the plane on which this surface appears.")
    uint32_t("planeStackIndex", "the z-order of the plane.")
    VkSurfaceTransformFlagBitsKHR("transform", "a {@code VkSurfaceTransformFlagBitsKHR} value specifying the transformation to apply to images as part of the scanout operation.")
    float("globalAlpha", "the global alpha value. This value is ignored if {@code alphaMode} is not #DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.")
    VkDisplayPlaneAlphaFlagBitsKHR("alphaMode", "a {@code VkDisplayPlaneAlphaFlagBitsKHR} value specifying the type of alpha blending to use.")
    VkExtent2D("imageExtent", "the size of the presentable images to use with the surface.")
}

val VkDisplayPresentInfoKHR = struct(Module.VULKAN, "VkDisplayPresentInfoKHR") {
    documentation =
        """
        Structure describing parameters of a queue presentation to a swapchain.

        <h5>Description</h5>
        If the extent of the {@code srcRect} and {@code dstRect} are not equal, the presented pixels will be scaled accordingly.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code srcRect} <b>must</b> specify a rectangular region that is a subset of the image being presented</li>
            <li>{@code dstRect} <b>must</b> specify a rectangular region that is a subset of the {@code visibleRegion} parameter of the display mode the swapchain being presented uses</li>
            <li>If the {@code persistentContent} member of the ##VkDisplayPropertiesKHR structure returned by {@code vkGetPhysicalDeviceDisplayPropertiesKHR} for the display the present operation targets is #FALSE, then {@code persistent} <b>must</b> be #FALSE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR</li>
        </ul>

        <h5>See Also</h5>
        ##VkRect2D
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkRect2D("srcRect", "a rectangular region of pixels to present. It <b>must</b> be a subset of the image being presented. If ##VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire presentable image.")
    VkRect2D("dstRect", "a rectangular region within the visible region of the swapchain’s display mode. If ##VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire visible region of the swapchain’s mode. If the specified rectangle is a subset of the display mode’s visible region, content from display planes below the swapchain’s plane will be visible outside the rectangle. If there are no planes below the swapchain’s, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display’s visible region, pixels mapping only to those portions of the rectangle will be discarded.")
    VkBool32("persistent", "If this is #TRUE, the display engine will enable buffered mode on displays that support it. This allows the display engine to stop sending content to the display until a new image is presented. The display will instead maintain a copy of the last presented image. This allows less power to be used, but <b>may</b> increase presentation latency. If ##VkDisplayPresentInfoKHR is not specified, persistent mode will not be used.")
}

val VkXlibSurfaceCreateInfoKHR = struct(Module.VULKAN, "VkXlibSurfaceCreateInfoKHR") {
    javaImport("org.lwjgl.system.linux.*")
    documentation =
        """
        Structure specifying parameters of a newly created Xlib surface object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code dpy} <b>must</b> point to a valid Xlib {@code Display}</li>
            <li>{@code window} <b>must</b> be a valid Xlib {@code Window}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateXlibSurfaceKHR()
        """

    Expression("#STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkXlibSurfaceCreateFlagsKHR("flags", "reserved for future use.")
    nullable..Display.p("dpy", "a pointer to an Xlib {@code Display} connection to the X server.")
    Window("window", "an Xlib {@code Window} to associate the surface with.")
}

val VkXcbSurfaceCreateInfoKHR = struct(Module.VULKAN, "VkXcbSurfaceCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created Xcb surface object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code connection} <b>must</b> point to a valid X11 {@code xcb_connection_t}</li>
            <li>{@code window} <b>must</b> be a valid X11 {@code xcb_window_t}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateXcbSurfaceKHR()
        """

    Expression("#STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkXcbSurfaceCreateFlagsKHR("flags", "reserved for future use.")
    nullable..xcb_connection_t.p("connection", "a pointer to an {@code xcb_connection_t} to the X server.")
    xcb_window_t("window", "the {@code xcb_window_t} for the X11 window to associate the surface with.")
}

val VkWaylandSurfaceCreateInfoKHR = struct(Module.VULKAN, "VkWaylandSurfaceCreateInfoKHR") {
    javaImport("org.lwjgl.system.linux.*")
    documentation =
        """
        Structure specifying parameters of a newly created Wayland surface object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code display} <b>must</b> point to a valid Wayland {@code wl_display}</li>
            <li>{@code surface} <b>must</b> point to a valid Wayland {@code wl_surface}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateWaylandSurfaceKHR()
        """

    Expression("#STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkWaylandSurfaceCreateFlagsKHR("flags", "reserved for future use.")
    nullable..wl_display.p("display", "{@code display} and {@code surface} are pointers to the Wayland {@code wl_display} and {@code wl_surface} to associate the surface with.")
    nullable..wl_surface.p("surface", "see {@code display}")
}

val VkAndroidSurfaceCreateInfoKHR = struct(Module.VULKAN, "VkAndroidSurfaceCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created Android surface object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code window} <b>must</b> point to a valid Android {@code ANativeWindow}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateAndroidSurfaceKHR()
        """

    Expression("#STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAndroidSurfaceCreateFlagsKHR("flags", "reserved for future use.")
    nullable..ANativeWindow.p("window", "a pointer to the {@code ANativeWindow} to associate the surface with.")
}

val VkWin32SurfaceCreateInfoKHR = struct(Module.VULKAN, "VkWin32SurfaceCreateInfoKHR") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Structure specifying parameters of a newly created Win32 surface object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code hinstance} <b>must</b> be a valid Win32 {@code HINSTANCE}</li>
            <li>{@code hwnd} <b>must</b> be a valid Win32 {@code HWND}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateWin32SurfaceKHR()
        """

    Expression("#STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkWin32SurfaceCreateFlagsKHR("flags", "reserved for future use.")
    HINSTANCE("hinstance", "the Win32 {@code HINSTANCE} for the window to associate the surface with.")
    HWND("hwnd", "the Win32 {@code HWND} for the window to associate the surface with.")
}

val VkDebugReportCallbackCreateInfoEXT = struct(Module.VULKAN, "VkDebugReportCallbackCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created debug report callback.

        <h5>Description</h5>
        For each {@code VkDebugReportCallbackEXT} that is created the ##VkDebugReportCallbackCreateInfoEXT{@code ::flags} determine when that ##VkDebugReportCallbackCreateInfoEXT{@code ::pfnCallback} is called. When an event happens, the implementation will do a bitwise AND of the event’s {@code VkDebugReportFlagBitsEXT} flags to each {@code VkDebugReportCallbackEXT} object’s flags. For each non-zero result the corresponding callback will be called. The callback will come directly from the component that detected the event, unless some other layer intercepts the calls for its own purposes (filter them in a different way, log to a system error log, etc.).

        An application <b>may</b> receive multiple callbacks if multiple {@code VkDebugReportCallbackEXT} objects were created. A callback will always be executed in the same thread as the originating Vulkan call.

        A callback may be called from multiple threads simultaneously (if the application is making Vulkan calls from multiple threads).

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkDebugReportFlagBitsEXT} values</li>
            <li>{@code pfnCallback} <b>must</b> be a valid ##VkDebugReportCallbackEXT value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDebugReportCallbackEXT, #CreateDebugReportCallbackEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDebugReportFlagsEXT("flags", "a bitmask of {@code VkDebugReportFlagBitsEXT} specifying which event(s) will cause this callback to be called.")
    PFN_vkDebugReportCallbackEXT("pfnCallback", "the application callback function to call.")
    nullable..opaque_p("pUserData", "user data to be passed to the callback.")
}

val VkPipelineRasterizationStateRasterizationOrderAMD = struct(Module.VULKAN, "VkPipelineRasterizationStateRasterizationOrderAMD") {
    documentation =
        """
        Structure defining rasterization order for a graphics pipeline.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD</li>
            <li>{@code rasterizationOrder} <b>must</b> be a valid {@code VkRasterizationOrderAMD} value</li>
        </ul>

        If the {@link AMDRasterizationOrder VK_AMD_rasterization_order} device extension is not enabled or the application does not request a particular rasterization order through specifying a ##VkPipelineRasterizationStateRasterizationOrderAMD structure then the rasterization order used by the graphics pipeline defaults to #RASTERIZATION_ORDER_STRICT_AMD.
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkRasterizationOrderAMD("rasterizationOrder", "a {@code VkRasterizationOrderAMD} value specifying the primitive rasterization order to use.")
}

val VkDebugMarkerObjectNameInfoEXT = struct(Module.VULKAN, "VkDebugMarkerObjectNameInfoEXT") {
    documentation =
        """
        Specify parameters of a name to give to an object.

        <h5>Description</h5>
        Applications <b>may</b> change the name associated with an object simply by calling {@code vkDebugMarkerSetObjectNameEXT} again with a new string. To remove a previously set name, {@code pObjectName} <b>should</b> be set to an empty string.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code objectType} <b>must</b> not be #DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT</li>
            <li>{@code object} <b>must</b> not be #NULL_HANDLE</li>
            <li>{@code object} <b>must</b> be a Vulkan object of the type associated with {@code objectType} as defined in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#debug-report-object-types">{@code VkDebugReportObjectTypeEXT} and Vulkan Handle Relationship</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code objectType} <b>must</b> be a valid {@code VkDebugReportObjectTypeEXT} value</li>
            <li>{@code pObjectName} <b>must</b> be a null-terminated UTF-8 string</li>
        </ul>

        <h5>See Also</h5>
        #DebugMarkerSetObjectNameEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDebugReportObjectTypeEXT("objectType", "a {@code VkDebugReportObjectTypeEXT} specifying the type of the object to be named.")
    uint64_t("object", "the object to be named.")
    charUTF8.const.p("pObjectName", "a null-terminated UTF-8 string specifying the name to apply to {@code object}.")
}

val VkDebugMarkerObjectTagInfoEXT = struct(Module.VULKAN, "VkDebugMarkerObjectTagInfoEXT") {
    documentation =
        """
        Specify parameters of a tag to attach to an object.

        <h5>Description</h5>
        The {@code tagName} parameter gives a name or identifier to the type of data being tagged. This can be used by debugging layers to easily filter for only data that can be used by that implementation.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code objectType} <b>must</b> not be #DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT</li>
            <li>{@code object} <b>must</b> not be #NULL_HANDLE</li>
            <li>{@code object} <b>must</b> be a Vulkan object of the type associated with {@code objectType} as defined in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#debug-report-object-types">{@code VkDebugReportObjectTypeEXT} and Vulkan Handle Relationship</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code objectType} <b>must</b> be a valid {@code VkDebugReportObjectTypeEXT} value</li>
            <li>{@code pTag} <b>must</b> be a valid pointer to an array of {@code tagSize} bytes</li>
            <li>{@code tagSize} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        #DebugMarkerSetObjectTagEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDebugReportObjectTypeEXT("objectType", "a {@code VkDebugReportObjectTypeEXT} specifying the type of the object to be named.")
    uint64_t("object", "the object to be tagged.")
    uint64_t("tagName", "a numerical identifier of the tag.")
    AutoSize("pTag")..size_t("tagSize", "the number of bytes of data to attach to the object.")
    void.const.p("pTag", "a pointer to an array of {@code tagSize} bytes containing the data to be associated with the object.")
}

val VkDebugMarkerMarkerInfoEXT = struct(Module.VULKAN, "VkDebugMarkerMarkerInfoEXT") {
    documentation =
        """
        Specify parameters of a command buffer marker region.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pMarkerName} <b>must</b> be a null-terminated UTF-8 string</li>
        </ul>

        <h5>See Also</h5>
        #CmdDebugMarkerBeginEXT(), #CmdDebugMarkerInsertEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    charUTF8.const.p("pMarkerName", "a pointer to a null-terminated UTF-8 string containing the name of the marker.")
    float("color", "an <b>optional</b> RGBA color value that can be associated with the marker. A particular implementation <b>may</b> choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in {@code color} are set to 0.0 then it is ignored.")[4]
}

val VkQueueFamilyQueryResultStatusPropertiesKHR = struct(Module.VULKAN, "VkQueueFamilyQueryResultStatusPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure specifying support for result status query.

        <h5>Description</h5>
        If this structure is included in the {@code pNext} chain of the ##VkQueueFamilyProperties2 structure passed to #GetPhysicalDeviceQueueFamilyProperties2(), then it is filled with information about whether <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#queries-result-status-only">result status queries</a> are supported by the specified queue family.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("queryResultStatusSupport", "reports #TRUE if query type #QUERY_TYPE_RESULT_STATUS_ONLY_KHR and use of #QUERY_RESULT_WITH_STATUS_BIT_KHR are supported.")
}

val VkQueueFamilyVideoPropertiesKHR = struct(Module.VULKAN, "VkQueueFamilyVideoPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing video codec operations supported by a queue family.

        <h5>Description</h5>
        If this structure is included in the {@code pNext} chain of the ##VkQueueFamilyProperties2 structure passed to #GetPhysicalDeviceQueueFamilyProperties2(), then it is filled with the set of video codec operations supported by the specified queue family.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoCodecOperationFlagsKHR("videoCodecOperations", "a bitmask of {@code VkVideoCodecOperationFlagBitsKHR} that indicates the set of video codec operations supported by the queue family.")
}

val VkVideoProfileInfoKHR = struct(Module.VULKAN, "VkVideoProfileInfoKHR") {
    documentation =
        """
        Structure specifying a video profile.

        <h5>Description</h5>
        Video profiles are provided as input to video capability queries such as #GetPhysicalDeviceVideoCapabilitiesKHR() or #GetPhysicalDeviceVideoFormatPropertiesKHR(), as well as when creating resources to be used by video coding operations such as images, buffers, query pools, and video sessions.

        The full description of a video profile is specified by an instance of this structure, and the codec-specific and auxiliary structures provided in its {@code pNext} chain.

        When this structure is specified as an input parameter to #GetPhysicalDeviceVideoCapabilitiesKHR(), or through the {@code pProfiles} member of an ##VkVideoProfileListInfoKHR structure in the {@code pNext} chain of the input parameter of a query command such as #GetPhysicalDeviceVideoFormatPropertiesKHR() or #GetPhysicalDeviceImageFormatProperties2(), the following error codes indicate specific causes of the failure of the query operation:

        <ul>
            <li>#ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR indicates that the requested video picture layout (e.g. through the {@code pictureLayout} member of a ##VkVideoDecodeH264ProfileInfoKHR structure included in the {@code pNext} chain of ##VkVideoProfileInfoKHR) is not supported.</li>
            <li>#ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR indicates that a video profile operation specified by {@code videoCodecOperation} is not supported.</li>
            <li>#ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR indicates that video format parameters specified by {@code chromaSubsampling}, {@code lumaBitDepth}, or {@code chromaBitDepth} are not supported.</li>
            <li>#ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR indicates that the codec-specific parameters corresponding to the video codec operation are not supported.</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code chromaSubsampling} <b>must</b> have a single bit set</li>
            <li>{@code lumaBitDepth} <b>must</b> have a single bit set</li>
            <li>If {@code chromaSubsampling} is not #VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR, then {@code chromaBitDepth} <b>must</b> have a single bit set</li>
            <li>If {@code videoCodecOperation} is #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the {@code pNext} chain <b>must</b> include a ##VkVideoDecodeH264ProfileInfoKHR structure</li>
            <li>If {@code videoCodecOperation} is #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the {@code pNext} chain <b>must</b> include a ##VkVideoDecodeH265ProfileInfoKHR structure</li>
            <li>If {@code videoCodecOperation} is #VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT, then the {@code pNext} chain <b>must</b> include a ##VkVideoEncodeH264ProfileInfoEXT structure</li>
            <li>If {@code videoCodecOperation} is #VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT, then the {@code pNext} chain <b>must</b> include a ##VkVideoEncodeH265ProfileInfoEXT structure</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR</li>
            <li>{@code videoCodecOperation} <b>must</b> be a valid {@code VkVideoCodecOperationFlagBitsKHR} value</li>
            <li>{@code chromaSubsampling} <b>must</b> be a valid combination of {@code VkVideoChromaSubsamplingFlagBitsKHR} values</li>
            <li>{@code chromaSubsampling} <b>must</b> not be 0</li>
            <li>{@code lumaBitDepth} <b>must</b> be a valid combination of {@code VkVideoComponentBitDepthFlagBitsKHR} values</li>
            <li>{@code lumaBitDepth} <b>must</b> not be 0</li>
            <li>{@code chromaBitDepth} <b>must</b> be a valid combination of {@code VkVideoComponentBitDepthFlagBitsKHR} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, ##VkVideoProfileListInfoKHR, ##VkVideoSessionCreateInfoKHR, #GetPhysicalDeviceVideoCapabilitiesKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoDecodeH264ProfileInfoKHR", "VkVideoDecodeH265ProfileInfoKHR", "VkVideoDecodeUsageInfoKHR", "VkVideoEncodeH264ProfileInfoEXT", "VkVideoEncodeH265ProfileInfoEXT", "VkVideoEncodeUsageInfoKHR",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoCodecOperationFlagBitsKHR("videoCodecOperation", "a {@code VkVideoCodecOperationFlagBitsKHR} value specifying a video codec operation.")
    VkVideoChromaSubsamplingFlagsKHR("chromaSubsampling", "a bitmask of {@code VkVideoChromaSubsamplingFlagBitsKHR} specifying video chroma subsampling information.")
    VkVideoComponentBitDepthFlagsKHR("lumaBitDepth", "a bitmask of {@code VkVideoComponentBitDepthFlagBitsKHR} specifying video luma bit depth information.")
    VkVideoComponentBitDepthFlagsKHR("chromaBitDepth", "a bitmask of {@code VkVideoComponentBitDepthFlagBitsKHR} specifying video chroma bit depth information.")
}

val VkVideoProfileListInfoKHR = struct(Module.VULKAN, "VkVideoProfileListInfoKHR") {
    documentation =
        """
        Structure specifying one or more video profiles used in conjunction.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note:</h5>
        Video transcoding is an example of a use case that necessitates the specification of multiple profiles in various contexts.
        </div>

        When the application provides a video decode profile and one or more video encode profiles in the profile list, the implementation ensures that any capabilitities returned or resources created are suitable for the video transcoding use cases without the need for manual data transformations.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code pProfiles} <b>must</b> not contain more than one element whose {@code videoCodecOperation} member specifies a decode operation</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR</li>
            <li>If {@code profileCount} is not 0, {@code pProfiles} <b>must</b> be a valid pointer to an array of {@code profileCount} valid ##VkVideoProfileInfoKHR structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoProfileInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pProfiles", optional = true)..uint32_t("profileCount", "the number of elements in the {@code pProfiles} array.")
    VkVideoProfileInfoKHR.const.p("pProfiles", "a pointer to an array of ##VkVideoProfileInfoKHR structures.")
}

val VkVideoCapabilitiesKHR = struct(Module.VULKAN, "VkVideoCapabilitiesKHR", mutable = false) {
    documentation =
        """
        Structure describing general video capabilities for a video profile.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note:</h5>
        It is common for video compression standards to allow using all reference pictures associated with active DPB slots as active reference pictures, hence for video decode profiles the values returned in {@code maxDpbSlots} and {@code maxActiveReferencePictures} are often equal. Similarly, in case of video decode profiles supporting field pictures the value of {@code maxActiveReferencePictures} often equals <code>maxDpbSlots × 2</code>.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoDecodeCapabilitiesKHR, ##VkVideoDecodeH264CapabilitiesKHR, ##VkVideoDecodeH265CapabilitiesKHR, ##VkVideoEncodeCapabilitiesKHR, ##VkVideoEncodeH264CapabilitiesEXT, or ##VkVideoEncodeH265CapabilitiesEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtensionProperties, ##VkExtent2D, #GetPhysicalDeviceVideoCapabilitiesKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    PointerSetter(
        "VkVideoDecodeCapabilitiesKHR", "VkVideoDecodeH264CapabilitiesKHR", "VkVideoDecodeH265CapabilitiesKHR", "VkVideoEncodeCapabilitiesKHR", "VkVideoEncodeH264CapabilitiesEXT", "VkVideoEncodeH265CapabilitiesEXT",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoCapabilityFlagsKHR("flags", "a bitmask of {@code VkVideoCapabilityFlagBitsKHR} specifying capability flags.")
    VkDeviceSize("minBitstreamBufferOffsetAlignment", "the minimum alignment for bitstream buffer offsets.")
    VkDeviceSize("minBitstreamBufferSizeAlignment", "the minimum alignment for bitstream buffer range sizes.")
    VkExtent2D("pictureAccessGranularity", "the granularity at which image access to video picture resources happen.")
    VkExtent2D("minCodedExtent", "the minimum width and height of the coded frames.")
    VkExtent2D("maxCodedExtent", "the maximum width and height of the coded frames.")
    uint32_t("maxDpbSlots", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#dpb-slot\">DPB slots</a> supported by a single video session.")
    uint32_t("maxActiveReferencePictures", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#active-reference-pictures\">active reference pictures</a> a single video coding operation <b>can</b> use.")
    VkExtensionProperties("stdHeaderVersion", "a ##VkExtensionProperties structure reporting the Video Std header name and version supported for the video profile.")
}

val VkPhysicalDeviceVideoFormatInfoKHR = struct(Module.VULKAN, "VkPhysicalDeviceVideoFormatInfoKHR") {
    documentation =
        """
        Structure specifying the codec video format.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL} or a pointer to a valid instance of ##VkVideoProfileListInfoKHR</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code imageUsage} <b>must</b> be a valid combination of {@code VkImageUsageFlagBits} values</li>
            <li>{@code imageUsage} <b>must</b> not be 0</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceVideoFormatPropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoProfileListInfoKHR",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageUsageFlags("imageUsage", "a bitmask of {@code VkImageUsageFlagBits} specifying the intended usage of the video images.")
}

val VkVideoFormatPropertiesKHR = struct(Module.VULKAN, "VkVideoFormatPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure enumerating the video image formats.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkComponentMapping, #GetPhysicalDeviceVideoFormatPropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkFormat("format", "a {@code VkFormat} that specifies the format that <b>can</b> be used with the specified video profiles and image usages.")
    VkComponentMapping("componentMapping", "defines the color channel order used for the format. {@code format} along with {@code componentMapping} describe how the color channels are ordered when producing video decoder output or are expected to be ordered in video encoder input, when applicable. If the {@code format} reported does not require component swizzling then all members of {@code componentMapping} will be set to #COMPONENT_SWIZZLE_IDENTITY.")
    VkImageCreateFlags("imageCreateFlags", "a bitmask of {@code VkImageCreateFlagBits} specifying the supported image creation flags for the format.")
    VkImageType("imageType", "a {@code VkImageType} that specifies the image type the format <b>can</b> be used with.")
    VkImageTiling("imageTiling", "a {@code VkImageTiling} that specifies the image tiling the format <b>can</b> be used with.")
    VkImageUsageFlags("imageUsageFlags", "a bitmask of {@code VkImageUsageFlagBits} specifying the supported image usage flags for the format.")
}

val VkVideoPictureResourceInfoKHR = struct(Module.VULKAN, "VkVideoPictureResourceInfoKHR") {
    documentation =
        """
        Structure specifying the parameters of a video picture resource.

        <h5>Description</h5>
        The image subresource referred to by such a structure is defined as the image array layer index specified in {@code baseArrayLayer} relative to the image subresource range the image view specified in {@code imageViewBinding} was created with.

        The meaning of the {@code codedOffset} and {@code codedExtent} depends on the command and context the video picture resource is used in, as well as on the used <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-profiles">video profile</a> and corresponding codec-specific semantics, as described later.

        A video picture resource is uniquely defined by the image subresource referred to by an instance of this structure, together with the {@code codedOffset} and {@code codedExtent} members that identify the image subregion within the image subresource referenced corresponding to the video picture resource according to the particular codec-specific semantics.

        Accesses to image data within a video picture resource happen at the granularity indicated by ##VkVideoCapabilitiesKHR{@code ::pictureAccessGranularity}, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the used <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-profiles">video profile</a>. As a result, given an effective image subregion corresponding to a video picture resource, the actual image subregion accessed <b>may</b> be larger than that as it <b>may</b> include additional padding texels due to the picture access granularity. Any writes performed by video coding operations to such padding texels will result in undefined texel values.

        Two video picture resources match if they refer to the same image subresource and they specify identical {@code codedOffset} and {@code codedExtent} values.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code baseArrayLayer} <b>must</b> be less than the ##VkImageViewCreateInfo{@code ::subresourceRange.layerCount} specified when the image view {@code imageViewBinding} was created</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code imageViewBinding} <b>must</b> be a valid {@code VkImageView} handle</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, ##VkOffset2D, ##VkVideoDecodeInfoKHR, ##VkVideoEncodeInfoKHR, ##VkVideoReferenceSlotInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkOffset2D("codedOffset", "the offset in texels of the image subregion to use.")
    VkExtent2D("codedExtent", "the size in pixels of the coded image data.")
    uint32_t("baseArrayLayer", "the array layer of the image view specified in {@code imageViewBinding} to use as the video picture resource.")
    VkImageView("imageViewBinding", "an image view representing the video picture resource.")
}

val VkVideoReferenceSlotInfoKHR = struct(Module.VULKAN, "VkVideoReferenceSlotInfoKHR") {
    documentation =
        """
        Structure specifying information about a reference picture slot.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoDecodeH264DpbSlotInfoKHR, ##VkVideoDecodeH265DpbSlotInfoKHR, ##VkVideoEncodeH264DpbSlotInfoEXT, or ##VkVideoEncodeH265DpbSlotInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>If {@code pPictureResource} is not {@code NULL}, {@code pPictureResource} <b>must</b> be a valid pointer to a valid ##VkVideoPictureResourceInfoKHR structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoBeginCodingInfoKHR, ##VkVideoDecodeInfoKHR, ##VkVideoEncodeInfoKHR, ##VkVideoPictureResourceInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoDecodeH264DpbSlotInfoKHR", "VkVideoDecodeH265DpbSlotInfoKHR", "VkVideoEncodeH264DpbSlotInfoEXT", "VkVideoEncodeH265DpbSlotInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    int32_t("slotIndex", "the index of the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#dpb-slot\">DPB slot</a> or a negative integer value.")
    nullable..VkVideoPictureResourceInfoKHR.const.p("pPictureResource", "{@code NULL} or a pointer to a ##VkVideoPictureResourceInfoKHR structure describing the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#video-picture-resources\">video picture resource</a> associated with the DPB slot index specified by {@code slotIndex}.")
}

val VkVideoSessionMemoryRequirementsKHR = struct(Module.VULKAN, "VkVideoSessionMemoryRequirementsKHR", mutable = false) {
    documentation =
        """
        Structure describing video session memory requirements.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkMemoryRequirements, #GetVideoSessionMemoryRequirementsKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("memoryBindIndex", "the index of the memory binding.")
    VkMemoryRequirements("memoryRequirements", "a ##VkMemoryRequirements structure in which the requested memory binding requirements for the binding index specified by {@code memoryBindIndex} are returned.")
}

val VkBindVideoSessionMemoryInfoKHR = struct(Module.VULKAN, "VkBindVideoSessionMemoryInfoKHR") {
    documentation =
        """
        Structure specifying memory bindings for a video session object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code memoryOffset} <b>must</b> be less than the size of {@code memory}</li>
            <li>{@code memorySize} <b>must</b> be less than or equal to the size of {@code memory} minus {@code memoryOffset}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
        </ul>

        <h5>See Also</h5>
        #BindVideoSessionMemoryKHR()
        """

    Expression("#STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("memoryBindIndex", "the memory binding index to bind memory to.")
    VkDeviceMemory("memory", "the allocated device memory to be bound to the video session’s memory binding with index {@code memoryBindIndex}.")
    VkDeviceSize("memoryOffset", "the start offset of the region of {@code memory} which is to be bound.")
    VkDeviceSize("memorySize", "the size in bytes of the region of {@code memory}, starting from {@code memoryOffset} bytes, to be bound.")
}

val VkVideoSessionCreateInfoKHR = struct(Module.VULKAN, "VkVideoSessionCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created video session.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-protectedMemory">{@code protectedMemory}</a> feature is not enabled or if ##VkVideoCapabilitiesKHR{@code ::flags} does not include #VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile specified by {@code pVideoProfile}, then {@code flags} <b>must</b> not include #VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR</li>
            <li>{@code pVideoProfile} <b>must</b> be a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-profile-support">supported video profile</a></li>
            <li>{@code maxDpbSlots} <b>must</b> be less than or equal to ##VkVideoCapabilitiesKHR{@code ::maxDpbSlots}, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile specified by {@code pVideoProfile}</li>
            <li>{@code maxActiveReferencePictures} <b>must</b> be less than or equal to ##VkVideoCapabilitiesKHR{@code ::maxActiveReferencePictures}, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile specified by {@code pVideoProfile}</li>
            <li>If either {@code maxDpbSlots} or {@code maxActiveReferencePictures} is 0, then both <b>must</b> be 0</li>
            <li>{@code maxCodedExtent} <b>must</b> be between ##VkVideoCapabilitiesKHR{@code ::minCodedExtent} and ##VkVideoCapabilitiesKHR{@code ::maxCodedExtent}, inclusive, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile specified by {@code pVideoProfile}</li>
            <li>If {@code pVideoProfile→videoCodecOperation} specifies a decode operation and {@code maxActiveReferencePictures} is greater than 0, then {@code referencePictureFormat} <b>must</b> be one of the supported decode DPB formats, as returned by #GetPhysicalDeviceVideoFormatPropertiesKHR() in ##VkVideoFormatPropertiesKHR{@code ::format} when called with the {@code imageUsage} member of its {@code pVideoFormatInfo} parameter containing #IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, and with a ##VkVideoProfileListInfoKHR structure specified in the {@code pNext} chain of its {@code pVideoFormatInfo} parameter whose {@code pProfiles} member contains an element matching {@code pVideoProfile}</li>
            <li>If {@code pVideoProfile→videoCodecOperation} specifies an encode operation and {@code maxActiveReferencePictures} is greater than 0, then {@code referencePictureFormat} <b>must</b> be one of the supported decode DPB formats, as returned by then {@code referencePictureFormat} <b>must</b> be one of the supported encode DPB formats, as returned by #GetPhysicalDeviceVideoFormatPropertiesKHR() in ##VkVideoFormatPropertiesKHR{@code ::format} when called with the {@code imageUsage} member of its {@code pVideoFormatInfo} parameter containing #IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, and with a ##VkVideoProfileListInfoKHR structure specified in the {@code pNext} chain of its {@code pVideoFormatInfo} parameter whose {@code pProfiles} member contains an element matching {@code pVideoProfile}</li>
            <li>If {@code pVideoProfile→videoCodecOperation} specifies a decode operation, then {@code pictureFormat} <b>must</b> be one of the supported decode output formats, as returned by #GetPhysicalDeviceVideoFormatPropertiesKHR() in ##VkVideoFormatPropertiesKHR{@code ::format} when called with the {@code imageUsage} member of its {@code pVideoFormatInfo} parameter containing #IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, and with a ##VkVideoProfileListInfoKHR structure specified in the {@code pNext} chain of its {@code pVideoFormatInfo} parameter whose {@code pProfiles} member contains an element matching {@code pVideoProfile}</li>
            <li>If {@code pVideoProfile→videoCodecOperation} specifies an encode operation, then {@code pictureFormat} <b>must</b> be one of the supported encode input formats, as returned by #GetPhysicalDeviceVideoFormatPropertiesKHR() in ##VkVideoFormatPropertiesKHR{@code ::format} when called with the {@code imageUsage} member of its {@code pVideoFormatInfo} parameter containing #IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, and with a ##VkVideoProfileListInfoKHR structure specified in the {@code pNext} chain of its {@code pVideoFormatInfo} parameter whose {@code pProfiles} member contains an element matching {@code pVideoProfile}</li>
            <li>{@code pStdHeaderVersion→extensionName} <b>must</b> match ##VkVideoCapabilitiesKHR{@code ::stdHeaderVersion.extensionName}, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile specified by {@code pVideoProfile}</li>
            <li>{@code pStdHeaderVersion→specVersion} <b>must</b> be less than or equal to ##VkVideoCapabilitiesKHR{@code ::stdHeaderVersion.specVersion}, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile specified by {@code pVideoProfile}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264SessionCreateInfoEXT or ##VkVideoEncodeH265SessionCreateInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkVideoSessionCreateFlagBitsKHR} values</li>
            <li>{@code pVideoProfile} <b>must</b> be a valid pointer to a valid ##VkVideoProfileInfoKHR structure</li>
            <li>{@code pictureFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code referencePictureFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code pStdHeaderVersion} <b>must</b> be a valid pointer to a valid ##VkExtensionProperties structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtensionProperties, ##VkExtent2D, ##VkVideoProfileInfoKHR, #CreateVideoSessionKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoEncodeH264SessionCreateInfoEXT", "VkVideoEncodeH265SessionCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("queueFamilyIndex", "the index of the queue family the created video session will be used with.")
    VkVideoSessionCreateFlagsKHR("flags", "a bitmask of {@code VkVideoSessionCreateFlagBitsKHR} specifying creation flags.")
    VkVideoProfileInfoKHR.const.p("pVideoProfile", "a pointer to a ##VkVideoProfileInfoKHR structure specifying the video profile the created video session will be used with.")
    VkFormat("pictureFormat", "the image format the created video session will be used with. If {@code pVideoProfile→videoCodecOperation} specifies a decode operation, then {@code pictureFormat} is the image format of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-output-picture\">decode output pictures</a> usable with the created video session. If {@code pVideoProfile→videoCodecOperation} specifies an encode operation, then {@code pictureFormat} is the image format of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#encode-input-picture\">encode input pictures</a> usable with the created video session.")
    VkExtent2D("maxCodedExtent", "the maximum width and height of the coded frames the created video session will be used with.")
    VkFormat("referencePictureFormat", "the image format of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#reference-picture\">reference pictures</a> stored in the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#dpb\">DPB</a> the created video session will be used with.")
    uint32_t("maxDpbSlots", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#dpb-slot\">DPB Slots</a> that <b>can</b> be used with the created video session.")
    uint32_t("maxActiveReferencePictures", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#active-reference-pictures\">active reference pictures</a> that <b>can</b> be used in a single video coding operation using the created video session.")
    VkExtensionProperties.const.p("pStdHeaderVersion", "a pointer to a ##VkExtensionProperties structure requesting the Video Std header version to use for the {@code videoCodecOperation} specified in {@code pVideoProfile}.")
}

val VkVideoSessionParametersCreateInfoKHR = struct(Module.VULKAN, "VkVideoSessionParametersCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created video session parameters object.

        <h5>Description</h5>
        Limiting values are defined below that are referenced by the relevant valid usage statements of this structure.

        <ul>
            <li>
                If {@code videoSession} was created with the codec operation #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then let {@code StdVideoH264SequenceParameterSet spsAddList[]} be the list of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-sps">H.264 SPS</a> entries to add to the created video session parameters object, defined as follows:
                <ul>
                    <li>If the {@code pParametersAddInfo} member of the ##VkVideoDecodeH264SessionParametersCreateInfoKHR structure provided in the {@code pNext} chain is not {@code NULL}, then the set of {@code StdVideoH264SequenceParameterSet} entries specified in {@code pParametersAddInfo→pStdSPSs} are added to {@code spsAddList};</li>
                    <li>If {@code videoSessionParametersTemplate} is not #NULL_HANDLE, then each {@code StdVideoH264SequenceParameterSet} entry stored in it with {@code seq_parameter_set_id} not matching any of the entries already in {@code spsAddList} is added to {@code spsAddList}.</li>
                </ul>
            </li>
            <li>
                If {@code videoSession} was created with the codec operation #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then let {@code StdVideoH264PictureParameterSet ppsAddList[]} be the list of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-pps">H.264 PPS</a> entries to add to the created video session parameters object, defined as follows:
                <ul>
                    <li>If the {@code pParametersAddInfo} member of the ##VkVideoDecodeH264SessionParametersCreateInfoKHR structure provided in the {@code pNext} chain is not {@code NULL}, then the set of {@code StdVideoH264PictureParameterSet} entries specified in {@code pParametersAddInfo→pStdPPSs} are added to {@code ppsAddList};</li>
                    <li>If {@code videoSessionParametersTemplate} is not #NULL_HANDLE, then each {@code StdVideoH264PictureParameterSet} entry stored in it with {@code seq_parameter_set_id} or {@code pic_parameter_set_id} not matching any of the entries already in {@code ppsAddList} is added to {@code ppsAddList}.</li>
                </ul>
            </li>
            <li>
                If {@code videoSession} was created with the codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then let {@code StdVideoH265VideoParameterSet vpsAddList[]} be the list of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-vps">H.265 VPS</a> entries to add to the created video session parameters object, defined as follows:
                <ul>
                    <li>If the {@code pParametersAddInfo} member of the ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure provided in the {@code pNext} chain is not {@code NULL}, then the set of {@code StdVideoH265VideoParameterSet} entries specified in {@code pParametersAddInfo→pStdVPSs} are added to {@code vpsAddList};</li>
                    <li>If {@code videoSessionParametersTemplate} is not #NULL_HANDLE, then each {@code StdVideoH265VideoParameterSet} entry stored in it with {@code vps_video_parameter_set_id} not matching any of the entries already in {@code vpsAddList} is added to {@code vpsAddList}.</li>
                </ul>
            </li>
            <li>
                If {@code videoSession} was created with the codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then let {@code StdVideoH265SequenceParameterSet spsAddList[]} be the list of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-sps">H.265 SPS</a> entries to add to the created video session parameters object, defined as follows:
                <ul>
                    <li>If the {@code pParametersAddInfo} member of the ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure provided in the {@code pNext} chain is not {@code NULL}, then the set of {@code StdVideoH265SequenceParameterSet} entries specified in {@code pParametersAddInfo→pStdSPSs} are added to {@code spsAddList};</li>
                    <li>If {@code videoSessionParametersTemplate} is not #NULL_HANDLE, then each {@code StdVideoH265SequenceParameterSet} entry stored in it with {@code sps_video_parameter_set_id} or {@code sps_seq_parameter_set_id} not matching any of the entries already in {@code spsAddList} is added to {@code spsAddList}.</li>
                </ul>
            </li>
            <li>
                If {@code videoSession} was created with the codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then let {@code StdVideoH265PictureParameterSet ppsAddList[]} be the list of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-pps">H.265 PPS</a> entries to add to the created video session parameters object, defined as follows:
                <ul>
                    <li>If the {@code pParametersAddInfo} member of the ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure provided in the {@code pNext} chain is not {@code NULL}, then the set of {@code StdVideoH265PictureParameterSet} entries specified in {@code pParametersAddInfo→pStdPPSs} are added to {@code ppsAddList};</li>
                    <li>If {@code videoSessionParametersTemplate} is not #NULL_HANDLE, then each {@code StdVideoH265PictureParameterSet} entry stored in it with {@code sps_video_parameter_set_id}, {@code pps_seq_parameter_set_id}, or {@code pps_pic_parameter_set_id} not matching any of the entries already in {@code ppsAddList} is added to {@code ppsAddList}.</li>
                </ul>
            </li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code videoSessionParametersTemplate} represents a valid handle, it <b>must</b> have been created against {@code videoSession}</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the {@code pNext} chain <b>must</b> include a ##VkVideoDecodeH264SessionParametersCreateInfoKHR structure</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the number of elements of {@code spsAddList} <b>must</b> be less than or equal to the {@code maxStdSPSCount} specified in the ##VkVideoDecodeH264SessionParametersCreateInfoKHR structure included in the {@code pNext} chain</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the number of elements of {@code ppsAddList} <b>must</b> be less than or equal to the {@code maxStdPPSCount} specified in the ##VkVideoDecodeH264SessionParametersCreateInfoKHR structure included in the {@code pNext} chain</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the {@code pNext} chain <b>must</b> include a ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of elements of {@code vpsAddList} <b>must</b> be less than or equal to the {@code maxStdVPSCount} specified in the ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure included in the {@code pNext} chain</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of elements of {@code spsAddList} <b>must</b> be less than or equal to the {@code maxStdSPSCount} specified in the ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure included in the {@code pNext} chain</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of elements of {@code ppsAddList} <b>must</b> be less than or equal to the {@code maxStdPPSCount} specified in the ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure included in the {@code pNext} chain</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT, then the {@code pNext} chain <b>must</b> include a ##VkVideoEncodeH264SessionParametersCreateInfoEXT structure</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT, then the {@code pNext} chain <b>must</b> include a ##VkVideoEncodeH265SessionParametersCreateInfoEXT structure</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoDecodeH264SessionParametersCreateInfoKHR, ##VkVideoDecodeH265SessionParametersCreateInfoKHR, ##VkVideoEncodeH264SessionParametersCreateInfoEXT, ##VkVideoEncodeH265SessionParametersCreateInfoEXT, or ##VkVideoEncodeQualityLevelInfoKHR</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>If {@code videoSessionParametersTemplate} is not #NULL_HANDLE, {@code videoSessionParametersTemplate} <b>must</b> be a valid {@code VkVideoSessionParametersKHR} handle</li>
            <li>{@code videoSession} <b>must</b> be a valid {@code VkVideoSessionKHR} handle</li>
            <li>If {@code videoSessionParametersTemplate} is a valid handle, it <b>must</b> have been created, allocated, or retrieved from {@code videoSession}</li>
            <li>Both of {@code videoSession}, and {@code videoSessionParametersTemplate} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #CreateVideoSessionParametersKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoDecodeH264SessionParametersCreateInfoKHR", "VkVideoDecodeH265SessionParametersCreateInfoKHR", "VkVideoEncodeH264SessionParametersCreateInfoEXT", "VkVideoEncodeH265SessionParametersCreateInfoEXT", "VkVideoEncodeQualityLevelInfoKHR",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoSessionParametersCreateFlagsKHR("flags", "reserved for future use.")
    VkVideoSessionParametersKHR("videoSessionParametersTemplate", "#NULL_HANDLE or a valid handle to a {@code VkVideoSessionParametersKHR} object used as a template for constructing the new video session parameters object.")
    VkVideoSessionKHR("videoSession", "the video session object against which the video session parameters object is going to be created.")
}

val VkVideoSessionParametersUpdateInfoKHR = struct(Module.VULKAN, "VkVideoSessionParametersUpdateInfoKHR") {
    documentation =
        """
        Structure specifying video session parameters update information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoDecodeH264SessionParametersAddInfoKHR, ##VkVideoDecodeH265SessionParametersAddInfoKHR, ##VkVideoEncodeH264SessionParametersAddInfoEXT, or ##VkVideoEncodeH265SessionParametersAddInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        #UpdateVideoSessionParametersKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoDecodeH264SessionParametersAddInfoKHR", "VkVideoDecodeH265SessionParametersAddInfoKHR", "VkVideoEncodeH264SessionParametersAddInfoEXT", "VkVideoEncodeH265SessionParametersAddInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("updateSequenceCount", "the new <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#video-session-parameters\">update sequence count</a> to set for the video session parameters object.")
}

val VkVideoBeginCodingInfoKHR = struct(Module.VULKAN, "VkVideoBeginCodingInfoKHR") {
    documentation =
        """
        Structure specifying video coding scope begin information.

        <h5>Description</h5>
        Limiting values are defined below that are referenced by the relevant valid usage statements of this structure.

        <ul>
            <li>
                Let {@code VkOffset2D codedOffsetGranularity} be the minimum alignment requirement for the coded offset of video picture resources. Unless otherwise defined, the value of the {@code x} and {@code y} members of {@code codedOffsetGranularity} are 0.
                <ul>
                    <li>If {@code videoSession} was created with an <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-profile">H.264 decode profile</a> with a ##VkVideoDecodeH264ProfileInfoKHR{@code ::pictureLayout} of #VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR, then {@code codedOffsetGranularity} is equal to ##VkVideoDecodeH264CapabilitiesKHR{@code ::fieldOffsetGranularity}, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for that video profile.</li>
                </ul>
            </li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code videoSession} <b>must</b> have memory bound to all of its memory bindings returned by #GetVideoSessionMemoryRequirementsKHR() for {@code videoSession}</li>
            <li>Each non-negative ##VkVideoReferenceSlotInfoKHR{@code ::slotIndex} specified in the elements of {@code pReferenceSlots} <b>must</b> be less than the ##VkVideoSessionCreateInfoKHR{@code ::maxDpbSlots} specified when {@code videoSession} was created</li>
            <li>Each video picture resource corresponding to any non-{@code NULL} {@code pPictureResource} member specified in the elements of {@code pReferenceSlots} <b>must</b> be <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-picture-resource-uniqueness">unique</a> within {@code pReferenceSlots}</li>
            <li>If the {@code pPictureResource} member of any element of {@code pReferenceSlots} is not {@code NULL}, then the image view specified in {@code pPictureResource→imageViewBinding} for that element <b>must</b> be <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-profile-compatibility">compatible</a> with the video profile {@code videoSession} was created with</li>
            <li>If the {@code pPictureResource} member of any element of {@code pReferenceSlots} is not {@code NULL}, then the format of the image view specified in {@code pPictureResource→imageViewBinding} for that element <b>must</b> match the ##VkVideoSessionCreateInfoKHR{@code ::referencePictureFormat} {@code videoSession} was created with</li>
            <li>If the {@code pPictureResource} member of any element of {@code pReferenceSlots} is not {@code NULL}, then its {@code codedOffset} member <b>must</b> be an integer multiple of {@code codedOffsetGranularity}</li>
            <li>If the {@code pPictureResource} member of any element of {@code pReferenceSlots} is not {@code NULL}, then its {@code codedExtent} member <b>must</b> be between {@code minCodedExtent} and {@code maxCodedExtent}, inclusive, {@code videoSession} was created with</li>
            <li>If ##VkVideoCapabilitiesKHR{@code ::flags} does not include #VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR, as returned by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile {@code videoSession} was created with, then {@code pPictureResource→imageViewBinding} of all elements of {@code pReferenceSlots} with a non-{@code NULL} {@code pPictureResource} member <b>must</b> specify image views created from the same image</li>
            <li>If {@code videoSession} was created with a decode operation and the {@code slotIndex} member of any element of {@code pReferenceSlots} is not negative, then the image view specified in {@code pPictureResource→imageViewBinding} for that element <b>must</b> have been created with #IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR</li>
            <li>If {@code videoSession} was created with an encode operation and the {@code slotIndex} member of any element of {@code pReferenceSlots} is not negative, then the image view specified in {@code pPictureResource→imageViewBinding} for that element <b>must</b> have been created with #IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then {@code videoSessionParameters} <b>must</b> not be #NULL_HANDLE</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then {@code videoSessionParameters} <b>must</b> not be #NULL_HANDLE</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT, then {@code videoSessionParameters} <b>must</b> not be #NULL_HANDLE</li>
            <li>If {@code videoSession} was created with the video codec operation #VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT, then {@code videoSessionParameters} <b>must</b> not be #NULL_HANDLE</li>
            <li>If {@code videoSessionParameters} is not #NULL_HANDLE, it <b>must</b> have been created with {@code videoSession} specified in ##VkVideoSessionParametersCreateInfoKHR{@code ::videoSession}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264GopRemainingFrameInfoEXT, ##VkVideoEncodeH264RateControlInfoEXT, ##VkVideoEncodeH265GopRemainingFrameInfoEXT, ##VkVideoEncodeH265RateControlInfoEXT, or ##VkVideoEncodeRateControlInfoKHR</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code videoSession} <b>must</b> be a valid {@code VkVideoSessionKHR} handle</li>
            <li>If {@code videoSessionParameters} is not #NULL_HANDLE, {@code videoSessionParameters} <b>must</b> be a valid {@code VkVideoSessionParametersKHR} handle</li>
            <li>If {@code referenceSlotCount} is not 0, {@code pReferenceSlots} <b>must</b> be a valid pointer to an array of {@code referenceSlotCount} valid ##VkVideoReferenceSlotInfoKHR structures</li>
            <li>If {@code videoSessionParameters} is a valid handle, it <b>must</b> have been created, allocated, or retrieved from {@code videoSession}</li>
            <li>Both of {@code videoSession}, and {@code videoSessionParameters} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoReferenceSlotInfoKHR, #CmdBeginVideoCodingKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoEncodeH264GopRemainingFrameInfoEXT", "VkVideoEncodeH264RateControlInfoEXT", "VkVideoEncodeH265GopRemainingFrameInfoEXT", "VkVideoEncodeH265RateControlInfoEXT", "VkVideoEncodeRateControlInfoKHR",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoBeginCodingFlagsKHR("flags", "reserved for future use.")
    VkVideoSessionKHR("videoSession", "the video session object to be bound for the processing of the video commands.")
    VkVideoSessionParametersKHR("videoSessionParameters", "#NULL_HANDLE or a handle of a {@code VkVideoSessionParametersKHR} object to be used for the processing of the video commands. If #NULL_HANDLE, then no video session parameters object is bound for the duration of the video coding scope.")
    AutoSize("pReferenceSlots", optional = true)..uint32_t("referenceSlotCount", "the number of elements in the {@code pReferenceSlots} array.")
    VkVideoReferenceSlotInfoKHR.const.p("pReferenceSlots", "a pointer to an array of ##VkVideoReferenceSlotInfoKHR structures specifying the information used to determine the set of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#bound-reference-picture-resources\">bound reference picture resources</a> for the video coding scope and their initial association with <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#dpb-slot\">DPB slot</a> indices.")
}

val VkVideoEndCodingInfoKHR = struct(Module.VULKAN, "VkVideoEndCodingInfoKHR") {
    documentation =
        """
        Structure specifying video coding scope end information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CmdEndVideoCodingKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoEndCodingFlagsKHR("flags", "reserved for future use.")
}

val VkVideoCodingControlInfoKHR = struct(Module.VULKAN, "VkVideoCodingControlInfoKHR") {
    documentation =
        """
        Structure specifying video coding control parameters.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code flags} includes #VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, then the {@code pNext} chain <b>must</b> include a ##VkVideoEncodeRateControlInfoKHR structure</li>
            <li>If {@code flags} includes #VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, the {@code rateControlMode} member of ##VkVideoEncodeRateControlInfoKHR included in the {@code pNext} chain is not #VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR or #VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR, and the bound video session was created with the video codec operation #VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT, then the {@code pNext} chain <b>must</b> include a ##VkVideoEncodeH264RateControlInfoEXT structure</li>
            <li>If the {@code pNext} chain includes a ##VkVideoEncodeRateControlInfoKHR, and ##VkVideoEncodeRateControlInfoKHR{@code ::layerCount} is greater than 1, then ##VkVideoEncodeH264RateControlInfoEXT{@code ::temporalLayerCount} <b>must</b> be equal to {@code layerCount}</li>
            <li>If {@code flags} includes #VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, the {@code rateControlMode} member of ##VkVideoEncodeRateControlInfoKHR included in the {@code pNext} chain is not #VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR or #VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR, and the bound video session was created with the video codec operation #VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT, then the {@code pNext} chain <b>must</b> include a ##VkVideoEncodeH265RateControlInfoEXT structure</li>
            <li>If the {@code pNext} chain includes a ##VkVideoEncodeRateControlInfoKHR, and ##VkVideoEncodeRateControlInfoKHR{@code ::layerCount} is greater than 1, then ##VkVideoEncodeH265RateControlInfoEXT{@code ::subLayerCount} <b>must</b> be equal to {@code layerCount}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264RateControlInfoEXT, ##VkVideoEncodeH265RateControlInfoEXT, ##VkVideoEncodeQualityLevelInfoKHR, or ##VkVideoEncodeRateControlInfoKHR</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkVideoCodingControlFlagBitsKHR} values</li>
            <li>{@code flags} <b>must</b> not be 0</li>
        </ul>

        <h5>See Also</h5>
        #CmdControlVideoCodingKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoEncodeH264RateControlInfoEXT", "VkVideoEncodeH265RateControlInfoEXT", "VkVideoEncodeQualityLevelInfoKHR", "VkVideoEncodeRateControlInfoKHR",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoCodingControlFlagsKHR("flags", "a bitmask of {@code VkVideoCodingControlFlagsKHR} specifying control flags.")
}

val VkVideoDecodeCapabilitiesKHR = struct(Module.VULKAN, "VkVideoDecodeCapabilitiesKHR", mutable = false) {
    documentation =
        """
        Structure describing general video decode capabilities for a video profile.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoDecodeCapabilityFlagsKHR("flags", "a bitmask of {@code VkVideoDecodeCapabilityFlagBitsKHR} describing the supported video decoding capabilities.")
}

val VkVideoDecodeUsageInfoKHR = struct(Module.VULKAN, "VkVideoDecodeUsageInfoKHR") {
    documentation =
        """
        Structure specifying video decode usage information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR</li>
            <li>{@code videoUsageHints} <b>must</b> be a valid combination of {@code VkVideoDecodeUsageFlagBitsKHR} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoDecodeUsageFlagsKHR("videoUsageHints", "a bitmask of {@code VkVideoDecodeUsageFlagBitsKHR} specifying hints about the intended use of the video decode profile.")
}

val VkVideoDecodeInfoKHR = struct(Module.VULKAN, "VkVideoDecodeInfoKHR") {
    documentation =
        """
        Structure specifying video decode parameters.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code srcBuffer} <b>must</b> have been created with #BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR set</li>
            <li>{@code srcBufferOffset} <b>must</b> be less than the size of {@code srcBuffer}</li>
            <li>{@code srcBufferRange} <b>must</b> be less than or equal to the size of {@code srcBuffer} minus {@code srcBufferOffset}</li>
            <li>If {@code pSetupReferenceSlot} is not {@code NULL}, then its {@code slotIndex} member <b>must</b> not be negative</li>
            <li>If {@code pSetupReferenceSlot} is not {@code NULL}, then its {@code pPictureResource} <b>must</b> not be {@code NULL}</li>
            <li>The {@code slotIndex} member of each element of {@code pReferenceSlots} <b>must</b> not be negative</li>
            <li>The {@code pPictureResource} member of each element of {@code pReferenceSlots} <b>must</b> not be {@code NULL}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoDecodeH264PictureInfoKHR or ##VkVideoDecodeH265PictureInfoKHR</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code srcBuffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code dstPictureResource} <b>must</b> be a valid ##VkVideoPictureResourceInfoKHR structure</li>
            <li>If {@code pSetupReferenceSlot} is not {@code NULL}, {@code pSetupReferenceSlot} <b>must</b> be a valid pointer to a valid ##VkVideoReferenceSlotInfoKHR structure</li>
            <li>If {@code referenceSlotCount} is not 0, {@code pReferenceSlots} <b>must</b> be a valid pointer to an array of {@code referenceSlotCount} valid ##VkVideoReferenceSlotInfoKHR structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoPictureResourceInfoKHR, ##VkVideoReferenceSlotInfoKHR, #CmdDecodeVideoKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoDecodeH264PictureInfoKHR", "VkVideoDecodeH265PictureInfoKHR",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoDecodeFlagsKHR("flags", "reserved for future use.")
    VkBuffer("srcBuffer", "the source video bitstream buffer to read the encoded bitstream from.")
    VkDeviceSize("srcBufferOffset", "the starting offset in bytes from the start of {@code srcBuffer} to read the encoded bitstream from.")
    VkDeviceSize("srcBufferRange", "the size in bytes of the encoded bitstream to decode from {@code srcBuffer}, starting from {@code srcBufferOffset}.")
    VkVideoPictureResourceInfoKHR("dstPictureResource", "the video picture resource to use as the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-output-picture\">decode output picture</a>.")
    nullable..VkVideoReferenceSlotInfoKHR.const.p("pSetupReferenceSlot", "{@code NULL} or a pointer to a ##VkVideoReferenceSlotInfoKHR structure describing the DPB slot to <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#dpb-slot-states\">activate</a> and the video picture resource to use as the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#reconstructed-picture\">reconstructed picture</a> to activate the DPB slot with.")
    AutoSize("pReferenceSlots", optional = true)..uint32_t("referenceSlotCount", "the number of elements in the {@code pReferenceSlots} array.")
    VkVideoReferenceSlotInfoKHR.const.p("pReferenceSlots", "{@code NULL} or a pointer to an array of ##VkVideoReferenceSlotInfoKHR structures describing the DPB slots and corresponding <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#reference-picture\">reference picture</a> resources to use in this video decode operation (the set of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#active-reference-pictures\">active reference pictures</a>).")
}

val VkDedicatedAllocationImageCreateInfoNV = struct(Module.VULKAN, "VkDedicatedAllocationImageCreateInfoNV") {
    documentation =
        """
        Specify that an image is bound to a dedicated memory resource.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Using a dedicated allocation for color and depth/stencil attachments or other large images <b>may</b> improve performance on some devices.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code dedicatedAllocation} is #TRUE, ##VkImageCreateInfo{@code ::flags} <b>must</b> not include #IMAGE_CREATE_SPARSE_BINDING_BIT, #IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or #IMAGE_CREATE_SPARSE_ALIASED_BIT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("dedicatedAllocation", "specifies whether the image will have a dedicated allocation bound to it.")
}

val VkDedicatedAllocationBufferCreateInfoNV = struct(Module.VULKAN, "VkDedicatedAllocationBufferCreateInfoNV") {
    documentation =
        """
        Specify that a buffer is bound to a dedicated memory resource.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("dedicatedAllocation", "specifies whether the buffer will have a dedicated allocation bound to it.")
}

val VkDedicatedAllocationMemoryAllocateInfoNV = struct(Module.VULKAN, "VkDedicatedAllocationMemoryAllocateInfoNV") {
    documentation =
        """
        Specify a dedicated memory allocation resource.

        <h5>Valid Usage</h5>
        <ul>
            <li>At least one of {@code image} and {@code buffer} <b>must</b> be #NULL_HANDLE</li>
            <li>If {@code image} is not #NULL_HANDLE, the image <b>must</b> have been created with ##VkDedicatedAllocationImageCreateInfoNV{@code ::dedicatedAllocation} equal to #TRUE</li>
            <li>If {@code buffer} is not #NULL_HANDLE, the buffer <b>must</b> have been created with ##VkDedicatedAllocationBufferCreateInfoNV{@code ::dedicatedAllocation} equal to #TRUE</li>
            <li>If {@code image} is not #NULL_HANDLE, ##VkMemoryAllocateInfo{@code ::allocationSize} <b>must</b> equal the ##VkMemoryRequirements{@code ::size} of the image</li>
            <li>If {@code buffer} is not #NULL_HANDLE, ##VkMemoryAllocateInfo{@code ::allocationSize} <b>must</b> equal the ##VkMemoryRequirements{@code ::size} of the buffer</li>
            <li>If {@code image} is not #NULL_HANDLE and ##VkMemoryAllocateInfo defines a memory import operation, the memory being imported <b>must</b> also be a dedicated image allocation and {@code image} <b>must</b> be identical to the image associated with the imported memory</li>
            <li>If {@code buffer} is not #NULL_HANDLE and ##VkMemoryAllocateInfo defines a memory import operation, the memory being imported <b>must</b> also be a dedicated buffer allocation and {@code buffer} <b>must</b> be identical to the buffer associated with the imported memory</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV</li>
            <li>If {@code image} is not #NULL_HANDLE, {@code image} <b>must</b> be a valid {@code VkImage} handle</li>
            <li>If {@code buffer} is not #NULL_HANDLE, {@code buffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>Both of {@code buffer}, and {@code image} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImage("image", "#NULL_HANDLE or a handle of an image which this memory will be bound to.")
    VkBuffer("buffer", "#NULL_HANDLE or a handle of a buffer which this memory will be bound to.")
}

val VkPhysicalDeviceTransformFeedbackFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceTransformFeedbackFeaturesEXT") {
    documentation =
        """
        Structure describing transform feedback features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceTransformFeedbackFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("transformFeedback", "indicates whether the implementation supports transform feedback and shader modules <b>can</b> declare the {@code TransformFeedback} capability.")
    VkBool32("geometryStreams", "indicates whether the implementation supports the {@code GeometryStreams} SPIR-V capability.")
}

val VkPhysicalDeviceTransformFeedbackPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceTransformFeedbackPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing transform feedback properties that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceTransformFeedbackPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxTransformFeedbackStreams", "the maximum number of vertex streams that can be output from geometry shaders declared with the {@code GeometryStreams} capability. If the implementation does not support ##VkPhysicalDeviceTransformFeedbackFeaturesEXT{@code ::geometryStreams} then {@code maxTransformFeedbackStreams} <b>must</b> be set to 1.")
    uint32_t("maxTransformFeedbackBuffers", "the maximum number of transform feedback buffers that can be bound for capturing shader outputs from the last <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#pipelines-graphics-subsets-pre-rasterization\">pre-rasterization shader stage</a>.")
    VkDeviceSize("maxTransformFeedbackBufferSize", "the maximum size that can be specified when binding a buffer for transform feedback in #CmdBindTransformFeedbackBuffersEXT().")
    uint32_t("maxTransformFeedbackStreamDataSize", "the maximum amount of data in bytes for each vertex that captured to one or more transform feedback buffers associated with a specific vertex stream.")
    uint32_t("maxTransformFeedbackBufferDataSize", "the maximum amount of data in bytes for each vertex that can be captured to a specific transform feedback buffer.")
    uint32_t("maxTransformFeedbackBufferDataStride", "the maximum stride between each capture of vertex data to the buffer.")
    VkBool32("transformFeedbackQueries", "#TRUE if the implementation supports the #QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT query type. {@code transformFeedbackQueries} is #FALSE if queries of this type <b>cannot</b> be created.")
    VkBool32("transformFeedbackStreamsLinesTriangles", "#TRUE if the implementation supports the geometry shader {@code OpExecutionMode} of {@code OutputLineStrip} and {@code OutputTriangleStrip} in addition to {@code OutputPoints} when more than one vertex stream is output. If {@code transformFeedbackStreamsLinesTriangles} is #FALSE the implementation only supports an {@code OpExecutionMode} of {@code OutputPoints} when more than one vertex stream is output from the geometry shader.")
    VkBool32("transformFeedbackRasterizationStreamSelect", "#TRUE if the implementation supports the {@code GeometryStreams} SPIR-V capability and the application can use ##VkPipelineRasterizationStateStreamCreateInfoEXT to modify which vertex stream output is used for rasterization. Otherwise vertex stream 0 <b>must</b> always be used for rasterization.")
    VkBool32("transformFeedbackDraw", "#TRUE if the implementation supports the #CmdDrawIndirectByteCountEXT() function otherwise the function <b>must</b> not be called.")
}

val VkPipelineRasterizationStateStreamCreateInfoEXT = struct(Module.VULKAN, "VkPipelineRasterizationStateStreamCreateInfoEXT") {
    documentation =
        """
        Structure defining the geometry stream used for rasterization.

        <h5>Description</h5>
        If this structure is not present, {@code rasterizationStream} is assumed to be zero.

        <h5>Valid Usage</h5>
        <ul>
            <li>##VkPhysicalDeviceTransformFeedbackFeaturesEXT{@code ::geometryStreams} <b>must</b> be enabled</li>
            <li>{@code rasterizationStream} <b>must</b> be less than ##VkPhysicalDeviceTransformFeedbackPropertiesEXT{@code ::maxTransformFeedbackStreams}</li>
            <li>{@code rasterizationStream} <b>must</b> be zero if ##VkPhysicalDeviceTransformFeedbackPropertiesEXT{@code ::transformFeedbackRasterizationStreamSelect} is #FALSE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineRasterizationStateStreamCreateFlagsEXT("flags", "reserved for future use.")
    uint32_t("rasterizationStream", "the vertex stream selected for rasterization.")
}

val VkCuModuleCreateInfoNVX = struct(Module.VULKAN, "VkCuModuleCreateInfoNVX") {
    documentation =
        """
        Stub description of VkCuModuleCreateInfoNVX.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pData} <b>must</b> be a valid pointer to an array of {@code dataSize} bytes</li>
            <li>{@code dataSize} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateCuModuleNVX()
        """

    Expression("#STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pData")..size_t("dataSize", "")
    void.const.p("pData", "")
}

val VkCuFunctionCreateInfoNVX = struct(Module.VULKAN, "VkCuFunctionCreateInfoNVX") {
    documentation =
        """
        Stub description of VkCuFunctionCreateInfoNVX.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code module} <b>must</b> be a valid {@code VkCuModuleNVX} handle</li>
            <li>{@code pName} <b>must</b> be a null-terminated UTF-8 string</li>
        </ul>

        <h5>See Also</h5>
        #CreateCuFunctionNVX()
        """

    Expression("#STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkCuModuleNVX("module", "")
    charUTF8.const.p("pName", "")
}

val VkCuLaunchInfoNVX = struct(Module.VULKAN, "VkCuLaunchInfoNVX") {
    documentation =
        """
        Stub description of VkCuLaunchInfoNVX.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code function} <b>must</b> be a valid {@code VkCuFunctionNVX} handle</li>
            <li>If {@code paramCount} is not 0, {@code pParams} <b>must</b> be a valid pointer to an array of {@code paramCount} bytes</li>
            <li>If {@code extraCount} is not 0, {@code pExtras} <b>must</b> be a valid pointer to an array of {@code extraCount} bytes</li>
        </ul>

        <h5>See Also</h5>
        #CmdCuLaunchKernelNVX()
        """

    Expression("#STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkCuFunctionNVX("function", "")
    uint32_t("gridDimX", "")
    uint32_t("gridDimY", "")
    uint32_t("gridDimZ", "")
    uint32_t("blockDimX", "")
    uint32_t("blockDimY", "")
    uint32_t("blockDimZ", "")
    uint32_t("sharedMemBytes", "")
    AutoSize("pParams", optional = true)..size_t("paramCount", "")
    void.const.p.const.p("pParams", "")
    AutoSize("pExtras", optional = true)..size_t("extraCount", "")
    void.const.p.const.p("pExtras", "")
}

val VkImageViewHandleInfoNVX = struct(Module.VULKAN, "VkImageViewHandleInfoNVX") {
    documentation =
        """
        Structure specifying the image view for handle queries.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code descriptorType} <b>must</b> be #DESCRIPTOR_TYPE_SAMPLED_IMAGE, #DESCRIPTOR_TYPE_STORAGE_IMAGE, or #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</li>
            <li>{@code sampler} <b>must</b> be a valid {@code VkSampler} if {@code descriptorType} is #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER</li>
            <li>If descriptorType is #DESCRIPTOR_TYPE_SAMPLED_IMAGE or #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the image that {@code imageView} was created from <b>must</b> have been created with the #IMAGE_USAGE_SAMPLED_BIT usage bit set</li>
            <li>If descriptorType is #DESCRIPTOR_TYPE_STORAGE_IMAGE, the image that {@code imageView} was created from <b>must</b> have been created with the #IMAGE_USAGE_STORAGE_BIT usage bit set</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code imageView} <b>must</b> be a valid {@code VkImageView} handle</li>
            <li>{@code descriptorType} <b>must</b> be a valid {@code VkDescriptorType} value</li>
            <li>If {@code sampler} is not #NULL_HANDLE, {@code sampler} <b>must</b> be a valid {@code VkSampler} handle</li>
            <li>Both of {@code imageView}, and {@code sampler} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #GetImageViewHandleNVX()
        """

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageView("imageView", "the image view to query.")
    VkDescriptorType("descriptorType", "the type of descriptor for which to query a handle.")
    VkSampler("sampler", "the sampler to combine with the image view when generating the handle.")
}

val VkImageViewAddressPropertiesNVX = struct(Module.VULKAN, "VkImageViewAddressPropertiesNVX", mutable = false) {
    documentation =
        """
        Structure specifying the image view for handle queries.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetImageViewAddressNVX()
        """

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDeviceAddress("deviceAddress", "the device address of the image view.")
    VkDeviceSize("size", "the size in bytes of the image view device memory.")
}

val VkVideoEncodeH264CapabilitiesEXT = struct(Module.VULKAN, "VkVideoEncodeH264CapabilitiesEXT", mutable = false) {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifying H.264 encode capabilities.

        <h5>Description</h5>
        When #GetPhysicalDeviceVideoCapabilitiesKHR() is called to query the capabilities with parameter {@code videoCodecOperation} specified as #VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT, a ##VkVideoEncodeH264CapabilitiesEXT structure <b>can</b> be chained to ##VkVideoCapabilitiesKHR to retrieve H.264 extension specific capabilities.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoEncodeH264CapabilityFlagsEXT("flags", "a bitmask of {@code VkVideoEncodeH264CapabilityFlagBitsEXT} indicating supported H.264 encoding capabilities.")
    StdVideoH264LevelIdc("maxLevelIdc", "a {@code StdVideoH264LevelIdc} value indicating the maximum H.264 level supported.")
    uint32_t("maxSliceCount", "indicates the maximum number of slices that <b>can</b> be encoded for a single picture. Further restrictions <b>may</b> apply to the number of slices that <b>can</b> be encoded for a single picture depending on other capabilities and codec-specific rules.")
    uint32_t("maxPPictureL0ReferenceCount", "indicates the maximum number of reference pictures the implementation supports in the reference list L0 for P pictures.")
    uint32_t("maxBPictureL0ReferenceCount", "indicates the maximum number of reference pictures the implementation supports in the reference list L0 for B pictures. The reported value is 0 if encoding of B pictures is not supported.")
    uint32_t("maxL1ReferenceCount", "reports the maximum number of reference pictures the implementation supports in the reference list L1 if encoding of B pictures is supported. The reported value is 0 if encoding of B pictures is not supported.")
    uint32_t("maxTemporalLayerCount", "indicates the maximum number of H.264 temporal layers supported by the implementation.")
    VkBool32("expectDyadicTemporalLayerPattern", "indicates that the implementation’s rate control algorithms expect the application to use a dyadic temporal layer pattern when encoding multiple temporal layers.")
    int32_t("minQp", "indicates the minimum QP value supported.")
    int32_t("maxQp", "indicates the maximum QP value supported.")
    VkBool32("prefersGopRemainingFrames", "indicates that the implementation’s rate control algorithm prefers the application to specify the number of frames of each type remaining in the current group of pictures.")
    VkBool32("requiresGopRemainingFrames", "indicates that the implementation’s rate control algorithm requires the application to specify the number of frames of each type remaining in the current group of pictures.")
    VkVideoEncodeH264StdFlagsEXT("stdSyntaxFlags", "a bitmask of {@code VkVideoEncodeH264StdFlagBitsEXT} indicating capabilities related to H.264 syntax elements.")
}

val VkVideoEncodeH264QpEXT = struct(Module.VULKAN, "VkVideoEncodeH264QpEXT") {
    documentation =
        """
        Structure describing H.264 QP values per picture type.

        <h5>See Also</h5>
        ##VkVideoEncodeH264QualityLevelPropertiesEXT, ##VkVideoEncodeH264RateControlLayerInfoEXT
        """

    int32_t("qpI", "the QP to be used for I-frames.")
    int32_t("qpP", "the QP to be used for P-frames.")
    int32_t("qpB", "the QP to be used for B-frames.")
}

val VkVideoEncodeH264QualityLevelPropertiesEXT = struct(Module.VULKAN, "VkVideoEncodeH264QualityLevelPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing the H.264 encode quality level properties.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH264QpEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoEncodeH264RateControlFlagsEXT("preferredRateControlFlags", "a bitmask of {@code VkVideoEncodeH264RateControlFlagBitsEXT} values indicating the preferred flags to use for ##VkVideoEncodeH264RateControlInfoEXT{@code ::flags}.")
    uint32_t("preferredGopFrameCount", "indicates the preferred value to use for ##VkVideoEncodeH264RateControlInfoEXT{@code ::gopFrameCount}.")
    uint32_t("preferredIdrPeriod", "indicates the preferred value to use for ##VkVideoEncodeH264RateControlInfoEXT{@code ::idrPeriod}.")
    uint32_t("preferredConsecutiveBFrameCount", "indicates the preferred value to use for ##VkVideoEncodeH264RateControlInfoEXT{@code ::consecutiveBFrameCount}.")
    uint32_t("preferredTemporalLayerCount", "indicates the preferred value to use for ##VkVideoEncodeH264RateControlInfoEXT{@code ::temporalLayerCount}.")
    VkVideoEncodeH264QpEXT("preferredConstantQp", "indicates the preferred values to use for ##VkVideoEncodeH264NaluSliceInfoEXT{@code ::constantQp} for each picture type when using rate control mode #VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR.")
    uint32_t("preferredMaxL0ReferenceCount", "indicates the preferred maximum number of reference pictures to use in the reference list L0.")
    uint32_t("preferredMaxL1ReferenceCount", "indicates the preferred maximum number of reference pictures to use in the reference list L1.")
    VkBool32("preferredStdEntropyCodingModeFlag", "indicates the preferred value to use for {@code entropy_coding_mode_flag} in {@code StdVideoH264PpsFlags}.")
}

val VkVideoEncodeH264SessionCreateInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264SessionCreateInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 encode session parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("useMaxLevelIdc", "indicates whether the value of {@code maxLevelIdc} should be used by the implementation. When it is set to #FALSE, the implementation ignores the value of {@code maxLevelIdc} and uses the value of ##VkVideoEncodeH264CapabilitiesEXT{@code ::maxLevelIdc}, as reported by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile.")
    StdVideoH264LevelIdc("maxLevelIdc", "provides the upper bound on the H.264 level for the video bitstreams produced by the created video session.")
}

val VkVideoEncodeH264SessionParametersAddInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264SessionParametersAddInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 encoder parameter set information.

        <h5>Valid Usage</h5>
        <ul>
            <li>The values of {@code stdSPSCount} and {@code stdPPSCount} <b>must</b> be less than or equal to the values of {@code maxStdSPSCount} and {@code maxStdPPSCount}, respectively</li>
            <li>When the {@code maxStdSPSCount} number of parameters of type StdVideoH264SequenceParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to the object. #ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point</li>
            <li>When the {@code maxStdPPSCount} number of parameters of type StdVideoH264PictureParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to the object. #ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point</li>
            <li>Each entry to be added <b>must</b> have a unique, to the rest of the parameter array entries and the existing parameters in the Video Session Parameters Object that is being updated, SPS-PPS IDs</li>
            <li>Parameter entries that already exist in Video Session Parameters object with a particular SPS-PPS IDs <b>cannot</b> be replaced nor updated</li>
            <li>When creating a new object using a Video Session Parameters as a template, the array’s parameters with the same SPS-PPS IDs as the ones from the template take precedence</li>
            <li>SPS/PPS parameters <b>must</b> comply with the limits specified in ##VkVideoSessionCreateInfoKHR during Video Session creation</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT</li>
            <li>If {@code stdSPSCount} is not 0, and {@code pStdSPSs} is not {@code NULL}, {@code pStdSPSs} <b>must</b> be a valid pointer to an array of {@code stdSPSCount} {@code StdVideoH264SequenceParameterSet} values</li>
            <li>If {@code stdPPSCount} is not 0, and {@code pStdPPSs} is not {@code NULL}, {@code pStdPPSs} <b>must</b> be a valid pointer to an array of {@code stdPPSCount} {@code StdVideoH264PictureParameterSet} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH264SessionParametersCreateInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pStdSPSs", optional = true)..uint32_t("stdSPSCount", "the number of SPS elements in the {@code pStdSPSs}. Its value <b>must</b> be less than or equal to the value of {@code maxStdSPSCount}.")
    nullable..StdVideoH264SequenceParameterSet.const.p("pStdSPSs", "a pointer to an array of {@code StdVideoH264SequenceParameterSet} structures representing H.264 sequence parameter sets. Each element of the array <b>must</b> have a unique H.264 SPS ID.")
    AutoSize("pStdPPSs", optional = true)..uint32_t("stdPPSCount", "the number of PPS provided in {@code pStdPPSs}. Its value <b>must</b> be less than or equal to the value of {@code maxStdPPSCount}.")
    nullable..StdVideoH264PictureParameterSet.const.p("pStdPPSs", "a pointer to an array of {@code StdVideoH264PictureParameterSet} structures representing H.264 picture parameter sets. Each element of the array <b>must</b> have a unique H.264 SPS-PPS ID pair.")
}

val VkVideoEncodeH264SessionParametersCreateInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264SessionParametersCreateInfoEXT") {
    documentation =
        """
        Structure specifies H.264 encoder parameter set information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT</li>
            <li>If {@code pParametersAddInfo} is not {@code NULL}, {@code pParametersAddInfo} <b>must</b> be a valid pointer to a valid ##VkVideoEncodeH264SessionParametersAddInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH264SessionParametersAddInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("maxStdSPSCount", "the maximum number of SPS parameters that the {@code VkVideoSessionParametersKHR} can contain.")
    uint32_t("maxStdPPSCount", "the maximum number of PPS parameters that the {@code VkVideoSessionParametersKHR} can contain.")
    nullable..VkVideoEncodeH264SessionParametersAddInfoEXT.const.p("pParametersAddInfo", "{@code NULL} or a pointer to a ##VkVideoEncodeH264SessionParametersAddInfoEXT structure specifying H.264 parameters to add upon object creation.")
}

val VkVideoEncodeH264SessionParametersGetInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264SessionParametersGetInfoEXT") {
    documentation =
        """
        Structure specifying parameters for retrieving encoded H.264 parameter set data.

        <h5>Description</h5>
        When this structure is specified in the {@code pNext} chain of the ##VkVideoEncodeSessionParametersGetInfoKHR structure passed to #GetEncodedVideoSessionParametersKHR(), the command will write encoded parameter data to the output buffer in the following order:

        <ul>
            <li>The H.264 sequence parameter set identified by {@code stdSPSId}, if {@code writeStdSPS} is set to #TRUE.</li>
            <li>The H.264 picture parameter set identified by the pair constructed from {@code stdSPSId} and {@code stdPPSId}, if {@code writeStdPPS} is set to #TRUE.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("writeStdSPS", "indicates whether the encoded H.264 sequence parameter set identified by {@code stdSPSId} is requested to be retrieved.")
    VkBool32("writeStdPPS", "indicates whether the encoded H.264 picture parameter set identified by the pair constructed from {@code stdSPSId} and {@code stdPPSId} is requested to be retrieved.")
    uint32_t("stdSPSId", "specifies the H.264 sequence parameter set ID used to identify the retrieved H.264 sequence and/or picture parameter set(s).")
    uint32_t("stdPPSId", "specifies the H.264 picture parameter set ID used to identify the retrieved H.264 picture parameter set when {@code writeStdPPS} is set to #TRUE.")
}

val VkVideoEncodeH264SessionParametersFeedbackInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264SessionParametersFeedbackInfoEXT", mutable = false) {
    documentation =
        """
        Structure providing feedback about the requested H.264 video session parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("hasStdSPSOverrides", "indicates whether any of the parameters of the requested H.264 sequence parameter set, if one was requested via ##VkVideoEncodeH264SessionParametersGetInfoEXT{@code ::writeStdSPS}, were overridden by the implementation.")
    VkBool32("hasStdPPSOverrides", "indicates whether any of the parameters of the requested H.264 picture parameter set, if one was requested via ##VkVideoEncodeH264SessionParametersGetInfoEXT{@code ::writeStdPPS}, were overridden by the implementation.")
}

val VkVideoEncodeH264NaluSliceInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264NaluSliceInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 encode slice NALU parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pStdSliceHeader} <b>must</b> be a valid pointer to a valid {@code StdVideoEncodeH264SliceHeader} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH264PictureInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    int32_t("constantQp", "the QP to use for the slice if the current rate control mode configured for the video session is #VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR.")
    StdVideoEncodeH264SliceHeader.const.p("pStdSliceHeader", "a pointer to a {@code StdVideoEncodeH264SliceHeader} structure specifying the slice header for the current slice.")
}

val VkVideoEncodeH264PictureInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264PictureInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 encode frame parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT</li>
            <li>{@code pNaluSliceEntries} <b>must</b> be a valid pointer to an array of {@code naluSliceEntryCount} valid ##VkVideoEncodeH264NaluSliceInfoEXT structures</li>
            <li>{@code pStdPictureInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoEncodeH264PictureInfo} value</li>
            <li>{@code naluSliceEntryCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH264NaluSliceInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pNaluSliceEntries")..uint32_t("naluSliceEntryCount", "the number of slice NALUs in the frame.")
    VkVideoEncodeH264NaluSliceInfoEXT.const.p("pNaluSliceEntries", "a pointer to an array of {@code naluSliceEntryCount} ##VkVideoEncodeH264NaluSliceInfoEXT structures specifying the division of the current picture into slices and the properties of these slices. This is an ordered sequence; the NALUs are generated consecutively in ##VkVideoEncodeInfoKHR{@code ::dstBuffer} in the same order as in this array.")
    StdVideoEncodeH264PictureInfo.const.p("pStdPictureInfo", "a pointer to a {@code StdVideoEncodeH264PictureInfo} structure specifying the syntax and other codec-specific information from the H.264 specification associated with this picture. The information provided <b>must</b> reflect the decoded picture marking operations that are applicable to this frame.")
    VkBool32("generatePrefixNalu", "controls whether prefix NALUs are generated before slice NALUs into the target bitstream.")
}

val VkVideoEncodeH264DpbSlotInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264DpbSlotInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 encode DPB picture information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT</li>
            <li>{@code pStdReferenceInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoEncodeH264ReferenceInfo} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoEncodeH264ReferenceInfo.const.p("pStdReferenceInfo", "a pointer to a {@code StdVideoEncodeH264ReferenceInfo} structure specifying the syntax and other codec-specific information from the H.264 specification associated with this reference picture.")
}

val VkVideoEncodeH264ProfileInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264ProfileInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifying H.264 encode profile.

        <h5>Description</h5>
        An H.264 encode profile is specified by including a ##VkVideoEncodeH264ProfileInfoEXT structure in the {@code pNext} chain of the ##VkVideoProfileInfoKHR structure when ##VkVideoProfileInfoKHR{@code ::videoCodecOperation} is #VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoH264ProfileIdc("stdProfileIdc", "a {@code StdVideoH264ProfileIdc} value specifying the H.264 codec profile IDC.")
}

val VkVideoEncodeH264RateControlInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264RateControlInfoEXT") {
    documentation =
        """
        Structure describing H.264 stream rate control parameters.

        <h5>Description</h5>
        In order to provide H.264-specific stream rate control parameters, add a ##VkVideoEncodeH264RateControlInfoEXT structure to the {@code pNext} chain of the ##VkVideoEncodeRateControlInfoKHR structure in the {@code pNext} chain of the ##VkVideoCodingControlInfoKHR structure passed to the #CmdControlVideoCodingKHR() command.

        The parameters from this structure act as a guidance for implementations to apply various rate control heuristics.

        It is possible to infer the picture type to be used when encoding a frame, on the basis of the values provided for {@code consecutiveBFrameCount}, {@code idrPeriod}, and {@code gopFrameCount}, but this inferred picture type will not be used by implementations to override the picture type provided in #CmdEncodeVideoKHR(). Additionally, it is not required for the video session to be reset if the inferred picture type does not match the actual picture type.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkVideoEncodeH264RateControlFlagBitsEXT} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoEncodeH264RateControlFlagsEXT("flags", "a bitmask of {@code VkVideoEncodeH264RateControlFlagBitsEXT} specifying H.264 rate control flags.")
    uint32_t("gopFrameCount", "the number of frames contained within the group of pictures (GOP), starting from an intra frame and until the next intra frame. If it is set to 0, the implementation chooses a suitable value. If it is set to {@code UINT32_MAX}, the GOP length is treated as infinite.")
    uint32_t("idrPeriod", "the interval, in terms of number of frames, between two IDR frames. If it is set to 0, the implementation chooses a suitable value. If it is set to {@code UINT32_MAX}, the IDR period is treated as infinite.")
    uint32_t("consecutiveBFrameCount", "the number of consecutive B-frames between I- and/or P-frames within the GOP.")
    uint32_t("temporalLayerCount", "specifies the number of temporal layers enabled in the stream.")
}

val VkVideoEncodeH264FrameSizeEXT = struct(Module.VULKAN, "VkVideoEncodeH264FrameSizeEXT") {
    documentation =
        """
        Structure describing frame size values per H.264 picture type.

        <h5>See Also</h5>
        ##VkVideoEncodeH264RateControlLayerInfoEXT
        """

    uint32_t("frameISize", "the size in bytes to be used for I-frames.")
    uint32_t("framePSize", "the size in bytes to be used for P-frames.")
    uint32_t("frameBSize", "the size in bytes to be used for B-frames.")
}

val VkVideoEncodeH264RateControlLayerInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264RateControlLayerInfoEXT") {
    documentation =
        """
        Structure describing H.264 per-layer rate control parameters.

        <h5>Description</h5>
        H.264-specific per-layer rate control parameters <b>must</b> be specified by adding a ##VkVideoEncodeH264RateControlLayerInfoEXT structure to the {@code pNext} chain of each ##VkVideoEncodeRateControlLayerInfoKHR structure in a call to #CmdControlVideoCodingKHR() command, when the command buffer context has an active video encode H.264 session.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT</li>
            <li>{@code minQp} <b>must</b> be a valid ##VkVideoEncodeH264QpEXT structure</li>
            <li>{@code maxQp} <b>must</b> be a valid ##VkVideoEncodeH264QpEXT structure</li>
            <li>{@code maxFrameSize} <b>must</b> be a valid ##VkVideoEncodeH264FrameSizeEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH264FrameSizeEXT, ##VkVideoEncodeH264QpEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("useMinQp", "indicates whether the values within {@code minQp} should be used by the implementation. When it is set to #FALSE, the implementation ignores the values in {@code minQp} and chooses suitable values.")
    VkVideoEncodeH264QpEXT("minQp", "provides the lower bound on the QP values for each picture type, to be used in rate control calculations.")
    VkBool32("useMaxQp", "indicates whether the values within {@code maxQp} should be used by the implementation. When it is set to #FALSE, the implementation ignores the values in {@code maxQp} and chooses suitable values.")
    VkVideoEncodeH264QpEXT("maxQp", "provides the upper bound on the QP values for each picture type, to be used in rate control calculations.")
    VkBool32("useMaxFrameSize", "indicates whether the values within {@code maxFrameSize} should be used by the implementation.")
    VkVideoEncodeH264FrameSizeEXT("maxFrameSize", "provides the upper bound on the encoded frame size for each picture type. The implementation does not guarantee the encoded frame sizes will be within the specified limits, however these limits <b>may</b> be used as a guide in rate control calculations. If enabled and not set properly, the {@code maxQp} limit may prevent the implementation from respecting the {@code maxFrameSize} limit.")
}

val VkVideoEncodeH264GopRemainingFrameInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH264GopRemainingFrameInfoEXT") {
    documentation =
        """
        Structure specifying H.264 encode rate control GOP remaining frame counts.

        <h5>Description</h5>
        Setting {@code useGopRemainingFrames} to #TRUE and including this structure in the {@code pNext} chain of ##VkVideoEncodeInfoKHR is only mandatory if the ##VkVideoEncodeH264CapabilitiesEXT{@code ::requiresGopRemainingFrames} reported for the used <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-profiles">video profile</a> is #TRUE. However, implementations <b>may</b> use these remaining frame counts, when specified, even when it is not required. In particular, when the application does not use a regular GOP structure, these values <b>may</b> provide additional guidance for the implementation’s rate control algorithm.

        The ##VkVideoEncodeH264CapabilitiesEXT{@code ::prefersGopRemainingFrames} capability is also used to indicate that the implementation’s rate control algorithm <b>may</b> operate more accurately if the application specifies the remaining frame counts using this structure.

        As with other rate control guidance values, if the effective order and number of frames encoded by the application are not in line with the remaining frame counts specified in this structure at any given point, then the behavior of the implementation’s rate control algorithm <b>may</b> deviate from the one expected by the application.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("useGopRemainingFrames", "indicates whether the implementation’s rate control algorithm <b>should</b> use the values specified in {@code gopRemainingI}, {@code gopRemainingP}, and {@code gopRemainingB}. If {@code useGopRemainingFrames} is #FALSE, then the values of {@code gopRemainingI}, {@code gopRemainingP}, and {@code gopRemainingB} are ignored.")
    uint32_t("gopRemainingI", "specifies the number of I-frames the implementation’s rate control algorithm <b>should</b> assume to be remaining in the GOP prior to executing the video encode operation.")
    uint32_t("gopRemainingP", "specifies the number of P-frames the implementation’s rate control algorithm <b>should</b> assume to be remaining in the GOP prior to executing the video encode operation.")
    uint32_t("gopRemainingB", "specifies the number of B-frames the implementation’s rate control algorithm <b>should</b> assume to be remaining in the GOP prior to executing the video encode operation.")
}

val VkVideoEncodeH265CapabilitiesEXT = struct(Module.VULKAN, "VkVideoEncodeH265CapabilitiesEXT", mutable = false) {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifying H.265 encode capabilities.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoEncodeH265CapabilityFlagsEXT("flags", "a bitmask of {@code VkVideoEncodeH265CapabilityFlagBitsEXT} indicating supported H.265 encoding capabilities.")
    StdVideoH265LevelIdc("maxLevelIdc", "a {@code StdVideoH265LevelIdc} value indicating the maximum H.265 level supported.")
    uint32_t("maxSliceSegmentCount", "indicates the maximum number of slice segments that <b>can</b> be encoded for a single picture. Further restrictions <b>may</b> apply to the number of slice segments that <b>can</b> be encoded for a single picture depending on other capabilities and codec-specific rules.")
    VkExtent2D("maxTiles", "indicates the maximum number of H.265 tile columns and rows that <b>can</b> be encoded for a single picture. Further restrictions <b>may</b> apply to the number of H.265 tiles that <b>can</b> be encoded for a single picture depending on other capabilities and codec-specific rules.")
    VkVideoEncodeH265CtbSizeFlagsEXT("ctbSizes", "a bitmask of {@code VkVideoEncodeH265CtbSizeFlagBitsEXT} describing the supported CTB sizes.")
    VkVideoEncodeH265TransformBlockSizeFlagsEXT("transformBlockSizes", "a bitmask of {@code VkVideoEncodeH265TransformBlockSizeFlagBitsEXT} describing the supported transform block sizes.")
    uint32_t("maxPPictureL0ReferenceCount", "indicates the maximum number of reference pictures the implementation supports in the reference list L0 for P pictures.")
    uint32_t("maxBPictureL0ReferenceCount", "indicates the maximum number of reference pictures the implementation supports in the reference list L0 for B pictures. The reported value is 0 if encoding of B pictures is not supported.")
    uint32_t("maxL1ReferenceCount", "indicates the maximum number of reference pictures the implementation supports in the reference list L1 if encoding of B pictures is supported. The reported value is 0 if encoding of B pictures is not supported.")
    uint32_t("maxSubLayerCount", "indicates the maximum number of H.265 sub-layers supported by the implementation.")
    VkBool32("expectDyadicTemporalSubLayerPattern", "indicates that the implementation’s rate control algorithms expect the application to use a dyadic temporal sub-layer pattern when encoding multiple temporal sub-layers.")
    int32_t("minQp", "indicates the minimum QP value supported.")
    int32_t("maxQp", "indicates the maximum QP value supported.")
    VkBool32("prefersGopRemainingFrames", "indicates that the implementation’s rate control algorithm prefers the application to specify the number of frames of each type remaining in the current group of pictures.")
    VkBool32("requiresGopRemainingFrames", "indicates that the implementation’s rate control algorithm requires the application to specify the number of frames of each type remaining in the current group of pictures.")
    VkVideoEncodeH265StdFlagsEXT("stdSyntaxFlags", "a bitmask of {@code VkVideoEncodeH265StdFlagBitsEXT} indicating capabilities related to H.265 syntax elements.")
}

val VkVideoEncodeH265SessionCreateInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265SessionCreateInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 encode session parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("useMaxLevelIdc", "indicates whether the value of {@code maxLevelIdc} should be used by the implementation. When it is set to #FALSE, the implementation ignores the value of {@code maxLevelIdc} and uses the value of ##VkVideoEncodeH265CapabilitiesEXT{@code ::maxLevelIdc}, as reported by #GetPhysicalDeviceVideoCapabilitiesKHR() for the video profile.")
    StdVideoH265LevelIdc("maxLevelIdc", "provides the upper bound on the H.265 level for the video bitstreams produced by the created video session.")
}

val VkVideoEncodeH265QpEXT = struct(Module.VULKAN, "VkVideoEncodeH265QpEXT") {
    documentation =
        """
        Structure describing H.265 QP values per picture type.

        <h5>See Also</h5>
        ##VkVideoEncodeH265QualityLevelPropertiesEXT, ##VkVideoEncodeH265RateControlLayerInfoEXT
        """

    int32_t("qpI", "the QP to be used for I-frames.")
    int32_t("qpP", "the QP to be used for P-frames.")
    int32_t("qpB", "the QP to be used for B-frames.")
}

val VkVideoEncodeH265QualityLevelPropertiesEXT = struct(Module.VULKAN, "VkVideoEncodeH265QualityLevelPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing the H.265 encode quality level properties.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH265QpEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoEncodeH265RateControlFlagsEXT("preferredRateControlFlags", "a bitmask of {@code VkVideoEncodeH265RateControlFlagBitsEXT} values indicating the preferred flags to use for ##VkVideoEncodeH265RateControlInfoEXT{@code ::flags}.")
    uint32_t("preferredGopFrameCount", "indicates the preferred value to use for ##VkVideoEncodeH265RateControlInfoEXT{@code ::gopFrameCount}.")
    uint32_t("preferredIdrPeriod", "indicates the preferred value to use for ##VkVideoEncodeH265RateControlInfoEXT{@code ::idrPeriod}.")
    uint32_t("preferredConsecutiveBFrameCount", "indicates the preferred value to use for ##VkVideoEncodeH265RateControlInfoEXT{@code ::consecutiveBFrameCount}.")
    uint32_t("preferredSubLayerCount", "indicates the preferred value to use for ##VkVideoEncodeH265RateControlInfoEXT{@code ::subLayerCount}.")
    VkVideoEncodeH265QpEXT("preferredConstantQp", "indicates the preferred values to use for ##VkVideoEncodeH265NaluSliceSegmentInfoEXT{@code ::constantQp} for each picture type when using rate control mode #VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR.")
    uint32_t("preferredMaxL0ReferenceCount", "indicates the preferred maximum number of reference pictures to use in the reference list L0.")
    uint32_t("preferredMaxL1ReferenceCount", "indicates the preferred maximum number of reference pictures to use in the reference list L1.")
}

val VkVideoEncodeH265SessionParametersAddInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265SessionParametersAddInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 encoder parameter set info.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT</li>
            <li>If {@code stdVPSCount} is not 0, and {@code pStdVPSs} is not {@code NULL}, {@code pStdVPSs} <b>must</b> be a valid pointer to an array of {@code stdVPSCount} {@code StdVideoH265VideoParameterSet} values</li>
            <li>If {@code stdSPSCount} is not 0, and {@code pStdSPSs} is not {@code NULL}, {@code pStdSPSs} <b>must</b> be a valid pointer to an array of {@code stdSPSCount} {@code StdVideoH265SequenceParameterSet} values</li>
            <li>If {@code stdPPSCount} is not 0, and {@code pStdPPSs} is not {@code NULL}, {@code pStdPPSs} <b>must</b> be a valid pointer to an array of {@code stdPPSCount} {@code StdVideoH265PictureParameterSet} values</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>The values of {@code stdVPSCount}, {@code stdSPSCount} and {@code stdPPSCount} <b>must</b> be less than or equal to the values of ##VkVideoEncodeH265SessionParametersCreateInfoEXT{@code ::maxStdVPSCount}, ##VkVideoEncodeH265SessionParametersCreateInfoEXT:{@code maxStdSPSCount}, and ##VkVideoEncodeH265SessionParametersCreateInfoEXT:{@code maxStdPPSCount}, respectively</li>
            <li>Each {@code StdVideoH265VideoParameterSet} entry in {@code pStdVPSs} <b>must</b> have a unique H.265 VPS ID</li>
            <li>Each {@code StdVideoH265SequenceParameterSet} entry in {@code pStdSPSs} <b>must</b> have a unique H.265 VPS-SPS ID pair</li>
            <li>Each {@code StdVideoH265PictureParameterSet} entry in {@code pStdPPSs} <b>must</b> have a unique H.265 VPS-SPS-PPS ID tuple</li>
            <li>Each entry to be added <b>must</b> have a unique, to the rest of the parameter array entries and the existing parameters in the Video Session Parameters Object that is being updated, VPS-SPS-PPS IDs</li>
            <li>Parameter entries that already exist in Video Session Parameters object with a particular VPS-SPS-PPS IDs <b>must</b> not be replaced nor updated</li>
            <li>When creating a new object using a Video Session Parameters as a template, the array’s parameters with the same VPS-SPS-PPS IDs as the ones from the template take precedence</li>
            <li>VPS/SPS/PPS parameters <b>must</b> comply with the limits specified in ##VkVideoSessionCreateInfoKHR during Video Session creation</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH265SessionParametersCreateInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pStdVPSs", optional = true)..uint32_t("stdVPSCount", "the number of VPS elements in {@code pStdVPSs}.")
    nullable..StdVideoH265VideoParameterSet.const.p("pStdVPSs", "a pointer to an array of {@code stdVPSCount} {@code StdVideoH265VideoParameterSet} structures representing H.265 video parameter sets.")
    AutoSize("pStdSPSs", optional = true)..uint32_t("stdSPSCount", "the number of SPS elements in {@code pStdSPSs}.")
    nullable..StdVideoH265SequenceParameterSet.const.p("pStdSPSs", "a pointer to an array of {@code stdSPSCount} {@code StdVideoH265SequenceParameterSet} structures representing H.265 sequence parameter sets.")
    AutoSize("pStdPPSs", optional = true)..uint32_t("stdPPSCount", "the number of PPS elements in {@code pStdPPSs}.")
    nullable..StdVideoH265PictureParameterSet.const.p("pStdPPSs", "a pointer to an array of {@code stdPPSCount} {@code StdVideoH265PictureParameterSet} structures representing H.265 picture parameter sets.")
}

val VkVideoEncodeH265SessionParametersCreateInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265SessionParametersCreateInfoEXT") {
    documentation =
        """
        Structure specifies H.265 encoder parameter set info.

        <h5>Description</h5>
        When a {@code VkVideoSessionParametersKHR} object contains {@code maxStdVPSCount} {@code StdVideoH265VideoParameterSet} entries, no additional {@code StdVideoH265VideoParameterSet} entries can be added to it, and #ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add these entries. When a {@code VkVideoSessionParametersKHR} object contains {@code maxStdSPSCount} {@code StdVideoH265SequenceParameterSet} entries, no additional {@code StdVideoH265SequenceParameterSet} entries can be added to it, and #ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add these entries. When a {@code VkVideoSessionParametersKHR} object contains {@code maxStdPPSCount} {@code StdVideoH265PictureParameterSet} entries, no additional {@code StdVideoH265PictureParameterSet} entries can be added to it, and #ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add these entries.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT</li>
            <li>If {@code pParametersAddInfo} is not {@code NULL}, {@code pParametersAddInfo} <b>must</b> be a valid pointer to a valid ##VkVideoEncodeH265SessionParametersAddInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH265SessionParametersAddInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("maxStdVPSCount", "the maximum number of entries of type {@code StdVideoH265VideoParameterSet} within {@code VkVideoSessionParametersKHR}.")
    uint32_t("maxStdSPSCount", "the maximum number of entries of type {@code StdVideoH265SequenceParameterSet} within {@code VkVideoSessionParametersKHR}.")
    uint32_t("maxStdPPSCount", "the maximum number of entries of type {@code StdVideoH265PictureParameterSet} within {@code VkVideoSessionParametersKHR}.")
    nullable..VkVideoEncodeH265SessionParametersAddInfoEXT.const.p("pParametersAddInfo", "{@code NULL} or a pointer to a ##VkVideoEncodeH265SessionParametersAddInfoEXT structure specifying the video session parameters to add upon creation of this object.")
}

val VkVideoEncodeH265SessionParametersGetInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265SessionParametersGetInfoEXT") {
    documentation =
        """
        Structure specifying parameters for retrieving encoded H.265 parameter set data.

        <h5>Description</h5>
        When this structure is specified in the {@code pNext} chain of the ##VkVideoEncodeSessionParametersGetInfoKHR structure passed to #GetEncodedVideoSessionParametersKHR(), the command will write encoded parameter data to the output buffer in the following order:

        <ul>
            <li>The H.265 video parameter set identified by {@code stdVPSId}, if {@code writeStdVPS} is set to #TRUE.</li>
            <li>The H.265 sequence parameter set identified by the pair constructed from {@code stdVPSId} and {@code stdSPSId}, if {@code writeStdSPS} is set to #TRUE.</li>
            <li>The H.265 picture parameter set identified by the triplet constructed from {@code stdVPSId}, {@code stdSPSId}, and {@code stdPPSId}, if {@code writeStdPPS} is set to #TRUE.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("writeStdVPS", "indicates whether the encoded H.265 video parameter set identified by {@code stdVPSId} is requested to be retrieved.")
    VkBool32("writeStdSPS", "indicates whether the encoded H.265 sequence parameter set identified by the pair constructed from {@code stdVPSId} and {@code stdSPSId} is requested to be retrieved.")
    VkBool32("writeStdPPS", "indicates whether the encoded H.265 picture parameter set identified by the triplet constructed from {@code stdVPSId}, {@code stdSPSId}, and {@code stdPPSId} is requested to be retrieved.")
    uint32_t("stdVPSId", "specifies the H.265 video parameter set ID used to identify the retrieved H.265 video, sequence, and/or picture parameter set(s).")
    uint32_t("stdSPSId", "specifies the H.265 sequence parameter set ID used to identify the retrieved H.265 sequence and/or picture parameter set(s) when {@code writeStdSPS} and/or {@code writeStdPPS} is set to #TRUE.")
    uint32_t("stdPPSId", "specifies the H.265 picture parameter set ID used to identify the retrieved H.265 picture parameter set when {@code writeStdPPS} is set to #TRUE.")
}

val VkVideoEncodeH265SessionParametersFeedbackInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265SessionParametersFeedbackInfoEXT", mutable = false) {
    documentation =
        """
        Structure providing feedback about the requested H.265 video session parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("hasStdVPSOverrides", "indicates whether any of the parameters of the requested H.265 video parameter set, if one was requested via ##VkVideoEncodeH265SessionParametersGetInfoEXT{@code ::writeStdVPS}, were overridden by the implementation.")
    VkBool32("hasStdSPSOverrides", "indicates whether any of the parameters of the requested H.265 sequence parameter set, if one was requested via ##VkVideoEncodeH265SessionParametersGetInfoEXT{@code ::writeStdSPS}, were overridden by the implementation.")
    VkBool32("hasStdPPSOverrides", "indicates whether any of the parameters of the requested H.265 picture parameter set, if one was requested via ##VkVideoEncodeH265SessionParametersGetInfoEXT{@code ::writeStdPPS}, were overridden by the implementation.")
}

val VkVideoEncodeH265NaluSliceSegmentInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265NaluSliceSegmentInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 encode slice segment NALU parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pStdSliceSegmentHeader} <b>must</b> be a valid pointer to a valid {@code StdVideoEncodeH265SliceSegmentHeader} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH265PictureInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    int32_t("constantQp", "the QP to use for the slice segment if the current rate control mode configured for the video session is #VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR.")
    StdVideoEncodeH265SliceSegmentHeader.const.p("pStdSliceSegmentHeader", "a pointer to a {@code StdVideoEncodeH265SliceSegmentHeader} structure specifying the slice segment header for the current slice segment.")
}

val VkVideoEncodeH265PictureInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265PictureInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 encode frame parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT</li>
            <li>{@code pNaluSliceSegmentEntries} <b>must</b> be a valid pointer to an array of {@code naluSliceSegmentEntryCount} valid ##VkVideoEncodeH265NaluSliceSegmentInfoEXT structures</li>
            <li>{@code pStdPictureInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoEncodeH265PictureInfo} value</li>
            <li>{@code naluSliceSegmentEntryCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH265NaluSliceSegmentInfoEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pNaluSliceSegmentEntries")..uint32_t("naluSliceSegmentEntryCount", "the number of slice segment NALUs in the frame.")
    VkVideoEncodeH265NaluSliceSegmentInfoEXT.const.p("pNaluSliceSegmentEntries", "a pointer to an array of ##VkVideoEncodeH265NaluSliceSegmentInfoEXT structures specifying the division of the current picture into slice segments and the properties of these slice segments.")
    StdVideoEncodeH265PictureInfo.const.p("pStdPictureInfo", "a pointer to a {@code StdVideoEncodeH265PictureInfo} structure specifying the syntax and other codec-specific information from the H.265 specification, associated with this picture.")
}

val VkVideoEncodeH265DpbSlotInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265DpbSlotInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 encode decoded pic info.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT</li>
            <li>{@code pStdReferenceInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoEncodeH265ReferenceInfo} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoEncodeH265ReferenceInfo.const.p("pStdReferenceInfo", "a pointer to a {@code StdVideoEncodeH265ReferenceInfo} structure specifying the syntax and other codec-specific information from the H.265 specification, associated with this reference picture.")
}

val VkVideoEncodeH265ProfileInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265ProfileInfoEXT") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifying H.265 encode profile.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoH265ProfileIdc("stdProfileIdc", "a {@code StdVideoH265ProfileIdc} value specifying the H.265 codec profile IDC.")
}

val VkVideoEncodeH265RateControlInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265RateControlInfoEXT") {
    documentation =
        """
        Structure describing H.265 stream rate control parameters.

        <h5>Description</h5>
        In order to provide H.265-specific stream rate control parameters, add a ##VkVideoEncodeH265RateControlInfoEXT structure to the {@code pNext} chain of the ##VkVideoEncodeRateControlInfoKHR structure in the {@code pNext} chain of the ##VkVideoCodingControlInfoKHR structure passed to the #CmdControlVideoCodingKHR() command.

        The parameters from this structure act as a guidance for implementations to apply various rate control heuristics.

        It is possible to infer the picture type to be used when encoding a frame, on the basis of the values provided for {@code consecutiveBFrameCount}, {@code idrPeriod}, and {@code gopFrameCount}, but this inferred picture type will not be used by implementations to override the picture type provided in #CmdEncodeVideoKHR(). Additionally, it is not required for the video session to be reset if the inferred picture type does not match the actual picture type.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkVideoEncodeH265RateControlFlagBitsEXT} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoEncodeH265RateControlFlagsEXT("flags", "a bitmask of {@code VkVideoEncodeH265RateControlFlagBitsEXT} specifying H.265 rate control flags.")
    uint32_t("gopFrameCount", "the number of frames contained within the group of pictures (GOP), starting from an intra frame and until the next intra frame. If it is set to 0, the implementation chooses a suitable value. If it is set to {@code UINT32_MAX}, the GOP length is treated as infinite.")
    uint32_t("idrPeriod", "the interval, in terms of number of frames, between two IDR frames. If it is set to 0, the implementation chooses a suitable value. If it is set to {@code UINT32_MAX}, the IDR period is treated as infinite.")
    uint32_t("consecutiveBFrameCount", "the number of consecutive B-frames between I- and/or P-frames within the GOP.")
    uint32_t("subLayerCount", "specifies the number of sub layers enabled in the stream.")
}

val VkVideoEncodeH265FrameSizeEXT = struct(Module.VULKAN, "VkVideoEncodeH265FrameSizeEXT") {
    documentation =
        """
        Structure describing frame size values per H.265 picture type.

        <h5>See Also</h5>
        ##VkVideoEncodeH265RateControlLayerInfoEXT
        """

    uint32_t("frameISize", "the size in bytes to be used for I-frames.")
    uint32_t("framePSize", "the size in bytes to be used for P-frames.")
    uint32_t("frameBSize", "the size in bytes to be used for B-frames.")
}

val VkVideoEncodeH265RateControlLayerInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265RateControlLayerInfoEXT") {
    documentation =
        """
        Structure describing H.265 per-layer rate control parameters.

        <h5>Description</h5>
        H.265-specific per-layer rate control parameters <b>must</b> be specified by adding a ##VkVideoEncodeH265RateControlLayerInfoEXT structure to the {@code pNext} chain of each ##VkVideoEncodeRateControlLayerInfoKHR structure in a call to #CmdControlVideoCodingKHR() command, when the command buffer context has an active video encode H.265 session.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT</li>
            <li>{@code minQp} <b>must</b> be a valid ##VkVideoEncodeH265QpEXT structure</li>
            <li>{@code maxQp} <b>must</b> be a valid ##VkVideoEncodeH265QpEXT structure</li>
            <li>{@code maxFrameSize} <b>must</b> be a valid ##VkVideoEncodeH265FrameSizeEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeH265FrameSizeEXT, ##VkVideoEncodeH265QpEXT
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("useMinQp", "indicates whether the values within {@code minQp} should be used by the implementation. When it is set to #FALSE, the implementation ignores the values in {@code minQp} and chooses suitable values.")
    VkVideoEncodeH265QpEXT("minQp", "provides the lower bound on the QP values for each picture type, to be used in rate control calculations.")
    VkBool32("useMaxQp", "indicates whether the values within {@code maxQp} should be used by the implementation. When it is set to #FALSE, the implementation ignores the values in {@code maxQp} and chooses suitable values.")
    VkVideoEncodeH265QpEXT("maxQp", "provides the upper bound on the QP values for each picture type, to be used in rate control calculations.")
    VkBool32("useMaxFrameSize", "indicates whether the values within {@code maxFrameSize} should be used by the implementation.")
    VkVideoEncodeH265FrameSizeEXT("maxFrameSize", "provides the upper bound on the encoded frame size for each picture type. The implementation does not guarantee the encoded frame sizes will be within the specified limits, however these limits <b>may</b> be used as a guide in rate control calculations. If enabled and not set properly, the {@code maxQp} limit may prevent the implementation from respecting the {@code maxFrameSize} limit.")
}

val VkVideoEncodeH265GopRemainingFrameInfoEXT = struct(Module.VULKAN, "VkVideoEncodeH265GopRemainingFrameInfoEXT") {
    documentation =
        """
        Structure specifying H.265 encode rate control GOP remaining frame counts.

        <h5>Description</h5>
        Setting {@code useGopRemainingFrames} to #TRUE and including this structure in the {@code pNext} chain of ##VkVideoEncodeInfoKHR is only mandatory if the ##VkVideoEncodeH265CapabilitiesEXT{@code ::requiresGopRemainingFrames} reported for the used <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-profiles">video profile</a> is #TRUE. However, implementations <b>may</b> use these remaining frame counts, when specified, even when it is not required. In particular, when the application does not use a regular GOP structure, these values <b>may</b> provide additional guidance for the implementation’s rate control algorithm.

        The ##VkVideoEncodeH265CapabilitiesEXT{@code ::prefersGopRemainingFrames} capability is also used to indicate that the implementation’s rate control algorithm <b>may</b> operate more accurately if the application specifies the remaining frame counts using this structure.

        As with other rate control guidance values, if the effective order and number of frames encoded by the application are not in line with the remaining frame counts specified in this structure at any given point, then the behavior of the implementation’s rate control algorithm <b>may</b> deviate from the one expected by the application.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("useGopRemainingFrames", "indicates whether the implementation’s rate control algorithm <b>should</b> use the values specified in {@code gopRemainingI}, {@code gopRemainingP}, and {@code gopRemainingB}. If {@code useGopRemainingFrames} is #FALSE, then the values of {@code gopRemainingI}, {@code gopRemainingP}, and {@code gopRemainingB} are ignored.")
    uint32_t("gopRemainingI", "specifies the number of I-frames the implementation’s rate control algorithm <b>should</b> assume to be remaining in the GOP prior to executing the video encode operation.")
    uint32_t("gopRemainingP", "specifies the number of P-frames the implementation’s rate control algorithm <b>should</b> assume to be remaining in the GOP prior to executing the video encode operation.")
    uint32_t("gopRemainingB", "specifies the number of B-frames the implementation’s rate control algorithm <b>should</b> assume to be remaining in the GOP prior to executing the video encode operation.")
}

val VkVideoDecodeH264ProfileInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH264ProfileInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifying H.264 decode-specific video profile parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR</li>
            <li>If {@code pictureLayout} is not 0, {@code pictureLayout} <b>must</b> be a valid {@code VkVideoDecodeH264PictureLayoutFlagBitsKHR} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoH264ProfileIdc("stdProfileIdc", "a {@code StdVideoH264ProfileIdc} value specifying the H.264 codec profile IDC, as defined in section A.2 of the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#itu-t-h264\">ITU-T H.264 Specification</a>.")
    VkVideoDecodeH264PictureLayoutFlagBitsKHR("pictureLayout", "a {@code VkVideoDecodeH264PictureLayoutFlagBitsKHR} value specifying the picture layout used by the H.264 video sequence to be decoded.")
}

val VkVideoDecodeH264CapabilitiesKHR = struct(Module.VULKAN, "VkVideoDecodeH264CapabilitiesKHR", mutable = false) {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure describing H.264 decode capabilities.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR</li>
        </ul>

        <h5>See Also</h5>
        ##VkOffset2D
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    StdVideoH264LevelIdc("maxLevelIdc", "a {@code StdVideoH264LevelIdc} value specifying the maximum H.264 level supported by the profile, where enum constant {@code STD_VIDEO_H264_LEVEL_IDC_&lt;major&gt;_&lt;minor&gt;} identifies H.264 level {@code &lt;major&gt;.&lt;minor&gt;} as defined in section A.3 of the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#itu-t-h264\">ITU-T H.264 Specification</a>.")
    VkOffset2D("fieldOffsetGranularity", "the minimum alignment for ##VkVideoPictureResourceInfoKHR{@code ::codedOffset} specified for a <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#video-picture-resources\">video picture resource</a> when using the picture layout #VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR.")
}

val VkVideoDecodeH264SessionParametersAddInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH264SessionParametersAddInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 decoder parameter set information.

        <h5>Description</h5>
        This structure <b>can</b> be specified in the following places:

        <ul>
            <li>In the {@code pParametersAddInfo} member of the ##VkVideoDecodeH264SessionParametersCreateInfoKHR structure specified in the {@code pNext} chain of ##VkVideoSessionParametersCreateInfoKHR used to create a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-session-parameters">video session parameters</a> object. In this case, if the video codec operation the video session parameters object is created with is #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then it defines the set of initial parameters to add to the created object (see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#creating-video-session-parameters">Creating Video Session Parameters</a>).</li>
            <li>In the {@code pNext} chain of ##VkVideoSessionParametersUpdateInfoKHR. In this case, if the video codec operation the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-session-parameters">video session parameters</a> object to be updated was created with is #VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then it defines the set of parameters to add to it (see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-session-parameters-update">Updating Video Session Parameters</a>).</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code seq_parameter_set_id} member of each {@code StdVideoH264SequenceParameterSet} structure specified in the elements of {@code pStdSPSs} <b>must</b> be unique within {@code pStdSPSs}</li>
            <li>The pair constructed from the {@code seq_parameter_set_id} and {@code pic_parameter_set_id} members of each {@code StdVideoH264PictureParameterSet} structure specified in the elements of {@code pStdPPSs} <b>must</b> be unique within {@code pStdPPSs}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR</li>
            <li>If {@code stdSPSCount} is not 0, {@code pStdSPSs} <b>must</b> be a valid pointer to an array of {@code stdSPSCount} {@code StdVideoH264SequenceParameterSet} values</li>
            <li>If {@code stdPPSCount} is not 0, {@code pStdPPSs} <b>must</b> be a valid pointer to an array of {@code stdPPSCount} {@code StdVideoH264PictureParameterSet} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoDecodeH264SessionParametersCreateInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pStdSPSs", optional = true)..uint32_t("stdSPSCount", "the number of elements in the {@code pStdSPSs} array.")
    StdVideoH264SequenceParameterSet.const.p("pStdSPSs", "a pointer to an array of {@code StdVideoH264SequenceParameterSet} structures describing the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h264-sps\">H.264 SPS</a> entries to add.")
    AutoSize("pStdPPSs", optional = true)..uint32_t("stdPPSCount", "the number of elements in the {@code pStdPPSs} array.")
    StdVideoH264PictureParameterSet.const.p("pStdPPSs", "a pointer to an array of {@code StdVideoH264PictureParameterSet} structures describing the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h264-pps\">H.264 PPS</a> entries to add.")
}

val VkVideoDecodeH264SessionParametersCreateInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH264SessionParametersCreateInfoKHR") {
    documentation =
        """
        Structure specifies H.264 decoder parameter set information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR</li>
            <li>If {@code pParametersAddInfo} is not {@code NULL}, {@code pParametersAddInfo} <b>must</b> be a valid pointer to a valid ##VkVideoDecodeH264SessionParametersAddInfoKHR structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoDecodeH264SessionParametersAddInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("maxStdSPSCount", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h264-sps\">H.264 SPS</a> entries the created {@code VkVideoSessionParametersKHR} <b>can</b> contain.")
    uint32_t("maxStdPPSCount", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h264-pps\">H.264 PPS</a> entries the created {@code VkVideoSessionParametersKHR} <b>can</b> contain.")
    nullable..VkVideoDecodeH264SessionParametersAddInfoKHR.const.p("pParametersAddInfo", "{@code NULL} or a pointer to a ##VkVideoDecodeH264SessionParametersAddInfoKHR structure specifying H.264 parameters to add upon object creation.")
}

val VkVideoDecodeH264PictureInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH264PictureInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 decode picture parameters when decoding a picture.

        <h5>Description</h5>
        This structure is specified in the {@code pNext} chain of the ##VkVideoDecodeInfoKHR structure passed to #CmdDecodeVideoKHR() to specify the codec-specific picture information for an <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264">H.264 decode operation</a>.

        <dl>
            <dt>Decode Output Picture Information</dt>
            <dd><ul>
                <li>If {@code pStdPictureInfo→flags.field_pic_flag} is not set, then the picture represents a frame.</li>
                <li>
                    If {@code pStdPictureInfo→flags.field_pic_flag} is set, then the picture represents a field. Specifically:
                    <ul>
                        <li>If {@code pStdPictureInfo→flags.bottom_field_flag} is not set, then the picture represents the top field of the frame.</li>
                        <li>If {@code pStdPictureInfo→flags.bottom_field_flag} is set, then the picture represents the bottom field of the frame.</li>
                    </ul>
                </li>
                <li>The image subregion used is determined according to the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-picture-data-access">H.264 Decode Picture Data Access</a> section.</li>
                <li>The decode output picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-picture-info">H.264 picture information</a> provided in {@code pStdPictureInfo}.</li>
            </ul></dd>
        </dl>

        <dl>
            <dt>Std Picture Information</dt>
            <dd><ul>
                <li>{@code reserved1} and {@code reserved2} are used only for padding purposes and are otherwise ignored;</li>
                <li>{@code flags.is_intra} as defined in section 3.73 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h264">ITU-T H.264 Specification</a>;</li>
                <li>{@code flags.is_reference} as defined in section 3.136 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h264">ITU-T H.264 Specification</a>;</li>
                <li>{@code flags.complementary_field_pair} as defined in section 3.35 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h264">ITU-T H.264 Specification</a>;</li>
                <li>{@code seq_parameter_set_id} and {@code pic_parameter_set_id} are used to identify the active parameter sets, as described below;</li>
                <li>all other members are interpreted as defined in section 7.4.3 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h264">ITU-T H.264 Specification</a>.</li>
            </ul></dd>

            <dt>Active Parameter Sets</dt>
            <dd><ul>
                <li>The <em>active SPS</em> is the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-sps">SPS</a> identified by the key specified in {@code StdVideoDecodeH264PictureInfo}{@code ::seq_parameter_set_id}.</li>
                <li>The <em>active PPS</em> is the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-pps">PPS</a> identified by the key specified by the pair constructed from {@code StdVideoDecodeH264PictureInfo}{@code ::seq_parameter_set_id} and {@code StdVideoDecodeH264PictureInfo}{@code ::pic_parameter_set_id}.</li>
            </ul></dd>
        </dl>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR</li>
            <li>{@code pStdPictureInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoDecodeH264PictureInfo} value</li>
            <li>{@code pSliceOffsets} <b>must</b> be a valid pointer to an array of {@code sliceCount} {@code uint32_t} values</li>
            <li>{@code sliceCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoDecodeH264PictureInfo.const.p("pStdPictureInfo", "a pointer to a {@code StdVideoDecodeH264PictureInfo} structure specifying <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h264-picture-info\">H.264 picture information</a>.")
    AutoSize("pSliceOffsets")..uint32_t("sliceCount", "the number of elements in {@code pSliceOffsets}.")
    uint32_t.const.p("pSliceOffsets", "a pointer to an array of {@code sliceCount} offsets specifying the start offset of the slices of the picture within the video bitstream buffer range specified in ##VkVideoDecodeInfoKHR.")
}

val VkVideoDecodeH264DpbSlotInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH264DpbSlotInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.264 decode DPB picture information.

        <h5>Description</h5>
        This structure is specified in the {@code pNext} chain of ##VkVideoDecodeInfoKHR{@code ::pSetupReferenceSlot}, if not {@code NULL}, and the {@code pNext} chain of the elements of ##VkVideoDecodeInfoKHR{@code ::pReferenceSlots} to specify the codec-specific reference picture information for an <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264">H.264 decode operation</a>.

        <dl>
            <dt>Active Reference Picture Information</dt>
            <dd><ul>
                <li>If neither {@code pStdReferenceInfo→flags.top_field_flag} nor {@code pStdReferenceInfo→flags.bottom_field_flag} is set, then the picture is added as a frame reference to the list of active reference pictures.</li>
                <li>If {@code pStdReferenceInfo→flags.top_field_flag} is set, then the picture is added as a top field reference to the list of active reference pictures.</li>
                <li>If {@code pStdReferenceInfo→flags.bottom_field_flag} is set, then the picture is added as a bottom field reference to the list of active reference pictures.</li>
                <li>For each added reference picture, the corresponding image subregion used is determined according to the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-picture-data-access">H.264 Decode Picture Data Access</a> section.</li>
                <li>Each added reference picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#dpb-slot">DPB slot</a> index specified in the {@code slotIndex} member of the corresponding element of ##VkVideoDecodeInfoKHR{@code ::pReferenceSlots}.</li>
                <li>Each added reference picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-reference-info">H.264 reference information</a> provided in {@code pStdReferenceInfo}.</li>
            </ul></dd>
        </dl>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        When both the top and bottom field of an interlaced frame currently associated with a DPB slot is intended to be used as an active reference picture and both fields are stored in the same image subregion (which is the case when using #VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR which stores the two fields at even and odd scanlines of the same image subregion), both references have to be provided through a single ##VkVideoReferenceSlotInfoKHR structure that has both {@code flags.top_field_flag} and {@code flags.bottom_field_flag} set in the {@code StdVideoDecodeH264ReferenceInfo} structure pointed to by the {@code pStdReferenceInfo} member of the ##VkVideoDecodeH264DpbSlotInfoKHR structure included in the corresponding ##VkVideoReferenceSlotInfoKHR structure’s {@code pNext} chain. However, this approach can only be used when both fields are stored in the same image subregion. If that is not the case (e.g. when using #VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR which requires separate {@code codedOffset} values for the two fields and also allows storing the two fields of a frame in separate image layers or entirely separate images), then a separate ##VkVideoReferenceSlotInfoKHR structure needs to be provided for referencing the two fields, each only setting one of {@code flags.top_field_flag} or {@code flags.bottom_field_flag}, and providing the appropriate video picture resource information in ##VkVideoReferenceSlotInfoKHR{@code ::pPictureResource}.
        </div>

        <dl>
            <dt>Reconstructed Picture Information</dt>
            <dd><ul>
                <li>If neither {@code pStdReferenceInfo→flags.top_field_flag} nor {@code pStdReferenceInfo→flags.bottom_field_flag} is set, then the picture represents a frame.</li>
                <li>If {@code pStdReferenceInfo→flags.top_field_flag} is set, then the picture represents a field, specifically, the top field of the frame.</li>
                <li>If {@code pStdReferenceInfo→flags.bottom_field_flag} is set, then the picture represents a field, specifically, the bottom field of the frame.</li>
                <li>The image subregion used is determined according to the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-picture-data-access">H.264 Decode Picture Data Access</a> section.</li>
                <li>The reconstructed picture is used to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#dpb-slot-states">activate</a> the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#dpb-slot">DPB slot</a> with the index specified in ##VkVideoDecodeInfoKHR{@code ::pSetupReferenceSlot→slotIndex}.</li>
                <li>The reconstructed picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h264-reference-info">H.264 reference information</a> provided in {@code pStdReferenceInfo}.</li>
            </ul></dd>
        </dl>

        <dl>
            <dt>Std Reference Information</dt>
            <dd><ul>
                <li>{@code flags.top_field_flag} is used to indicate whether the reference is used as top field reference;</li>
                <li>{@code flags.bottom_field_flag} is used to indicate whether the reference is used as bottom field reference;</li>
                <li>{@code flags.used_for_long_term_reference} is used to indicate whether the picture is marked as “used for long-term reference” as defined in section 8.2.5.1 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h264">ITU-T H.264 Specification</a>;</li>
                <li>{@code flags.is_non_existing} is used to indicate whether the picture is marked as “non-existing” as defined in section 8.2.5.2 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h264">ITU-T H.264 Specification</a>;</li>
                <li>all other members are interpreted as defined in section 8.2 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h264">ITU-T H.264 Specification</a>.</li>
            </ul></dd>
        </dl>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR</li>
            <li>{@code pStdReferenceInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoDecodeH264ReferenceInfo} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoDecodeH264ReferenceInfo.const.p("pStdReferenceInfo", "a pointer to a {@code StdVideoDecodeH264ReferenceInfo} structure specifying <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h264-reference-info\">H.264 reference information</a>.")
}

val VkTextureLODGatherFormatPropertiesAMD = struct(Module.VULKAN, "VkTextureLODGatherFormatPropertiesAMD", mutable = false) {
    documentation =
        """
        Structure informing whether or not texture gather bias/LOD functionality is supported for a given image format and a given physical device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("supportsTextureGatherLODBiasAMD", "tells if the image format can be used with texture gather bias/LOD functions, as introduced by the {@link AMDTextureGatherBiasLod VK_AMD_texture_gather_bias_lod} extension. This field is set by the implementation. User-specified value is ignored.")
}

val VkShaderResourceUsageAMD = struct(Module.VULKAN, "VkShaderResourceUsageAMD", mutable = false) {
    documentation =
        """
        Resource usage information about a particular shader within a pipeline.

        <h5>See Also</h5>
        ##VkShaderStatisticsInfoAMD
        """

    uint32_t("numUsedVgprs", "the number of vector instruction general-purpose registers used by this shader.")
    uint32_t("numUsedSgprs", "the number of scalar instruction general-purpose registers used by this shader.")
    uint32_t("ldsSizePerLocalWorkGroup", "the maximum local data store size per work group in bytes.")
    size_t("ldsUsageSizeInBytes", "the LDS usage size in bytes per work group by this shader.")
    size_t("scratchMemUsageInBytes", "the scratch memory usage in bytes by this shader.")
}

val VkShaderStatisticsInfoAMD = struct(Module.VULKAN, "VkShaderStatisticsInfoAMD", mutable = false) {
    documentation =
        """
        Statistical information about a particular shader within a pipeline.

        <h5>Description</h5>
        Some implementations may merge multiple logical shader stages together in a single shader. In such cases, {@code shaderStageMask} will contain a bitmask of all of the stages that are active within that shader. Consequently, if specifying those stages as input to #GetShaderInfoAMD(), the same output information <b>may</b> be returned for all such shader stage queries.

        The number of available VGPRs and SGPRs ({@code numAvailableVgprs} and {@code numAvailableSgprs} respectively) are the shader-addressable subset of physical registers that is given as a limit to the compiler for register assignment. These values <b>may</b> further be limited by implementations due to performance optimizations where register pressure is a bottleneck.

        <h5>See Also</h5>
        ##VkShaderResourceUsageAMD
        """

    VkShaderStageFlags("shaderStageMask", "are the combination of logical shader stages contained within this shader.")
    VkShaderResourceUsageAMD("resourceUsage", "a ##VkShaderResourceUsageAMD structure describing internal physical device resources used by this shader.")
    uint32_t("numPhysicalVgprs", "the maximum number of vector instruction general-purpose registers (VGPRs) available to the physical device.")
    uint32_t("numPhysicalSgprs", "the maximum number of scalar instruction general-purpose registers (SGPRs) available to the physical device.")
    uint32_t("numAvailableVgprs", "the maximum limit of VGPRs made available to the shader compiler.")
    uint32_t("numAvailableSgprs", "the maximum limit of SGPRs made available to the shader compiler.")
    uint32_t("computeWorkGroupSize", "the local workgroup size of this shader in { X, Y, Z } dimensions.")[3]
}

val VkRenderingInfoKHR = struct(Module.VULKAN, "VkRenderingInfoKHR", alias = VkRenderingInfo) {
    documentation = "See ##VkRenderingInfo."

    Expression("#STRUCTURE_TYPE_RENDERING_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkRenderingFlags("flags", "")
    VkRect2D("renderArea", "")
    uint32_t("layerCount", "")
    uint32_t("viewMask", "")
    AutoSize("pColorAttachments", optional = true)..uint32_t("colorAttachmentCount", "")
    VkRenderingAttachmentInfo.const.p("pColorAttachments", "")
    nullable..VkRenderingAttachmentInfo.const.p("pDepthAttachment", "")
    nullable..VkRenderingAttachmentInfo.const.p("pStencilAttachment", "")
}

val VkRenderingAttachmentInfoKHR = struct(Module.VULKAN, "VkRenderingAttachmentInfoKHR", alias = VkRenderingAttachmentInfo) {
    documentation = "See ##VkRenderingAttachmentInfo."

    Expression("#STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageView("imageView", "")
    VkImageLayout("imageLayout", "")
    VkResolveModeFlagBits("resolveMode", "")
    VkImageView("resolveImageView", "")
    VkImageLayout("resolveImageLayout", "")
    VkAttachmentLoadOp("loadOp", "")
    VkAttachmentStoreOp("storeOp", "")
    VkClearValue("clearValue", "")
}

val VkPipelineRenderingCreateInfoKHR = struct(Module.VULKAN, "VkPipelineRenderingCreateInfoKHR", alias = VkPipelineRenderingCreateInfo) {
    documentation = "See ##VkPipelineRenderingCreateInfo."

    Expression("#STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("viewMask", "")
    AutoSize("pColorAttachmentFormats", optional = true)..uint32_t("colorAttachmentCount", "")
    nullable..VkFormat.const.p("pColorAttachmentFormats", "")
    VkFormat("depthAttachmentFormat", "")
    VkFormat("stencilAttachmentFormat", "")
}

val VkPhysicalDeviceDynamicRenderingFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceDynamicRenderingFeaturesKHR", alias = VkPhysicalDeviceDynamicRenderingFeatures) {
    documentation = "See ##VkPhysicalDeviceDynamicRenderingFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("dynamicRendering", "")
}

val VkCommandBufferInheritanceRenderingInfoKHR = struct(Module.VULKAN, "VkCommandBufferInheritanceRenderingInfoKHR", alias = VkCommandBufferInheritanceRenderingInfo) {
    documentation = "See ##VkCommandBufferInheritanceRenderingInfo."

    Expression("#STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkRenderingFlags("flags", "")
    uint32_t("viewMask", "")
    AutoSize("pColorAttachmentFormats", optional = true)..uint32_t("colorAttachmentCount", "")
    VkFormat.const.p("pColorAttachmentFormats", "")
    VkFormat("depthAttachmentFormat", "")
    VkFormat("stencilAttachmentFormat", "")
    VkSampleCountFlagBits("rasterizationSamples", "")
}

val VkRenderingFragmentShadingRateAttachmentInfoKHR = struct(Module.VULKAN, "VkRenderingFragmentShadingRateAttachmentInfoKHR") {
    documentation =
        """
        Structure specifying fragment shading rate attachment information.

        <h5>Description</h5>
        This structure can be included in the {@code pNext} chain of ##VkRenderingInfo to define a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-fragment-shading-rate-attachment">fragment shading rate attachment</a>. If {@code imageView} is #NULL_HANDLE, or if this structure is not specified, the implementation behaves as if a valid shading rate attachment was specified with all texels specifying a single pixel per fragment.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code layout} <b>must</b> be #IMAGE_LAYOUT_GENERAL or #IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR</li>
            <li>If {@code imageView} is not #NULL_HANDLE, it <b>must</b> have been created with #IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR</li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code shadingRateAttachmentTexelSize.width} <b>must</b> be a power of two value</li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code shadingRateAttachmentTexelSize.width} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSize">{@code maxFragmentShadingRateAttachmentTexelSize.width}</a></li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code shadingRateAttachmentTexelSize.width} <b>must</b> be greater than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-minFragmentShadingRateAttachmentTexelSize">{@code minFragmentShadingRateAttachmentTexelSize.width}</a></li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code shadingRateAttachmentTexelSize.height} <b>must</b> be a power of two value</li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code shadingRateAttachmentTexelSize.height} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSize">{@code maxFragmentShadingRateAttachmentTexelSize.height}</a></li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code shadingRateAttachmentTexelSize.height} <b>must</b> be greater than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-minFragmentShadingRateAttachmentTexelSize">{@code minFragmentShadingRateAttachmentTexelSize.height}</a></li>
            <li>If {@code imageView} is not #NULL_HANDLE, the quotient of {@code shadingRateAttachmentTexelSize.width} and {@code shadingRateAttachmentTexelSize.height} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSizeAspectRatio">{@code maxFragmentShadingRateAttachmentTexelSizeAspectRatio}</a></li>
            <li>If {@code imageView} is not #NULL_HANDLE, the quotient of {@code shadingRateAttachmentTexelSize.height} and {@code shadingRateAttachmentTexelSize.width} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSizeAspectRatio">{@code maxFragmentShadingRateAttachmentTexelSizeAspectRatio}</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR</li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code imageView} <b>must</b> be a valid {@code VkImageView} handle</li>
            <li>{@code imageLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageView("imageView", "the image view that will be used as a fragment shading rate attachment.")
    VkImageLayout("imageLayout", "the layout that {@code imageView} will be in during rendering.")
    VkExtent2D("shadingRateAttachmentTexelSize", "specifies the number of pixels corresponding to each texel in {@code imageView}.")
}

val VkRenderingFragmentDensityMapAttachmentInfoEXT = struct(Module.VULKAN, "VkRenderingFragmentDensityMapAttachmentInfoEXT") {
    documentation =
        """
        Structure specifying fragment shading rate attachment information.

        <h5>Description</h5>
        This structure can be included in the {@code pNext} chain of ##VkRenderingInfo to define a fragment density map. If this structure is not included in the {@code pNext} chain, {@code imageView} is treated as #NULL_HANDLE.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code layout} <b>must</b> be #IMAGE_LAYOUT_GENERAL or #IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT</li>
            <li>If {@code imageView} is not #NULL_HANDLE, it <b>must</b> have been created with #IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT</li>
            <li>If {@code imageView} is not #NULL_HANDLE, it <b>must</b> not have been created with #IMAGE_CREATE_SUBSAMPLED_BIT_EXT</li>
            <li>If {@link KHRMultiview VK_KHR_multiview} is not enabled, ##VkPhysicalDeviceProperties{@code ::apiVersion} is less than Vulkan 1.1, and {@code imageView} is not #NULL_HANDLE, it <b>must</b> have a {@code layerCount} equal to 1</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT</li>
            <li>{@code imageView} <b>must</b> be a valid {@code VkImageView} handle</li>
            <li>{@code imageLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageView("imageView", "the image view that will be used as a fragment density map attachment.")
    VkImageLayout("imageLayout", "the layout that {@code imageView} will be in during rendering.")
}

val VkAttachmentSampleCountInfoAMD = struct(Module.VULKAN, "VkAttachmentSampleCountInfoAMD") {
    documentation =
        """
        Structure specifying command buffer inheritance info for dynamic render pass instances.

        <h5>Description</h5>
        If ##VkCommandBufferInheritanceInfo{@code ::renderPass} is #NULL_HANDLE, #COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT is specified in ##VkCommandBufferBeginInfo{@code ::flags}, and the {@code pNext} chain of ##VkCommandBufferInheritanceInfo includes ##VkAttachmentSampleCountInfoAMD, then this structure defines the sample counts of each attachment within the render pass instance. If ##VkAttachmentSampleCountInfoAMD is not included, the value of ##VkCommandBufferInheritanceRenderingInfo{@code ::rasterizationSamples} is used as the sample count for each attachment. If ##VkCommandBufferInheritanceInfo{@code ::renderPass} is not #NULL_HANDLE, or #COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT is not specified in ##VkCommandBufferBeginInfo{@code ::flags}, parameters of this structure are ignored.

        ##VkAttachmentSampleCountInfoAMD <b>can</b> also be included in the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo. When a graphics pipeline is created without a {@code VkRenderPass}, if this structure is included in the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo, it specifies the sample count of attachments used for rendering. If this structure is not specified, and the pipeline does not include a {@code VkRenderPass}, the value of ##VkPipelineMultisampleStateCreateInfo{@code ::rasterizationSamples} is used as the sample count for each attachment. If a graphics pipeline is created with a valid {@code VkRenderPass}, parameters of this structure are ignored.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure")
    AutoSize("pColorAttachmentSamples", optional = true)..uint32_t("colorAttachmentCount", "the number of color attachments specified in a render pass instance.")
    nullable..VkSampleCountFlagBits.const.p("pColorAttachmentSamples", "a pointer to an array of {@code VkSampleCountFlagBits} values defining the sample count of color attachments.")
    VkSampleCountFlagBits("depthStencilAttachmentSamples", "a {@code VkSampleCountFlagBits} value defining the sample count of a depth/stencil attachment.")
}

val VkAttachmentSampleCountInfoNV = struct(Module.VULKAN, "VkAttachmentSampleCountInfoNV", alias = VkAttachmentSampleCountInfoAMD) {
    documentation = "See ##VkAttachmentSampleCountInfoAMD."

    Expression("#STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pColorAttachmentSamples", optional = true)..uint32_t("colorAttachmentCount", "")
    nullable..VkSampleCountFlagBits.const.p("pColorAttachmentSamples", "")
    VkSampleCountFlagBits("depthStencilAttachmentSamples", "")
}

val VkMultiviewPerViewAttributesInfoNVX = struct(Module.VULKAN, "VkMultiviewPerViewAttributesInfoNVX") {
    documentation =
        """
        Structure specifying the multiview per-attribute properties.

        <h5>Description</h5>
        When dynamic render pass instances are being used, instead of specifying #SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX or #SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX in the subpass description flags, the per-attribute properties of the render pass instance <b>must</b> be specified by the ##VkMultiviewPerViewAttributesInfoNVX structure Include the ##VkMultiviewPerViewAttributesInfoNVX structure in the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo when creating a graphics pipeline for dynamic rendering, ##VkRenderingInfo when starting a dynamic render pass instance, and ##VkCommandBufferInheritanceInfo when specifying the dynamic render pass instance parameters for secondary command buffers.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("perViewAttributes", "specifies that shaders compiled for this pipeline write the attributes for all views in a single invocation of each vertex processing stage. All pipelines executed within a render pass instance that includes this bit <b>must</b> write per-view attributes to the {@code *PerViewNV[]} shader outputs, in addition to the non-per-view (e.g. {@code Position}) outputs.")
    VkBool32("perViewAttributesPositionXOnly", "specifies that shaders compiled for this pipeline use per-view positions which only differ in value in the x component. Per-view viewport mask <b>can</b> also be used.")
}

val VkPhysicalDeviceCornerSampledImageFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceCornerSampledImageFeaturesNV") {
    documentation =
        """
        Structure describing corner sampled image features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCornerSampledImageFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCornerSampledImageFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("cornerSampledImage", "specifies whether images can be created with a ##VkImageCreateInfo{@code ::flags} containing #IMAGE_CREATE_CORNER_SAMPLED_BIT_NV. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#resources-images-corner-sampled\">Corner-Sampled Images</a>.")
}

val VkRenderPassMultiviewCreateInfoKHR = struct(Module.VULKAN, "VkRenderPassMultiviewCreateInfoKHR", alias = VkRenderPassMultiviewCreateInfo) {
    documentation = "See ##VkRenderPassMultiviewCreateInfo."

    Expression("#STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pViewMasks", optional = true)..uint32_t("subpassCount", "")
    uint32_t.const.p("pViewMasks", "")
    AutoSize("pViewOffsets", optional = true)..uint32_t("dependencyCount", "")
    int32_t.const.p("pViewOffsets", "")
    AutoSize("pCorrelationMasks", optional = true)..uint32_t("correlationMaskCount", "")
    uint32_t.const.p("pCorrelationMasks", "")
}

val VkPhysicalDeviceMultiviewFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceMultiviewFeaturesKHR", alias = VkPhysicalDeviceMultiviewFeatures) {
    documentation = "See ##VkPhysicalDeviceMultiviewFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("multiview", "")
    VkBool32("multiviewGeometryShader", "")
    VkBool32("multiviewTessellationShader", "")
}

val VkPhysicalDeviceMultiviewPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceMultiviewPropertiesKHR", mutable = false, alias = VkPhysicalDeviceMultiviewProperties) {
    documentation = "See ##VkPhysicalDeviceMultiviewProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("maxMultiviewViewCount", "")
    uint32_t("maxMultiviewInstanceIndex", "")
}

val VkExternalImageFormatPropertiesNV = struct(Module.VULKAN, "VkExternalImageFormatPropertiesNV", mutable = false) {
    documentation =
        """
        Structure specifying external image format properties.

        <h5>See Also</h5>
        ##VkImageFormatProperties, #GetPhysicalDeviceExternalImageFormatPropertiesNV()
        """

    VkImageFormatProperties("imageFormatProperties", "will be filled in as when calling #GetPhysicalDeviceImageFormatProperties(), but the values returned <b>may</b> vary depending on the external handle type requested.")
    VkExternalMemoryFeatureFlagsNV("externalMemoryFeatures", "a bitmask of {@code VkExternalMemoryFeatureFlagBitsNV}, indicating properties of the external memory handle type (#GetPhysicalDeviceExternalImageFormatPropertiesNV(){@code ::externalHandleType}) being queried, or 0 if the external memory handle type is 0.")
    VkExternalMemoryHandleTypeFlagsNV("exportFromImportedHandleTypes", "a bitmask of {@code VkExternalMemoryHandleTypeFlagBitsNV} containing a bit set for every external handle type that <b>may</b> be used to create memory from which the handles of the type specified in #GetPhysicalDeviceExternalImageFormatPropertiesNV(){@code ::externalHandleType} <b>can</b> be exported, or 0 if the external memory handle type is 0.")
    VkExternalMemoryHandleTypeFlagsNV("compatibleHandleTypes", "a bitmask of {@code VkExternalMemoryHandleTypeFlagBitsNV} containing a bit set for every external handle type that <b>may</b> be specified simultaneously with the handle type specified by #GetPhysicalDeviceExternalImageFormatPropertiesNV(){@code ::externalHandleType} when calling #AllocateMemory(), or 0 if the external memory handle type is 0. {@code compatibleHandleTypes} will always contain #GetPhysicalDeviceExternalImageFormatPropertiesNV(){@code ::externalHandleType}")
}

val VkExternalMemoryImageCreateInfoNV = struct(Module.VULKAN, "VkExternalMemoryImageCreateInfoNV") {
    documentation =
        """
        Specify that an image may be backed by external memory.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV</li>
            <li>{@code handleTypes} <b>must</b> be a valid combination of {@code VkExternalMemoryHandleTypeFlagBitsNV} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExternalMemoryHandleTypeFlagsNV("handleTypes", "zero or a bitmask of {@code VkExternalMemoryHandleTypeFlagBitsNV} specifying one or more external memory handle types.")
}

val VkExportMemoryAllocateInfoNV = struct(Module.VULKAN, "VkExportMemoryAllocateInfoNV") {
    documentation =
        """
        Specify memory handle types that may be exported.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV</li>
            <li>{@code handleTypes} <b>must</b> be a valid combination of {@code VkExternalMemoryHandleTypeFlagBitsNV} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExternalMemoryHandleTypeFlagsNV("handleTypes", "a bitmask of {@code VkExternalMemoryHandleTypeFlagBitsNV} specifying one or more memory handle types that <b>may</b> be exported. Multiple handle types <b>may</b> be requested for the same allocation as long as they are compatible, as reported by #GetPhysicalDeviceExternalImageFormatPropertiesNV().")
}

val VkImportMemoryWin32HandleInfoNV = struct(Module.VULKAN, "VkImportMemoryWin32HandleInfoNV") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Import Win32 memory created on the same physical device.

        <h5>Description</h5>
        If {@code handleType} is 0, this structure is ignored by consumers of the ##VkMemoryAllocateInfo structure it is chained from.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> not have more than one bit set</li>
            <li>{@code handle} <b>must</b> be a valid handle to memory, obtained as specified by {@code handleType}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV</li>
            <li>{@code handleType} <b>must</b> be a valid combination of {@code VkExternalMemoryHandleTypeFlagBitsNV} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExternalMemoryHandleTypeFlagsNV("handleType", "0 or a {@code VkExternalMemoryHandleTypeFlagBitsNV} value specifying the type of memory handle in {@code handle}.")
    HANDLE("handle", "a Windows {@code HANDLE} referring to the memory.")
}

val VkExportMemoryWin32HandleInfoNV = struct(Module.VULKAN, "VkExportMemoryWin32HandleInfoNV") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Specify security attributes and access rights for Win32 memory handles.

        <h5>Description</h5>
        If this structure is not present, or if {@code pAttributes} is set to {@code NULL}, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “{@code Synchronization Object Security and Access Rights}”<sup>1</sup>. Further, if the structure is not present, the access rights will be

        {@code DXGI_SHARED_RESOURCE_READ} | {@code DXGI_SHARED_RESOURCE_WRITE}

        <dl>
            <dt>1</dt>
            <dd><a href="https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights</a></dd>
        </dl>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV</li>
            <li>If {@code pAttributes} is not {@code NULL}, {@code pAttributes} <b>must</b> be a valid pointer to a valid {@code SECURITY_ATTRIBUTES} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    nullable..SECURITY_ATTRIBUTES.const.p("pAttributes", "a pointer to a Windows {@code SECURITY_ATTRIBUTES} structure specifying security attributes of the handle.")
    DWORD("dwAccess", "a {@code DWORD} specifying access rights of the handle.")
}

val VkWin32KeyedMutexAcquireReleaseInfoNV = struct(Module.VULKAN, "VkWin32KeyedMutexAcquireReleaseInfoNV") {
    documentation =
        """
        Use Windows keyex mutex mechanism to synchronize work.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV</li>
            <li>If {@code acquireCount} is not 0, {@code pAcquireSyncs} <b>must</b> be a valid pointer to an array of {@code acquireCount} valid {@code VkDeviceMemory} handles</li>
            <li>If {@code acquireCount} is not 0, {@code pAcquireKeys} <b>must</b> be a valid pointer to an array of {@code acquireCount} {@code uint64_t} values</li>
            <li>If {@code acquireCount} is not 0, {@code pAcquireTimeoutMilliseconds} <b>must</b> be a valid pointer to an array of {@code acquireCount} {@code uint32_t} values</li>
            <li>If {@code releaseCount} is not 0, {@code pReleaseSyncs} <b>must</b> be a valid pointer to an array of {@code releaseCount} valid {@code VkDeviceMemory} handles</li>
            <li>If {@code releaseCount} is not 0, {@code pReleaseKeys} <b>must</b> be a valid pointer to an array of {@code releaseCount} {@code uint64_t} values</li>
            <li>Both of the elements of {@code pAcquireSyncs}, and the elements of {@code pReleaseSyncs} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pAcquireSyncs", "pAcquireKeys", "pAcquireTimeoutMilliseconds", optional = true)..uint32_t("acquireCount", "the number of entries in the {@code pAcquireSyncs}, {@code pAcquireKeys}, and {@code pAcquireTimeoutMilliseconds} arrays.")
    VkDeviceMemory.const.p("pAcquireSyncs", "a pointer to an array of {@code VkDeviceMemory} objects which were imported from Direct3D 11 resources.")
    uint64_t.const.p("pAcquireKeys", "a pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in {@code pAcquireSyncs}.")
    uint32_t.const.p("pAcquireTimeoutMilliseconds", "a pointer to an array of timeout values, in millisecond units, for each acquire specified in {@code pAcquireKeys}.")
    AutoSize("pReleaseSyncs", "pReleaseKeys", optional = true)..uint32_t("releaseCount", "the number of entries in the {@code pReleaseSyncs} and {@code pReleaseKeys} arrays.")
    VkDeviceMemory.const.p("pReleaseSyncs", "a pointer to an array of {@code VkDeviceMemory} objects which were imported from Direct3D 11 resources.")
    uint64_t.const.p("pReleaseKeys", "a pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in {@code pReleaseSyncs}.")
}

val VkPhysicalDeviceFeatures2KHR = struct(Module.VULKAN, "VkPhysicalDeviceFeatures2KHR", alias = VkPhysicalDeviceFeatures2) {
    documentation = "See ##VkPhysicalDeviceFeatures2."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkPhysicalDeviceFeatures("features", "")
}

val VkPhysicalDeviceProperties2KHR = struct(Module.VULKAN, "VkPhysicalDeviceProperties2KHR", mutable = false, alias = VkPhysicalDeviceProperties2) {
    documentation = "See ##VkPhysicalDeviceProperties2."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkPhysicalDeviceProperties("properties", "")
}

val VkFormatProperties2KHR = struct(Module.VULKAN, "VkFormatProperties2KHR", mutable = false, alias = VkFormatProperties2) {
    documentation = "See ##VkFormatProperties2."

    Expression("#STRUCTURE_TYPE_FORMAT_PROPERTIES_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkFormatProperties("formatProperties", "")
}

val VkImageFormatProperties2KHR = struct(Module.VULKAN, "VkImageFormatProperties2KHR", mutable = false, alias = VkImageFormatProperties2) {
    documentation = "See ##VkImageFormatProperties2."

    Expression("#STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkImageFormatProperties("imageFormatProperties", "")
}

val VkPhysicalDeviceImageFormatInfo2KHR = struct(Module.VULKAN, "VkPhysicalDeviceImageFormatInfo2KHR", alias = VkPhysicalDeviceImageFormatInfo2) {
    documentation = "See ##VkPhysicalDeviceImageFormatInfo2."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkFormat("format", "")
    VkImageType("type", "")
    VkImageTiling("tiling", "")
    VkImageUsageFlags("usage", "")
    VkImageCreateFlags("flags", "")
}

val VkQueueFamilyProperties2KHR = struct(Module.VULKAN, "VkQueueFamilyProperties2KHR", mutable = false, alias = VkQueueFamilyProperties2) {
    documentation = "See ##VkQueueFamilyProperties2."

    Expression("#STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkQueueFamilyProperties("queueFamilyProperties", "")
}

val VkPhysicalDeviceMemoryProperties2KHR = struct(Module.VULKAN, "VkPhysicalDeviceMemoryProperties2KHR", mutable = false, alias = VkPhysicalDeviceMemoryProperties2) {
    documentation = "See ##VkPhysicalDeviceMemoryProperties2."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkPhysicalDeviceMemoryProperties("memoryProperties", "")
}

val VkSparseImageFormatProperties2KHR = struct(Module.VULKAN, "VkSparseImageFormatProperties2KHR", mutable = false, alias = VkSparseImageFormatProperties2) {
    documentation = "See ##VkSparseImageFormatProperties2."

    Expression("#STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkSparseImageFormatProperties("properties", "")
}

val VkPhysicalDeviceSparseImageFormatInfo2KHR = struct(Module.VULKAN, "VkPhysicalDeviceSparseImageFormatInfo2KHR", alias = VkPhysicalDeviceSparseImageFormatInfo2) {
    documentation = "See ##VkPhysicalDeviceSparseImageFormatInfo2."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkFormat("format", "")
    VkImageType("type", "")
    VkSampleCountFlagBits("samples", "")
    VkImageUsageFlags("usage", "")
    VkImageTiling("tiling", "")
}

val VkMemoryAllocateFlagsInfoKHR = struct(Module.VULKAN, "VkMemoryAllocateFlagsInfoKHR", alias = VkMemoryAllocateFlagsInfo) {
    documentation = "See ##VkMemoryAllocateFlagsInfo."

    Expression("#STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkMemoryAllocateFlags("flags", "")
    uint32_t("deviceMask", "")
}

val VkDeviceGroupRenderPassBeginInfoKHR = struct(Module.VULKAN, "VkDeviceGroupRenderPassBeginInfoKHR", alias = VkDeviceGroupRenderPassBeginInfo) {
    documentation = "See ##VkDeviceGroupRenderPassBeginInfo."

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("deviceMask", "")
    AutoSize("pDeviceRenderAreas", optional = true)..uint32_t("deviceRenderAreaCount", "")
    VkRect2D.const.p("pDeviceRenderAreas", "")
}

val VkDeviceGroupCommandBufferBeginInfoKHR = struct(Module.VULKAN, "VkDeviceGroupCommandBufferBeginInfoKHR", alias = VkDeviceGroupCommandBufferBeginInfo) {
    documentation = "See ##VkDeviceGroupCommandBufferBeginInfo."

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("deviceMask", "")
}

val VkDeviceGroupSubmitInfoKHR = struct(Module.VULKAN, "VkDeviceGroupSubmitInfoKHR", alias = VkDeviceGroupSubmitInfo) {
    documentation = "See ##VkDeviceGroupSubmitInfo."

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pWaitSemaphoreDeviceIndices", optional = true)..uint32_t("waitSemaphoreCount", "")
    uint32_t.const.p("pWaitSemaphoreDeviceIndices", "")
    AutoSize("pCommandBufferDeviceMasks", optional = true)..uint32_t("commandBufferCount", "")
    uint32_t.const.p("pCommandBufferDeviceMasks", "")
    AutoSize("pSignalSemaphoreDeviceIndices", optional = true)..uint32_t("signalSemaphoreCount", "")
    uint32_t.const.p("pSignalSemaphoreDeviceIndices", "")
}

val VkDeviceGroupBindSparseInfoKHR = struct(Module.VULKAN, "VkDeviceGroupBindSparseInfoKHR", alias = VkDeviceGroupBindSparseInfo) {
    documentation = "See ##VkDeviceGroupBindSparseInfo."

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("resourceDeviceIndex", "")
    uint32_t("memoryDeviceIndex", "")
}

val VkBindBufferMemoryDeviceGroupInfoKHR = struct(Module.VULKAN, "VkBindBufferMemoryDeviceGroupInfoKHR", alias = VkBindBufferMemoryDeviceGroupInfo) {
    documentation = "See ##VkBindBufferMemoryDeviceGroupInfo."

    Expression("#STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pDeviceIndices", optional = true)..uint32_t("deviceIndexCount", "")
    uint32_t.const.p("pDeviceIndices", "")
}

val VkBindImageMemoryDeviceGroupInfoKHR = struct(Module.VULKAN, "VkBindImageMemoryDeviceGroupInfoKHR", alias = VkBindImageMemoryDeviceGroupInfo) {
    documentation = "See ##VkBindImageMemoryDeviceGroupInfo."

    Expression("#STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pDeviceIndices", optional = true)..uint32_t("deviceIndexCount", "")
    uint32_t.const.p("pDeviceIndices", "")
    AutoSize("pSplitInstanceBindRegions", optional = true)..uint32_t("splitInstanceBindRegionCount", "")
    VkRect2D.const.p("pSplitInstanceBindRegions", "")
}

val VkValidationFlagsEXT = struct(Module.VULKAN, "VkValidationFlagsEXT") {
    documentation =
        """
        Specify validation checks to disable for a Vulkan instance.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VALIDATION_FLAGS_EXT</li>
            <li>{@code pDisabledValidationChecks} <b>must</b> be a valid pointer to an array of {@code disabledValidationCheckCount} valid {@code VkValidationCheckEXT} values</li>
            <li>{@code disabledValidationCheckCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VALIDATION_FLAGS_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pDisabledValidationChecks")..uint32_t("disabledValidationCheckCount", "the number of checks to disable.")
    VkValidationCheckEXT.const.p("pDisabledValidationChecks", "a pointer to an array of {@code VkValidationCheckEXT} values specifying the validation checks to be disabled.")
}

val VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT", alias = VkPhysicalDeviceTextureCompressionASTCHDRFeatures) {
    documentation = "See ##VkPhysicalDeviceTextureCompressionASTCHDRFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("textureCompressionASTC_HDR", "")
}

val VkImageViewASTCDecodeModeEXT = struct(Module.VULKAN, "VkImageViewASTCDecodeModeEXT") {
    documentation =
        """
        Structure describing the ASTC decode mode for an image view.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code decodeMode} <b>must</b> be one of #FORMAT_R16G16B16A16_SFLOAT, #FORMAT_R8G8B8A8_UNORM, or #FORMAT_E5B9G9R9_UFLOAT_PACK32</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-astc-decodeModeSharedExponent">{@code decodeModeSharedExponent}</a> feature is not enabled, {@code decodeMode} <b>must</b> not be #FORMAT_E5B9G9R9_UFLOAT_PACK32</li>
            <li>If {@code decodeMode} is #FORMAT_R8G8B8A8_UNORM the image view <b>must</b> not include blocks using any of the ASTC HDR modes</li>
            <li>{@code format} of the image view <b>must</b> be one of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#appendix-compressedtex-astc">ASTC Compressed Image Formats</a></li>
        </ul>

        If {@code format} uses sRGB encoding then the {@code decodeMode} has no effect.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT</li>
            <li>{@code decodeMode} <b>must</b> be a valid {@code VkFormat} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFormat("decodeMode", "the intermediate format used to decode ASTC compressed formats.")
}

val VkPhysicalDeviceASTCDecodeFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceASTCDecodeFeaturesEXT") {
    documentation =
        """
        Structure describing ASTC decode mode features.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceASTCDecodeFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceASTCDecodeFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("decodeModeSharedExponent", "indicates whether the implementation supports decoding ASTC compressed formats to #FORMAT_E5B9G9R9_UFLOAT_PACK32 internal precision.")
}

val VkPhysicalDevicePipelineRobustnessFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePipelineRobustnessFeaturesEXT") {
    documentation =
        """
        Structure describing whether an implementation supports robustness requests on a per-pipeline stage granularity.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Enabling <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineRobustness">{@code pipelineRobustness}</a> may, on some platforms, incur a minor performance cost when <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustBufferAccess">{@code robustBufferAccess}</a> is disabled, even for pipelines which do not make use of any robustness features. If robustness is not needed, <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineRobustness">{@code pipelineRobustness}</a> should not be enabled by an application.
        </div>

        If the ##VkPhysicalDevicePipelineRobustnessFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePipelineRobustnessFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("pipelineRobustness", "indicates that robustness <b>can</b> be requested on a per-pipeline-stage granularity.")
}

val VkPhysicalDevicePipelineRobustnessPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDevicePipelineRobustnessPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing the default robustness behavior of a physical device.

        <h5>Description</h5>
        Some implementations of Vulkan may be able to guarantee that certain types of accesses are always performed with robustness even when the Vulkan API’s robustness features are not explicitly enabled.

        Even when an implementation reports that accesses to a given resource type are robust by default, it remains invalid to make an out of bounds access without requesting the appropriate robustness feature.

        If the ##VkPhysicalDevicePipelineRobustnessPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkPipelineRobustnessBufferBehaviorEXT("defaultRobustnessStorageBuffers", "describes the behaviour of out of bounds accesses made to storage buffers when no robustness features are enabled")
    VkPipelineRobustnessBufferBehaviorEXT("defaultRobustnessUniformBuffers", "describes the behaviour of out of bounds accesses made to uniform buffers when no robustness features are enabled")
    VkPipelineRobustnessBufferBehaviorEXT("defaultRobustnessVertexInputs", "describes the behaviour of out of bounds accesses made to vertex input attributes when no robustness features are enabled")
    VkPipelineRobustnessImageBehaviorEXT("defaultRobustnessImages", "describes the behaviour of out of bounds accesses made to images when no robustness features are enabled")
}

val VkPipelineRobustnessCreateInfoEXT = struct(Module.VULKAN, "VkPipelineRobustnessCreateInfoEXT") {
    documentation =
        """
        Structure controlling the robustness of a newly created pipeline shader stage.

        <h5>Description</h5>
        Resources bound as #DESCRIPTOR_TYPE_MUTABLE_EXT will have the robustness behavior that covers its active descriptor type.

        The scope of the effect of ##VkPipelineRobustnessCreateInfoEXT depends on which structure’s {@code pNext} chain it is included in.

        <ul>
            <li>##VkGraphicsPipelineCreateInfo, ##VkRayTracingPipelineCreateInfoKHR, ##VkComputePipelineCreateInfo: The robustness behavior described by ##VkPipelineRobustnessCreateInfoEXT applies to all accesses through this pipeline</li>
            <li>##VkPipelineShaderStageCreateInfo: The robustness behavior described by ##VkPipelineRobustnessCreateInfoEXT applies to all accesses emanating from the shader code of this shader stage</li>
        </ul>

        If ##VkPipelineRobustnessCreateInfoEXT is specified for both a pipeline and a pipeline stage, the ##VkPipelineRobustnessCreateInfoEXT specified for the pipeline stage will take precedence.

        When ##VkPipelineRobustnessCreateInfoEXT is specified for a pipeline, it only affects the subset of the pipeline that is specified by the create info, as opposed to subsets linked from pipeline libraries. For ##VkGraphicsPipelineCreateInfo, that subset is specified by ##VkGraphicsPipelineLibraryCreateInfoEXT{@code ::flags}. For ##VkRayTracingPipelineCreateInfoKHR, that subset is specified by the specific stages in ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages}.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineRobustness">{@code pipelineRobustness}</a> feature is not enabled, {@code storageBuffers} <b>must</b> be #PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineRobustness">{@code pipelineRobustness}</a> feature is not enabled, {@code uniformBuffers} <b>must</b> be #PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineRobustness">{@code pipelineRobustness}</a> feature is not enabled, {@code vertexInputs} <b>must</b> be #PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineRobustness">{@code pipelineRobustness}</a> feature is not enabled, {@code images} <b>must</b> be #PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustImageAccess">{@code robustImageAccess}</a> feature is not supported, {@code images} <b>must</b> not be #PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustBufferAccess2">{@code robustBufferAccess2}</a> feature is not supported, {@code storageBuffers} <b>must</b> not be #PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustBufferAccess2">{@code robustBufferAccess2}</a> feature is not supported, {@code uniformBuffers} <b>must</b> not be #PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustBufferAccess2">{@code robustBufferAccess2}</a> feature is not supported, {@code vertexInputs} <b>must</b> not be #PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustImageAccess2">{@code robustImageAccess2}</a> feature is not supported, {@code images} <b>must</b> not be #PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT</li>
            <li>{@code storageBuffers} <b>must</b> be a valid {@code VkPipelineRobustnessBufferBehaviorEXT} value</li>
            <li>{@code uniformBuffers} <b>must</b> be a valid {@code VkPipelineRobustnessBufferBehaviorEXT} value</li>
            <li>{@code vertexInputs} <b>must</b> be a valid {@code VkPipelineRobustnessBufferBehaviorEXT} value</li>
            <li>{@code images} <b>must</b> be a valid {@code VkPipelineRobustnessImageBehaviorEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineRobustnessBufferBehaviorEXT("storageBuffers", """sets the behaviour of out of bounds accesses made to resources bound as:

        <ul>
            <li>#DESCRIPTOR_TYPE_STORAGE_BUFFER</li>
            <li>#DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</li>
            <li>#DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</li>
        </ul>""")
    VkPipelineRobustnessBufferBehaviorEXT("uniformBuffers", """describes the behaviour of out of bounds accesses made to resources bound as:

        <ul>
            <li>#DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</li>
            <li>#DESCRIPTOR_TYPE_UNIFORM_BUFFER</li>
            <li>#DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</li>
            <li>#DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</li>
        </ul>""")
    VkPipelineRobustnessBufferBehaviorEXT("vertexInputs", "describes the behaviour of out of bounds accesses made to vertex input attributes")
    VkPipelineRobustnessImageBehaviorEXT("images", """describes the behaviour of out of bounds accesses made to resources bound as:

        <ul>
            <li>#DESCRIPTOR_TYPE_SAMPLED_IMAGE</li>
            <li>#DESCRIPTOR_TYPE_STORAGE_IMAGE</li>
        </ul>""")
}

val VkPhysicalDeviceGroupPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceGroupPropertiesKHR", mutable = false, alias = VkPhysicalDeviceGroupProperties) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation = "See ##VkPhysicalDeviceGroupProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("physicalDeviceCount", "")
    VkPhysicalDevice("physicalDevices", "")["VK_MAX_DEVICE_GROUP_SIZE"]
    VkBool32("subsetAllocation", "")
}

val VkDeviceGroupDeviceCreateInfoKHR = struct(Module.VULKAN, "VkDeviceGroupDeviceCreateInfoKHR", alias = VkDeviceGroupDeviceCreateInfo) {
    documentation = "See ##VkDeviceGroupDeviceCreateInfo."

    Expression("#STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pPhysicalDevices", optional = true)..uint32_t("physicalDeviceCount", "")
    VkPhysicalDevice.const.p("pPhysicalDevices", "")
}

val VkExternalMemoryPropertiesKHR = struct(Module.VULKAN, "VkExternalMemoryPropertiesKHR", mutable = false, alias = VkExternalMemoryProperties) {
    documentation = "See ##VkExternalMemoryProperties."

    VkExternalMemoryFeatureFlags("externalMemoryFeatures", "")
    VkExternalMemoryHandleTypeFlags("exportFromImportedHandleTypes", "")
    VkExternalMemoryHandleTypeFlags("compatibleHandleTypes", "")
}

val VkPhysicalDeviceExternalImageFormatInfoKHR = struct(Module.VULKAN, "VkPhysicalDeviceExternalImageFormatInfoKHR", alias = VkPhysicalDeviceExternalImageFormatInfo) {
    documentation = "See ##VkPhysicalDeviceExternalImageFormatInfo."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalMemoryHandleTypeFlagBits("handleType", "")
}

val VkExternalImageFormatPropertiesKHR = struct(Module.VULKAN, "VkExternalImageFormatPropertiesKHR", mutable = false, alias = VkExternalImageFormatProperties) {
    documentation = "See ##VkExternalImageFormatProperties."

    Expression("#STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkExternalMemoryProperties("externalMemoryProperties", "")
}

val VkPhysicalDeviceExternalBufferInfoKHR = struct(Module.VULKAN, "VkPhysicalDeviceExternalBufferInfoKHR", alias = VkPhysicalDeviceExternalBufferInfo) {
    documentation = "See ##VkPhysicalDeviceExternalBufferInfo."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBufferCreateFlags("flags", "")
    VkBufferUsageFlags("usage", "")
    VkExternalMemoryHandleTypeFlagBits("handleType", "")
}

val VkExternalBufferPropertiesKHR = struct(Module.VULKAN, "VkExternalBufferPropertiesKHR", mutable = false, alias = VkExternalBufferProperties) {
    documentation = "See ##VkExternalBufferProperties."

    Expression("#STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkExternalMemoryProperties("externalMemoryProperties", "")
}

val VkPhysicalDeviceIDPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceIDPropertiesKHR", mutable = false, alias = VkPhysicalDeviceIDProperties) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation = "See ##VkPhysicalDeviceIDProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint8_t("deviceUUID", "")["VK_UUID_SIZE"]
    uint8_t("driverUUID", "")["VK_UUID_SIZE"]
    uint8_t("deviceLUID", "")["VK_LUID_SIZE"]
    uint32_t("deviceNodeMask", "")
    VkBool32("deviceLUIDValid", "")
}

val VkExternalMemoryImageCreateInfoKHR = struct(Module.VULKAN, "VkExternalMemoryImageCreateInfoKHR", alias = VkExternalMemoryImageCreateInfo) {
    documentation = "See ##VkExternalMemoryImageCreateInfo."

    Expression("#STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalMemoryHandleTypeFlags("handleTypes", "")
}

val VkExternalMemoryBufferCreateInfoKHR = struct(Module.VULKAN, "VkExternalMemoryBufferCreateInfoKHR", alias = VkExternalMemoryBufferCreateInfo) {
    documentation = "See ##VkExternalMemoryBufferCreateInfo."

    Expression("#STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalMemoryHandleTypeFlags("handleTypes", "")
}

val VkExportMemoryAllocateInfoKHR = struct(Module.VULKAN, "VkExportMemoryAllocateInfoKHR", alias = VkExportMemoryAllocateInfo) {
    documentation = "See ##VkExportMemoryAllocateInfo."

    Expression("#STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalMemoryHandleTypeFlags("handleTypes", "")
}

val VkImportMemoryWin32HandleInfoKHR = struct(Module.VULKAN, "VkImportMemoryWin32HandleInfoKHR") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Import Win32 memory created on the same physical device.

        <h5>Description</h5>
        Importing memory object payloads from Windows handles does not transfer ownership of the handle to the Vulkan implementation. For handle types defined as NT handles, the application <b>must</b> release handle ownership using the {@code CloseHandle} system call when the handle is no longer needed. For handle types defined as NT handles, the imported memory object holds a reference to its payload.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Non-NT handle import operations do not add a reference to their associated payload. If the original object owning the payload is destroyed, all resources and handles sharing that payload will become invalid.
        </div>

        Applications <b>can</b> import the same payload into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance. In all cases, each import operation <b>must</b> create a distinct {@code VkDeviceMemory} object.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code handleType} is not 0, it <b>must</b> be supported for import, as reported by ##VkExternalImageFormatProperties or ##VkExternalBufferProperties</li>
            <li>The memory from which {@code handle} was exported, or the memory named by {@code name} <b>must</b> have been created on the same underlying physical device as {@code device}</li>
            <li>If {@code handleType} is not 0, it <b>must</b> be defined as an NT handle or a global share handle</li>
            <li>If {@code handleType} is not #EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, #EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, #EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or #EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, {@code name} <b>must</b> be {@code NULL}</li>
            <li>If {@code handleType} is not 0 and {@code handle} is {@code NULL}, {@code name} <b>must</b> name a valid memory resource of the type specified by {@code handleType}</li>
            <li>If {@code handleType} is not 0 and {@code name} is {@code NULL}, {@code handle} <b>must</b> be a valid handle of the type specified by {@code handleType}</li>
            <li>If {@code handle} is not {@code NULL}, {@code name} <b>must</b> be {@code NULL}</li>
            <li>If {@code handle} is not {@code NULL}, it <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-memory-handle-types-compatibility">external memory handle types compatibility</a></li>
            <li>If {@code name} is not {@code NULL}, it <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-memory-handle-types-compatibility">external memory handle types compatibility</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR</li>
            <li>If {@code handleType} is not 0, {@code handleType} <b>must</b> be a valid {@code VkExternalMemoryHandleTypeFlagBits} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExternalMemoryHandleTypeFlagBits("handleType", "a {@code VkExternalMemoryHandleTypeFlagBits} value specifying the type of {@code handle} or {@code name}.")
    HANDLE("handle", "{@code NULL} or the external handle to import.")
    LPCWSTR("name", "{@code NULL} or a null-terminated UTF-16 string naming the payload to import.")
}

val VkExportMemoryWin32HandleInfoKHR = struct(Module.VULKAN, "VkExportMemoryWin32HandleInfoKHR") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Structure specifying additional attributes of Windows handles exported from a memory.

        <h5>Description</h5>
        If ##VkExportMemoryAllocateInfo is not included in the same {@code pNext} chain, this structure is ignored.

        If ##VkExportMemoryAllocateInfo is included in the {@code pNext} chain of ##VkMemoryAllocateInfo with a Windows {@code handleType}, but either ##VkExportMemoryWin32HandleInfoKHR is not included in the {@code pNext} chain, or it is included but {@code pAttributes} is set to {@code NULL}, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “{@code Synchronization Object Security and Access Rights}”<sup>1</sup>. Further, if the structure is not present, the access rights used depend on the handle type.

        For handles of the following types:

        <ul>
            <li>#EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT</li>
        </ul>

        The implementation <b>must</b> ensure the access rights allow read and write access to the memory.

        <dl>
            <dt>1</dt>
            <dd><a href="https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights</a></dd>
        </dl>

        <h5>Valid Usage</h5>
        <ul>
            <li>If ##VkExportMemoryAllocateInfo{@code ::handleTypes} does not include #EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, a ##VkExportMemoryWin32HandleInfoKHR structure <b>must</b> not be included in the {@code pNext} chain of ##VkMemoryAllocateInfo</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR</li>
            <li>If {@code pAttributes} is not {@code NULL}, {@code pAttributes} <b>must</b> be a valid pointer to a valid {@code SECURITY_ATTRIBUTES} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    nullable..SECURITY_ATTRIBUTES.const.p("pAttributes", "a pointer to a Windows {@code SECURITY_ATTRIBUTES} structure specifying security attributes of the handle.")
    DWORD("dwAccess", "a {@code DWORD} specifying access rights of the handle.")
    LPCWSTR("name", "a null-terminated UTF-16 string to associate with the payload referenced by NT handles exported from the created memory.")
}

val VkMemoryWin32HandlePropertiesKHR = struct(Module.VULKAN, "VkMemoryWin32HandlePropertiesKHR", mutable = false) {
    documentation =
        """
        Properties of External Memory Windows Handles.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetMemoryWin32HandlePropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("memoryTypeBits", "a bitmask containing one bit set for every memory type which the specified windows handle <b>can</b> be imported as.")
}

val VkMemoryGetWin32HandleInfoKHR = struct(Module.VULKAN, "VkMemoryGetWin32HandleInfoKHR") {
    documentation =
        """
        Structure describing a Win32 handle memory export operation.

        <h5>Description</h5>
        The properties of the handle returned depend on the value of {@code handleType}. See {@code VkExternalMemoryHandleTypeFlagBits} for a description of the properties of the defined external memory handle types.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> have been included in ##VkExportMemoryAllocateInfo{@code ::handleTypes} when {@code memory} was created</li>
            <li>If {@code handleType} is defined as an NT handle, #GetMemoryWin32HandleKHR() <b>must</b> be called no more than once for each valid unique combination of {@code memory} and {@code handleType}</li>
            <li>{@code handleType} <b>must</b> be defined as an NT handle or a global share handle</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalMemoryHandleTypeFlagBits} value</li>
        </ul>

        <h5>See Also</h5>
        #GetMemoryWin32HandleKHR()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceMemory("memory", "the memory object from which the handle will be exported.")
    VkExternalMemoryHandleTypeFlagBits("handleType", "a {@code VkExternalMemoryHandleTypeFlagBits} value specifying the type of handle requested.")
}

val VkImportMemoryFdInfoKHR = struct(Module.VULKAN, "VkImportMemoryFdInfoKHR") {
    documentation =
        """
        Import memory created on the same physical device from a file descriptor.

        <h5>Description</h5>
        Importing memory from a file descriptor transfers ownership of the file descriptor from the application to the Vulkan implementation. The application <b>must</b> not perform any operations on the file descriptor after a successful import. The imported memory object holds a reference to its payload.

        Applications <b>can</b> import the same payload into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance. In all cases, each import operation <b>must</b> create a distinct {@code VkDeviceMemory} object.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code handleType} is not 0, it <b>must</b> be supported for import, as reported by ##VkExternalImageFormatProperties or ##VkExternalBufferProperties</li>
            <li>The memory from which {@code fd} was exported <b>must</b> have been created on the same underlying physical device as {@code device}</li>
            <li>If {@code handleType} is not 0, it <b>must</b> be #EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT or #EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT</li>
            <li>If {@code handleType} is not 0, {@code fd} <b>must</b> be a valid handle of the type specified by {@code handleType}</li>
            <li>The memory represented by {@code fd} <b>must</b> have been created from a physical device and driver that is compatible with {@code device} and {@code handleType}, as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-memory-handle-types-compatibility">External memory handle types compatibility</a></li>
            <li>{@code fd} <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-memory-handle-types-compatibility">external memory handle types compatibility</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR</li>
            <li>If {@code handleType} is not 0, {@code handleType} <b>must</b> be a valid {@code VkExternalMemoryHandleTypeFlagBits} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExternalMemoryHandleTypeFlagBits("handleType", "a {@code VkExternalMemoryHandleTypeFlagBits} value specifying the handle type of {@code fd}.")
    int("fd", "the external handle to import.")
}

val VkMemoryFdPropertiesKHR = struct(Module.VULKAN, "VkMemoryFdPropertiesKHR", mutable = false) {
    documentation =
        """
        Properties of External Memory File Descriptors.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetMemoryFdPropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("memoryTypeBits", "a bitmask containing one bit set for every memory type which the specified file descriptor <b>can</b> be imported as.")
}

val VkMemoryGetFdInfoKHR = struct(Module.VULKAN, "VkMemoryGetFdInfoKHR") {
    documentation =
        """
        Structure describing a POSIX FD memory export operation.

        <h5>Description</h5>
        The properties of the file descriptor exported depend on the value of {@code handleType}. See {@code VkExternalMemoryHandleTypeFlagBits} for a description of the properties of the defined external memory handle types.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The size of the exported file <b>may</b> be larger than the size requested by ##VkMemoryAllocateInfo{@code ::allocationSize}. If {@code handleType} is #EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT, then the application <b>can</b> query the file’s actual size with <a href="https://man7.org/linux/man-pages/man2/lseek.2.html">{@code lseek}</a>.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> have been included in ##VkExportMemoryAllocateInfo{@code ::handleTypes} when {@code memory} was created</li>
            <li>{@code handleType} <b>must</b> be #EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT or #EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalMemoryHandleTypeFlagBits} value</li>
        </ul>

        <h5>See Also</h5>
        #GetMemoryFdKHR()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceMemory("memory", "the memory object from which the handle will be exported.")
    VkExternalMemoryHandleTypeFlagBits("handleType", "a {@code VkExternalMemoryHandleTypeFlagBits} value specifying the type of handle requested.")
}

val VkWin32KeyedMutexAcquireReleaseInfoKHR = struct(Module.VULKAN, "VkWin32KeyedMutexAcquireReleaseInfoKHR") {
    documentation =
        """
        Use the Windows keyed mutex mechanism to synchronize work.

        <h5>Valid Usage</h5>
        <ul>
            <li>Each member of {@code pAcquireSyncs} and {@code pReleaseSyncs} <b>must</b> be a device memory object imported by setting ##VkImportMemoryWin32HandleInfoKHR{@code ::handleType} to #EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT or #EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR</li>
            <li>If {@code acquireCount} is not 0, {@code pAcquireSyncs} <b>must</b> be a valid pointer to an array of {@code acquireCount} valid {@code VkDeviceMemory} handles</li>
            <li>If {@code acquireCount} is not 0, {@code pAcquireKeys} <b>must</b> be a valid pointer to an array of {@code acquireCount} {@code uint64_t} values</li>
            <li>If {@code acquireCount} is not 0, {@code pAcquireTimeouts} <b>must</b> be a valid pointer to an array of {@code acquireCount} {@code uint32_t} values</li>
            <li>If {@code releaseCount} is not 0, {@code pReleaseSyncs} <b>must</b> be a valid pointer to an array of {@code releaseCount} valid {@code VkDeviceMemory} handles</li>
            <li>If {@code releaseCount} is not 0, {@code pReleaseKeys} <b>must</b> be a valid pointer to an array of {@code releaseCount} {@code uint64_t} values</li>
            <li>Both of the elements of {@code pAcquireSyncs}, and the elements of {@code pReleaseSyncs} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pAcquireSyncs", "pAcquireKeys", "pAcquireTimeouts", optional = true)..uint32_t("acquireCount", "the number of entries in the {@code pAcquireSyncs}, {@code pAcquireKeys}, and {@code pAcquireTimeouts} arrays.")
    VkDeviceMemory.const.p("pAcquireSyncs", "a pointer to an array of {@code VkDeviceMemory} objects which were imported from Direct3D 11 resources.")
    uint64_t.const.p("pAcquireKeys", "a pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in {@code pAcquireSyncs}.")
    uint32_t.const.p("pAcquireTimeouts", "a pointer to an array of timeout values, in millisecond units, for each acquire specified in {@code pAcquireKeys}.")
    AutoSize("pReleaseSyncs", "pReleaseKeys", optional = true)..uint32_t("releaseCount", "the number of entries in the {@code pReleaseSyncs} and {@code pReleaseKeys} arrays.")
    VkDeviceMemory.const.p("pReleaseSyncs", "a pointer to an array of {@code VkDeviceMemory} objects which were imported from Direct3D 11 resources.")
    uint64_t.const.p("pReleaseKeys", "a pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in {@code pReleaseSyncs}.")
}

val VkPhysicalDeviceExternalSemaphoreInfoKHR = struct(Module.VULKAN, "VkPhysicalDeviceExternalSemaphoreInfoKHR", alias = VkPhysicalDeviceExternalSemaphoreInfo) {
    documentation = "See ##VkPhysicalDeviceExternalSemaphoreInfo."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalSemaphoreHandleTypeFlagBits("handleType", "")
}

val VkExternalSemaphorePropertiesKHR = struct(Module.VULKAN, "VkExternalSemaphorePropertiesKHR", mutable = false, alias = VkExternalSemaphoreProperties) {
    documentation = "See ##VkExternalSemaphoreProperties."

    Expression("#STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkExternalSemaphoreHandleTypeFlags("exportFromImportedHandleTypes", "")
    VkExternalSemaphoreHandleTypeFlags("compatibleHandleTypes", "")
    VkExternalSemaphoreFeatureFlags("externalSemaphoreFeatures", "")
}

val VkExportSemaphoreCreateInfoKHR = struct(Module.VULKAN, "VkExportSemaphoreCreateInfoKHR", alias = VkExportSemaphoreCreateInfo) {
    documentation = "See ##VkExportSemaphoreCreateInfo."

    Expression("#STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalSemaphoreHandleTypeFlags("handleTypes", "")
}

val VkImportSemaphoreWin32HandleInfoKHR = struct(Module.VULKAN, "VkImportSemaphoreWin32HandleInfoKHR") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Structure specifying Windows handle to import to a semaphore.

        <h5>Description</h5>
        The handle types supported by {@code handleType} are:

        <h6>Handle Types Supported by ##VkImportSemaphoreWin32HandleInfoKHR</h6>
        <table class="lwjgl">
            <thead><tr><th>Handle Type</th><th>Transference</th><th>Permanence Supported</th></tr></thead>
            <tbody>
                <tr><td>#EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT</td><td>Reference</td><td>Temporary,Permanent</td></tr>
                <tr><td>#EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT</td><td>Reference</td><td>Temporary,Permanent</td></tr>
                <tr><td>#EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT</td><td>Reference</td><td>Temporary,Permanent</td></tr>
            </tbody>
        </table>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> be a value included in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphore-handletypes-win32">Handle Types Supported by ##VkImportSemaphoreWin32HandleInfoKHR</a> table</li>
            <li>If {@code handleType} is not #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or #EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, {@code name} <b>must</b> be {@code NULL}</li>
            <li>If {@code handle} is {@code NULL}, {@code name} <b>must</b> name a valid synchronization primitive of the type specified by {@code handleType}</li>
            <li>If {@code name} is {@code NULL}, {@code handle} <b>must</b> be a valid handle of the type specified by {@code handleType}</li>
            <li>If {@code handle} is not {@code NULL}, {@code name} <b>must</b> be {@code NULL}</li>
            <li>If {@code handle} is not {@code NULL}, it <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-semaphore-handle-types-compatibility">external semaphore handle types compatibility</a></li>
            <li>If {@code name} is not {@code NULL}, it <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-semaphore-handle-types-compatibility">external semaphore handle types compatibility</a></li>
            <li>If {@code handleType} is #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, the ##VkSemaphoreCreateInfo{@code ::flags} field <b>must</b> match that of the semaphore from which {@code handle} or {@code name} was exported</li>
            <li>If {@code handleType} is #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, the ##VkSemaphoreTypeCreateInfo{@code ::semaphoreType} field <b>must</b> match that of the semaphore from which {@code handle} or {@code name} was exported</li>
            <li>If {@code flags} contains #SEMAPHORE_IMPORT_TEMPORARY_BIT, the ##VkSemaphoreTypeCreateInfo{@code ::semaphoreType} field of the semaphore from which {@code handle} or {@code name} was exported <b>must</b> not be #SEMAPHORE_TYPE_TIMELINE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code semaphore} <b>must</b> be a valid {@code VkSemaphore} handle</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkSemaphoreImportFlagBits} values</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code semaphore} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #ImportSemaphoreWin32HandleKHR()
        """

    Expression("#STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSemaphore("semaphore", "the semaphore into which the payload will be imported.")
    VkSemaphoreImportFlags("flags", "a bitmask of {@code VkSemaphoreImportFlagBits} specifying additional parameters for the semaphore payload import operation.")
    VkExternalSemaphoreHandleTypeFlagBits("handleType", "a {@code VkExternalSemaphoreHandleTypeFlagBits} value specifying the type of {@code handle}.")
    HANDLE("handle", "{@code NULL} or the external handle to import.")
    LPCWSTR("name", "{@code NULL} or a null-terminated UTF-16 string naming the underlying synchronization primitive to import.")
}

val VkExportSemaphoreWin32HandleInfoKHR = struct(Module.VULKAN, "VkExportSemaphoreWin32HandleInfoKHR") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Structure specifying additional attributes of Windows handles exported from a semaphore.

        <h5>Description</h5>
        If ##VkExportSemaphoreCreateInfo is not included in the same {@code pNext} chain, this structure is ignored.

        If ##VkExportSemaphoreCreateInfo is included in the {@code pNext} chain of ##VkSemaphoreCreateInfo with a Windows {@code handleType}, but either ##VkExportSemaphoreWin32HandleInfoKHR is not included in the {@code pNext} chain, or it is included but {@code pAttributes} is set to {@code NULL}, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “{@code Synchronization Object Security and Access Rights}”<sup>1</sup>. Further, if the structure is not present, the access rights used depend on the handle type.

        For handles of the following types:

        #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT

        The implementation <b>must</b> ensure the access rights allow both signal and wait operations on the semaphore.

        For handles of the following types:

        #EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT

        The access rights <b>must</b> be:

        {@code GENERIC_ALL}

        <dl>
            <dt>1</dt>
            <dd><a href="https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights</a></dd>
        </dl>

        <h5>Valid Usage</h5>
        <ul>
            <li>If ##VkExportSemaphoreCreateInfo{@code ::handleTypes} does not include #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or #EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, ##VkExportSemaphoreWin32HandleInfoKHR <b>must</b> not be included in the {@code pNext} chain of ##VkSemaphoreCreateInfo</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR</li>
            <li>If {@code pAttributes} is not {@code NULL}, {@code pAttributes} <b>must</b> be a valid pointer to a valid {@code SECURITY_ATTRIBUTES} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    nullable..SECURITY_ATTRIBUTES.const.p("pAttributes", "a pointer to a Windows {@code SECURITY_ATTRIBUTES} structure specifying security attributes of the handle.")
    DWORD("dwAccess", "a {@code DWORD} specifying access rights of the handle.")
    LPCWSTR("name", "a null-terminated UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created semaphore.")
}

val VkD3D12FenceSubmitInfoKHR = struct(Module.VULKAN, "VkD3D12FenceSubmitInfoKHR") {
    documentation =
        """
        Structure specifying values for Direct3D 12 fence-backed semaphores.

        <h5>Description</h5>
        If the semaphore in ##VkSubmitInfo{@code ::pWaitSemaphores} or ##VkSubmitInfo{@code ::pSignalSemaphores} corresponding to an entry in {@code pWaitSemaphoreValues} or {@code pSignalSemaphoreValues} respectively does not currently have a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-payloads">payload</a> referring to a Direct3D 12 fence, the implementation <b>must</b> ignore the value in the {@code pWaitSemaphoreValues} or {@code pSignalSemaphoreValues} entry.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        As the introduction of the external semaphore handle type #EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT predates that of timeline semaphores, support for importing semaphore payloads from external handles of that type into semaphores created (implicitly or explicitly) with a {@code VkSemaphoreType} of #SEMAPHORE_TYPE_BINARY is preserved for backwards compatibility. However, applications <b>should</b> prefer importing such handle types into semaphores created with a {@code VkSemaphoreType} of #SEMAPHORE_TYPE_TIMELINE, and use the ##VkTimelineSemaphoreSubmitInfo structure instead of the ##VkD3D12FenceSubmitInfoKHR structure to specify the values to use when waiting for and signaling such semaphores.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code waitSemaphoreValuesCount} <b>must</b> be the same value as ##VkSubmitInfo{@code ::waitSemaphoreCount}, where this structure is in the {@code pNext} chain of a ##VkSubmitInfo structure</li>
            <li>{@code signalSemaphoreValuesCount} <b>must</b> be the same value as ##VkSubmitInfo{@code ::signalSemaphoreCount}, where this structure is in the {@code pNext} chain of a ##VkSubmitInfo structure</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR</li>
            <li>If {@code waitSemaphoreValuesCount} is not 0, and {@code pWaitSemaphoreValues} is not {@code NULL}, {@code pWaitSemaphoreValues} <b>must</b> be a valid pointer to an array of {@code waitSemaphoreValuesCount} {@code uint64_t} values</li>
            <li>If {@code signalSemaphoreValuesCount} is not 0, and {@code pSignalSemaphoreValues} is not {@code NULL}, {@code pSignalSemaphoreValues} <b>must</b> be a valid pointer to an array of {@code signalSemaphoreValuesCount} {@code uint64_t} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pWaitSemaphoreValues", optional = true)..uint32_t("waitSemaphoreValuesCount", "the number of semaphore wait values specified in {@code pWaitSemaphoreValues}.")
    nullable..uint64_t.const.p("pWaitSemaphoreValues", "a pointer to an array of {@code waitSemaphoreValuesCount} values for the corresponding semaphores in ##VkSubmitInfo{@code ::pWaitSemaphores} to wait for.")
    AutoSize("pSignalSemaphoreValues", optional = true)..uint32_t("signalSemaphoreValuesCount", "the number of semaphore signal values specified in {@code pSignalSemaphoreValues}.")
    nullable..uint64_t.const.p("pSignalSemaphoreValues", "a pointer to an array of {@code signalSemaphoreValuesCount} values for the corresponding semaphores in ##VkSubmitInfo{@code ::pSignalSemaphores} to set when signaled.")
}

val VkSemaphoreGetWin32HandleInfoKHR = struct(Module.VULKAN, "VkSemaphoreGetWin32HandleInfoKHR") {
    documentation =
        """
        Structure describing a Win32 handle semaphore export operation.

        <h5>Description</h5>
        The properties of the handle returned depend on the value of {@code handleType}. See {@code VkExternalSemaphoreHandleTypeFlagBits} for a description of the properties of the defined external semaphore handle types.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> have been included in ##VkExportSemaphoreCreateInfo{@code ::handleTypes} when the {@code semaphore}’s current payload was created</li>
            <li>If {@code handleType} is defined as an NT handle, #GetSemaphoreWin32HandleKHR() <b>must</b> be called no more than once for each valid unique combination of {@code semaphore} and {@code handleType}</li>
            <li>{@code semaphore} <b>must</b> not currently have its payload replaced by an imported payload as described below in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-importing">Importing Semaphore Payloads</a> unless that imported payload’s handle type was included in ##VkExternalSemaphoreProperties{@code ::exportFromImportedHandleTypes} for {@code handleType}</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, as defined below in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-importing">Importing Semaphore Payloads</a>, there <b>must</b> be no queue waiting on {@code semaphore}</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code semaphore} <b>must</b> be signaled, or have an associated <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-signaling">semaphore signal operation</a> pending execution</li>
            <li>{@code handleType} <b>must</b> be defined as an NT handle or a global share handle</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code semaphore} <b>must</b> be a valid {@code VkSemaphore} handle</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalSemaphoreHandleTypeFlagBits} value</li>
        </ul>

        <h5>See Also</h5>
        #GetSemaphoreWin32HandleKHR()
        """

    Expression("#STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSemaphore("semaphore", "the semaphore from which state will be exported.")
    VkExternalSemaphoreHandleTypeFlagBits("handleType", "a {@code VkExternalSemaphoreHandleTypeFlagBits} value specifying the type of handle requested.")
}

val VkImportSemaphoreFdInfoKHR = struct(Module.VULKAN, "VkImportSemaphoreFdInfoKHR") {
    documentation =
        """
        Structure specifying POSIX file descriptor to import to a semaphore.

        <h5>Description</h5>
        The handle types supported by {@code handleType} are:

        <h6>Handle Types Supported by ##VkImportSemaphoreFdInfoKHR</h6>
        <table class="lwjgl">
            <thead><tr><th>Handle Type</th><th>Transference</th><th>Permanence Supported</th></tr></thead>
            <tbody>
                <tr><td>#EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT</td><td>Reference</td><td>Temporary,Permanent</td></tr>
                <tr><td>#EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT</td><td>Copy</td><td>Temporary</td></tr>
            </tbody>
        </table>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> be a value included in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphore-handletypes-fd">Handle Types Supported by ##VkImportSemaphoreFdInfoKHR</a> table</li>
            <li>{@code fd} <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-semaphore-handle-types-compatibility">external semaphore handle types compatibility</a></li>
            <li>If {@code handleType} is #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT, the ##VkSemaphoreCreateInfo{@code ::flags} field <b>must</b> match that of the semaphore from which {@code fd} was exported</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code flags} <b>must</b> contain #SEMAPHORE_IMPORT_TEMPORARY_BIT</li>
            <li>If {@code handleType} is #EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT, the ##VkSemaphoreTypeCreateInfo{@code ::semaphoreType} field <b>must</b> match that of the semaphore from which {@code fd} was exported</li>
            <li>If {@code flags} contains #SEMAPHORE_IMPORT_TEMPORARY_BIT, the ##VkSemaphoreTypeCreateInfo{@code ::semaphoreType} field of the semaphore from which {@code fd} was exported <b>must</b> not be #SEMAPHORE_TYPE_TIMELINE</li>
        </ul>

        If {@code handleType} is #EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT, the special value {@code -1} for {@code fd} is treated like a valid sync file descriptor referring to an object that has already signaled. The import operation will succeed and the {@code VkSemaphore} will have a temporarily imported payload as if a valid file descriptor had been provided.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        This special behavior for importing an invalid sync file descriptor allows easier interoperability with other system APIs which use the convention that an invalid sync file descriptor represents work that has already completed and does not need to be waited for. It is consistent with the option for implementations to return a {@code -1} file descriptor when exporting a #EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT from a {@code VkSemaphore} which is signaled.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code semaphore} <b>must</b> be a valid {@code VkSemaphore} handle</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkSemaphoreImportFlagBits} values</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalSemaphoreHandleTypeFlagBits} value</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code semaphore} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #ImportSemaphoreFdKHR()
        """

    Expression("#STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSemaphore("semaphore", "the semaphore into which the payload will be imported.")
    VkSemaphoreImportFlags("flags", "a bitmask of {@code VkSemaphoreImportFlagBits} specifying additional parameters for the semaphore payload import operation.")
    VkExternalSemaphoreHandleTypeFlagBits("handleType", "a {@code VkExternalSemaphoreHandleTypeFlagBits} value specifying the type of {@code fd}.")
    int("fd", "the external handle to import.")
}

val VkSemaphoreGetFdInfoKHR = struct(Module.VULKAN, "VkSemaphoreGetFdInfoKHR") {
    documentation =
        """
        Structure describing a POSIX FD semaphore export operation.

        <h5>Description</h5>
        The properties of the file descriptor returned depend on the value of {@code handleType}. See {@code VkExternalSemaphoreHandleTypeFlagBits} for a description of the properties of the defined external semaphore handle types.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> have been included in ##VkExportSemaphoreCreateInfo{@code ::handleTypes} when {@code semaphore}’s current payload was created</li>
            <li>{@code semaphore} <b>must</b> not currently have its payload replaced by an imported payload as described below in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-importing">Importing Semaphore Payloads</a> unless that imported payload’s handle type was included in ##VkExternalSemaphoreProperties{@code ::exportFromImportedHandleTypes} for {@code handleType}</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, as defined below in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-importing">Importing Semaphore Payloads</a>, there <b>must</b> be no queue waiting on {@code semaphore}</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code semaphore} <b>must</b> be signaled, or have an associated <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-signaling">semaphore signal operation</a> pending execution</li>
            <li>{@code handleType} <b>must</b> be defined as a POSIX file descriptor handle</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code semaphore} <b>must</b> have been created with a {@code VkSemaphoreType} of #SEMAPHORE_TYPE_BINARY</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code semaphore} <b>must</b> have an associated semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends (if any) <b>must</b> have also been submitted for execution</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code semaphore} <b>must</b> be a valid {@code VkSemaphore} handle</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalSemaphoreHandleTypeFlagBits} value</li>
        </ul>

        <h5>See Also</h5>
        #GetSemaphoreFdKHR()
        """

    Expression("#STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSemaphore("semaphore", "the semaphore from which state will be exported.")
    VkExternalSemaphoreHandleTypeFlagBits("handleType", "a {@code VkExternalSemaphoreHandleTypeFlagBits} value specifying the type of handle requested.")
}

val VkPhysicalDevicePushDescriptorPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDevicePushDescriptorPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing push descriptor limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePushDescriptorPropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxPushDescriptors", "the maximum number of descriptors that <b>can</b> be used in a descriptor set layout created with #DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set.")
}

val VkConditionalRenderingBeginInfoEXT = struct(Module.VULKAN, "VkConditionalRenderingBeginInfoEXT") {
    documentation =
        """
        Structure specifying conditional rendering begin information.

        <h5>Description</h5>
        If the 32-bit value at {@code offset} in {@code buffer} memory is zero, then the rendering commands are discarded, otherwise they are executed as normal. If the value of the predicate in buffer memory changes while conditional rendering is active, the rendering commands <b>may</b> be discarded in an implementation-dependent way. Some implementations may latch the value of the predicate upon beginning conditional rendering while others may read it before every rendering command.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code buffer} is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>{@code buffer} <b>must</b> have been created with the #BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set</li>
            <li>{@code offset} <b>must</b> be less than the size of {@code buffer} by at least 32 bits</li>
            <li>{@code offset} <b>must</b> be a multiple of 4</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code buffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkConditionalRenderingFlagBitsEXT} values</li>
        </ul>

        <h5>See Also</h5>
        #CmdBeginConditionalRenderingEXT()
        """

    Expression("#STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBuffer("buffer", "a buffer containing the predicate for conditional rendering.")
    VkDeviceSize("offset", "the byte offset into {@code buffer} where the predicate is located.")
    VkConditionalRenderingFlagsEXT("flags", "a bitmask of {@code VkConditionalRenderingFlagsEXT} specifying the behavior of conditional rendering.")
}

val VkPhysicalDeviceConditionalRenderingFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceConditionalRenderingFeaturesEXT") {
    documentation =
        """
        Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceConditionalRenderingFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("conditionalRendering", "specifies whether conditional rendering is supported.")
    VkBool32("inheritedConditionalRendering", "specifies whether a secondary command buffer <b>can</b> be executed while conditional rendering is active in the primary command buffer.")
}

val VkCommandBufferInheritanceConditionalRenderingInfoEXT = struct(Module.VULKAN, "VkCommandBufferInheritanceConditionalRenderingInfoEXT") {
    documentation =
        """
        Structure specifying command buffer inheritance information.

        <h5>Description</h5>
        If this structure is not present, the behavior is as if {@code conditionalRenderingEnable} is #FALSE.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-inheritedConditionalRendering">{@code inheritedConditionalRendering}</a> feature is not enabled, {@code conditionalRenderingEnable} <b>must</b> be #FALSE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("conditionalRenderingEnable", "specifies whether the command buffer <b>can</b> be executed while conditional rendering is active in the primary command buffer. If this is #TRUE, then this command buffer <b>can</b> be executed whether the primary command buffer has active conditional rendering or not. If this is #FALSE, then the primary command buffer <b>must</b> not have conditional rendering active.")
}

val VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR", alias = VkPhysicalDeviceShaderFloat16Int8Features) {
    documentation = "See ##VkPhysicalDeviceShaderFloat16Int8Features."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderFloat16", "")
    VkBool32("shaderInt8", "")
}

val VkPhysicalDeviceFloat16Int8FeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceFloat16Int8FeaturesKHR", alias = VkPhysicalDeviceShaderFloat16Int8Features) {
    documentation = "See ##VkPhysicalDeviceShaderFloat16Int8Features."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderFloat16", "")
    VkBool32("shaderInt8", "")
}

val VkPhysicalDevice16BitStorageFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDevice16BitStorageFeaturesKHR", alias = VkPhysicalDevice16BitStorageFeatures) {
    documentation = "See ##VkPhysicalDevice16BitStorageFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("storageBuffer16BitAccess", "")
    VkBool32("uniformAndStorageBuffer16BitAccess", "")
    VkBool32("storagePushConstant16", "")
    VkBool32("storageInputOutput16", "")
}

val VkRectLayerKHR = struct(Module.VULKAN, "VkRectLayerKHR") {
    documentation =
        """
        Structure containing a rectangle, including layer, changed by vkQueuePresentKHR for a given VkImage.

        <h5>Description</h5>
        Some platforms allow the size of a surface to change, and then scale the pixels of the image to fit the surface. ##VkRectLayerKHR specifies pixels of the swapchain’s image(s), which will be constant for the life of the swapchain.

        <h5>Valid Usage</h5>
        <ul>
            <li>The sum of {@code offset} and {@code extent}, after being transformed according to the {@code preTransform} member of the ##VkSwapchainCreateInfoKHR structure, <b>must</b> be no greater than the {@code imageExtent} member of the ##VkSwapchainCreateInfoKHR structure passed to #CreateSwapchainKHR()</li>
            <li>{@code layer} <b>must</b> be less than the {@code imageArrayLayers} member of the ##VkSwapchainCreateInfoKHR structure passed to #CreateSwapchainKHR()</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, ##VkOffset2D, ##VkPresentRegionKHR
        """

    VkOffset2D("offset", "the origin of the rectangle, in pixels.")
    VkExtent2D("extent", "the size of the rectangle, in pixels.")
    uint32_t("layer", "the layer of the image. For images with only one layer, the value of {@code layer} <b>must</b> be 0.")
}

val VkPresentRegionKHR = struct(Module.VULKAN, "VkPresentRegionKHR") {
    documentation =
        """
        Structure containing rectangular region changed by vkQueuePresentKHR for a given VkImage.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>If {@code rectangleCount} is not 0, and {@code pRectangles} is not {@code NULL}, {@code pRectangles} <b>must</b> be a valid pointer to an array of {@code rectangleCount} valid ##VkRectLayerKHR structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkPresentRegionsKHR, ##VkRectLayerKHR
        """

    AutoSize("pRectangles", optional = true)..uint32_t("rectangleCount", "the number of rectangles in {@code pRectangles}, or zero if the entire image has changed and should be presented.")
    nullable..VkRectLayerKHR.const.p("pRectangles", "either {@code NULL} or a pointer to an array of ##VkRectLayerKHR structures. The ##VkRectLayerKHR structure is the framebuffer coordinates, plus layer, of a portion of a presentable image that has changed and <b>must</b> be presented. If non-{@code NULL}, each entry in {@code pRectangles} is a rectangle of the given image that has changed since the last image was presented to the given swapchain. The rectangles <b>must</b> be specified relative to ##VkSurfaceCapabilitiesKHR{@code ::currentTransform}, regardless of the swapchain’s {@code preTransform}. The presentation engine will apply the {@code preTransform} transformation to the rectangles, along with any further transformation it applies to the image content.")
}

val VkPresentRegionsKHR = struct(Module.VULKAN, "VkPresentRegionsKHR") {
    documentation =
        """
        Structure hint of rectangular regions changed by vkQueuePresentKHR.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code swapchainCount} <b>must</b> be the same value as ##VkPresentInfoKHR{@code ::swapchainCount}, where ##VkPresentInfoKHR is included in the {@code pNext} chain of this ##VkPresentRegionsKHR structure</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PRESENT_REGIONS_KHR</li>
            <li>If {@code pRegions} is not {@code NULL}, {@code pRegions} <b>must</b> be a valid pointer to an array of {@code swapchainCount} valid ##VkPresentRegionKHR structures</li>
            <li>{@code swapchainCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkPresentRegionKHR
        """

    Expression("#STRUCTURE_TYPE_PRESENT_REGIONS_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pRegions", optional = true)..uint32_t("swapchainCount", "the number of swapchains being presented to by this command.")
    nullable..VkPresentRegionKHR.const.p("pRegions", "{@code NULL} or a pointer to an array of ##VkPresentRegionKHR elements with {@code swapchainCount} entries. If not {@code NULL}, each element of {@code pRegions} contains the region that has changed since the last present to the swapchain in the corresponding entry in the ##VkPresentInfoKHR{@code ::pSwapchains} array.")
}

val VkDescriptorUpdateTemplateEntryKHR = struct(Module.VULKAN, "VkDescriptorUpdateTemplateEntryKHR", alias = VkDescriptorUpdateTemplateEntry) {
    documentation = "See ##VkDescriptorUpdateTemplateEntry."

    uint32_t("dstBinding", "")
    uint32_t("dstArrayElement", "")
    uint32_t("descriptorCount", "")
    VkDescriptorType("descriptorType", "")
    size_t("offset", "")
    size_t("stride", "")
}

val VkDescriptorUpdateTemplateCreateInfoKHR = struct(Module.VULKAN, "VkDescriptorUpdateTemplateCreateInfoKHR", alias = VkDescriptorUpdateTemplateCreateInfo) {
    documentation = "See ##VkDescriptorUpdateTemplateCreateInfo."

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkDescriptorUpdateTemplateCreateFlags("flags", "")
    AutoSize("pDescriptorUpdateEntries")..uint32_t("descriptorUpdateEntryCount", "")
    VkDescriptorUpdateTemplateEntry.const.p("pDescriptorUpdateEntries", "")
    VkDescriptorUpdateTemplateType("templateType", "")
    VkDescriptorSetLayout("descriptorSetLayout", "")
    VkPipelineBindPoint("pipelineBindPoint", "")
    VkPipelineLayout("pipelineLayout", "")
    uint32_t("set", "")
}

val VkViewportWScalingNV = struct(Module.VULKAN, "VkViewportWScalingNV") {
    documentation =
        """
        Structure specifying a viewport.

        <h5>See Also</h5>
        ##VkPipelineViewportWScalingStateCreateInfoNV, #CmdSetViewportWScalingNV()
        """

    float("xcoeff", "{@code xcoeff} and {@code ycoeff} are the viewport’s W scaling factor for x and y respectively.")
    float("ycoeff", "see {@code xcoeff}")
}

val VkPipelineViewportWScalingStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineViewportWScalingStateCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters of a newly created pipeline viewport W scaling state.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV</li>
            <li>{@code viewportCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkViewportWScalingNV
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("viewportWScalingEnable", "controls whether viewport <b>W</b> scaling is enabled.")
    AutoSize("pViewportWScalings", optional = true)..uint32_t("viewportCount", "the number of viewports used by <b>W</b> scaling, and <b>must</b> match the number of viewports in the pipeline if viewport <b>W</b> scaling is enabled.")
    nullable..VkViewportWScalingNV.const.p("pViewportWScalings", "a pointer to an array of ##VkViewportWScalingNV structures defining the <b>W</b> scaling parameters for the corresponding viewports. If the viewport <b>W</b> scaling state is dynamic, this member is ignored.")
}

val VkSurfaceCapabilities2EXT = struct(Module.VULKAN, "VkSurfaceCapabilities2EXT", mutable = false) {
    documentation =
        """
        Structure describing capabilities of a surface.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code supportedSurfaceCounters} <b>must</b> not include #SURFACE_COUNTER_VBLANK_BIT_EXT unless the surface queried is a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#wsi-display-surfaces">display surface</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, #GetPhysicalDeviceSurfaceCapabilities2EXT()
        """

    Expression("#STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("minImageCount", "the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.")
    uint32_t("maxImageCount", "the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to {@code minImageCount}. A value of 0 means that there is no limit on the number of images, though there <b>may</b> be limits related to the total amount of memory used by presentable images.")
    VkExtent2D("currentExtent", "the current width and height of the surface, or the special value <code>(0xFFFFFFFF, 0xFFFFFFFF)</code> indicating that the surface size will be determined by the extent of a swapchain targeting the surface.")
    VkExtent2D("minImageExtent", "contains the smallest valid swapchain extent for the surface on the specified device. The {@code width} and {@code height} of the extent will each be less than or equal to the corresponding {@code width} and {@code height} of {@code currentExtent}, unless {@code currentExtent} has the special value described above.")
    VkExtent2D("maxImageExtent", "contains the largest valid swapchain extent for the surface on the specified device. The {@code width} and {@code height} of the extent will each be greater than or equal to the corresponding {@code width} and {@code height} of {@code minImageExtent}. The {@code width} and {@code height} of the extent will each be greater than or equal to the corresponding {@code width} and {@code height} of {@code currentExtent}, unless {@code currentExtent} has the special value described above.")
    uint32_t("maxImageArrayLayers", "the maximum number of layers presentable images <b>can</b> have for a swapchain created for this device and surface, and will be at least one.")
    VkSurfaceTransformFlagsKHR("supportedTransforms", "a bitmask of {@code VkSurfaceTransformFlagBitsKHR} indicating the presentation transforms supported for the surface on the specified device. At least one bit will be set.")
    VkSurfaceTransformFlagBitsKHR("currentTransform", "{@code VkSurfaceTransformFlagBitsKHR} value indicating the surface’s current transform relative to the presentation engine’s natural orientation.")
    VkCompositeAlphaFlagsKHR("supportedCompositeAlpha", "a bitmask of {@code VkCompositeAlphaFlagBitsKHR}, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition <b>can</b> be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.")
    VkImageUsageFlags("supportedUsageFlags", "a bitmask of {@code VkImageUsageFlagBits} representing the ways the application <b>can</b> use the presentable images of a swapchain created with {@code VkPresentModeKHR} set to #PRESENT_MODE_IMMEDIATE_KHR, #PRESENT_MODE_MAILBOX_KHR, #PRESENT_MODE_FIFO_KHR or #PRESENT_MODE_FIFO_RELAXED_KHR for the surface on the specified device. #IMAGE_USAGE_COLOR_ATTACHMENT_BIT <b>must</b> be included in the set. Implementations <b>may</b> support additional usages.")
    VkSurfaceCounterFlagsEXT("supportedSurfaceCounters", "a bitmask of {@code VkSurfaceCounterFlagBitsEXT} indicating the supported surface counter types.")
}

val VkDisplayPowerInfoEXT = struct(Module.VULKAN, "VkDisplayPowerInfoEXT") {
    documentation =
        """
        Describe the power state of a display.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code powerState} <b>must</b> be a valid {@code VkDisplayPowerStateEXT} value</li>
        </ul>

        <h5>See Also</h5>
        #DisplayPowerControlEXT()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDisplayPowerStateEXT("powerState", "a {@code VkDisplayPowerStateEXT} value specifying the new power state of the display.")
}

val VkDeviceEventInfoEXT = struct(Module.VULKAN, "VkDeviceEventInfoEXT") {
    documentation =
        """
        Describe a device event to create.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code deviceEvent} <b>must</b> be a valid {@code VkDeviceEventTypeEXT} value</li>
        </ul>

        <h5>See Also</h5>
        #RegisterDeviceEventEXT()
        """

    Expression("#STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceEventTypeEXT("deviceEvent", "")
}

val VkDisplayEventInfoEXT = struct(Module.VULKAN, "VkDisplayEventInfoEXT") {
    documentation =
        """
        Describe a display event to create.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code displayEvent} <b>must</b> be a valid {@code VkDisplayEventTypeEXT} value</li>
        </ul>

        <h5>See Also</h5>
        #RegisterDisplayEventEXT()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDisplayEventTypeEXT("displayEvent", "a {@code VkDisplayEventTypeEXT} specifying when the fence will be signaled.")
}

val VkSwapchainCounterCreateInfoEXT = struct(Module.VULKAN, "VkSwapchainCounterCreateInfoEXT") {
    documentation =
        """
        Specify the surface counters desired.

        <h5>Valid Usage</h5>
        <ul>
            <li>The bits in {@code surfaceCounters} <b>must</b> be supported by ##VkSwapchainCreateInfoKHR{@code ::surface}, as reported by #GetPhysicalDeviceSurfaceCapabilities2EXT()</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT</li>
            <li>{@code surfaceCounters} <b>must</b> be a valid combination of {@code VkSurfaceCounterFlagBitsEXT} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSurfaceCounterFlagsEXT("surfaceCounters", "a bitmask of {@code VkSurfaceCounterFlagBitsEXT} specifying surface counters to enable for the swapchain.")
}

val VkRefreshCycleDurationGOOGLE = struct(Module.VULKAN, "VkRefreshCycleDurationGOOGLE", mutable = false) {
    documentation =
        """
        Structure containing the RC duration of a display.

        <h5>See Also</h5>
        #GetRefreshCycleDurationGOOGLE()
        """

    uint64_t("refreshDuration", "the number of nanoseconds from the start of one refresh cycle to the next.")
}

val VkPastPresentationTimingGOOGLE = struct(Module.VULKAN, "VkPastPresentationTimingGOOGLE", mutable = false) {
    documentation =
        """
        Structure containing timing information about a previously-presented image.

        <h5>Description</h5>
        The results for a given {@code swapchain} and {@code presentID} are only returned once from {@code vkGetPastPresentationTimingGOOGLE}.

        The application <b>can</b> use the ##VkPastPresentationTimingGOOGLE values to occasionally adjust its timing. For example, if {@code actualPresentTime} is later than expected (e.g. one {@code refreshDuration} late), the application may increase its target IPD to a higher multiple of {@code refreshDuration} (e.g. decrease its frame rate from 60Hz to 30Hz). If {@code actualPresentTime} and {@code earliestPresentTime} are consistently different, and if {@code presentMargin} is consistently large enough, the application may decrease its target IPD to a smaller multiple of {@code refreshDuration} (e.g. increase its frame rate from 30Hz to 60Hz). If {@code actualPresentTime} and {@code earliestPresentTime} are same, and if {@code presentMargin} is consistently high, the application may delay the start of its input-render-present loop in order to decrease the latency between user input and the corresponding present (always leaving some margin in case a new image takes longer to render than the previous image). An application that desires its target IPD to always be the same as {@code refreshDuration}, can also adjust features until {@code actualPresentTime} is never late and {@code presentMargin} is satisfactory.

        <h5>See Also</h5>
        #GetPastPresentationTimingGOOGLE()
        """

    uint32_t("presentID", "an application-provided value that was given to a previous {@code vkQueuePresentKHR} command via ##VkPresentTimeGOOGLE{@code ::presentID} (see below). It <b>can</b> be used to uniquely identify a previous present with the #QueuePresentKHR() command.")
    uint64_t("desiredPresentTime", "an application-provided value that was given to a previous #QueuePresentKHR() command via ##VkPresentTimeGOOGLE{@code ::desiredPresentTime}. If non-zero, it was used by the application to indicate that an image not be presented any sooner than {@code desiredPresentTime}.")
    uint64_t("actualPresentTime", "the time when the image of the {@code swapchain} was actually displayed.")
    uint64_t("earliestPresentTime", "the time when the image of the {@code swapchain} could have been displayed. This <b>may</b> differ from {@code actualPresentTime} if the application requested that the image be presented no sooner than ##VkPresentTimeGOOGLE{@code ::desiredPresentTime}.")
    uint64_t("presentMargin", "an indication of how early the {@code vkQueuePresentKHR} command was processed compared to how soon it needed to be processed, and still be presented at {@code earliestPresentTime}.")
}

val VkPresentTimeGOOGLE = struct(Module.VULKAN, "VkPresentTimeGOOGLE") {
    documentation =
        """
        The earliest time image should be presented.

        <h5>See Also</h5>
        ##VkPresentTimesInfoGOOGLE
        """

    uint32_t("presentID", "an application-provided identification value, that <b>can</b> be used with the results of #GetPastPresentationTimingGOOGLE(), in order to uniquely identify this present. In order to be useful to the application, it <b>should</b> be unique within some period of time that is meaningful to the application.")
    uint64_t("desiredPresentTime", "specifies that the image given <b>should</b> not be displayed to the user any earlier than this time. {@code desiredPresentTime} is a time in nanoseconds, relative to a monotonically-increasing clock (e.g. {@code CLOCK_MONOTONIC} (see clock_gettime(2)) on Android and Linux). A value of zero specifies that the presentation engine <b>may</b> display the image at any time. This is useful when the application desires to provide {@code presentID}, but does not need a specific {@code desiredPresentTime}.")
}

val VkPresentTimesInfoGOOGLE = struct(Module.VULKAN, "VkPresentTimesInfoGOOGLE") {
    documentation =
        """
        The earliest time each image should be presented.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code swapchainCount} <b>must</b> be the same value as ##VkPresentInfoKHR{@code ::swapchainCount}, where ##VkPresentInfoKHR is included in the {@code pNext} chain of this ##VkPresentTimesInfoGOOGLE structure</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE</li>
            <li>If {@code pTimes} is not {@code NULL}, {@code pTimes} <b>must</b> be a valid pointer to an array of {@code swapchainCount} ##VkPresentTimeGOOGLE structures</li>
            <li>{@code swapchainCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkPresentTimeGOOGLE
        """

    Expression("#STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pTimes", optional = true)..uint32_t("swapchainCount", "the number of swapchains being presented to by this command.")
    nullable..VkPresentTimeGOOGLE.const.p("pTimes", "{@code NULL} or a pointer to an array of ##VkPresentTimeGOOGLE elements with {@code swapchainCount} entries. If not {@code NULL}, each element of {@code pTimes} contains the earliest time to present the image corresponding to the entry in the ##VkPresentInfoKHR{@code ::pImageIndices} array.")
}

val VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = struct(Module.VULKAN, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", mutable = false) {
    documentation =
        """
        Structure describing multiview limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("perViewPositionAllComponents", "#TRUE if the implementation supports per-view position values that differ in components other than the X component.")
}

val VkViewportSwizzleNV = struct(Module.VULKAN, "VkViewportSwizzleNV") {
    documentation =
        """
        Structure specifying a viewport swizzle.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code x} <b>must</b> be a valid {@code VkViewportCoordinateSwizzleNV} value</li>
            <li>{@code y} <b>must</b> be a valid {@code VkViewportCoordinateSwizzleNV} value</li>
            <li>{@code z} <b>must</b> be a valid {@code VkViewportCoordinateSwizzleNV} value</li>
            <li>{@code w} <b>must</b> be a valid {@code VkViewportCoordinateSwizzleNV} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkPipelineViewportSwizzleStateCreateInfoNV, #CmdSetViewportSwizzleNV()
        """

    VkViewportCoordinateSwizzleNV("x", "a {@code VkViewportCoordinateSwizzleNV} value specifying the swizzle operation to apply to the x component of the primitive")
    VkViewportCoordinateSwizzleNV("y", "a {@code VkViewportCoordinateSwizzleNV} value specifying the swizzle operation to apply to the y component of the primitive")
    VkViewportCoordinateSwizzleNV("z", "a {@code VkViewportCoordinateSwizzleNV} value specifying the swizzle operation to apply to the z component of the primitive")
    VkViewportCoordinateSwizzleNV("w", "a {@code VkViewportCoordinateSwizzleNV} value specifying the swizzle operation to apply to the w component of the primitive")
}

val VkPipelineViewportSwizzleStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineViewportSwizzleStateCreateInfoNV") {
    documentation =
        """
        Structure specifying swizzle applied to primitive clip coordinates.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code viewportCount} <b>must</b> be greater than or equal to the {@code viewportCount} set in ##VkPipelineViewportStateCreateInfo</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code pViewportSwizzles} <b>must</b> be a valid pointer to an array of {@code viewportCount} valid ##VkViewportSwizzleNV structures</li>
            <li>{@code viewportCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkViewportSwizzleNV
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineViewportSwizzleStateCreateFlagsNV("flags", "reserved for future use.")
    AutoSize("pViewportSwizzles")..uint32_t("viewportCount", "the number of viewport swizzles used by the pipeline.")
    VkViewportSwizzleNV.const.p("pViewportSwizzles", "a pointer to an array of ##VkViewportSwizzleNV structures, defining the viewport swizzles.")
}

val VkPhysicalDeviceDiscardRectanglePropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDiscardRectanglePropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing discard rectangle limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDiscardRectanglePropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxDiscardRectangles", "the maximum number of active discard rectangles that <b>can</b> be specified.")
}

val VkPipelineDiscardRectangleStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineDiscardRectangleStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying discard rectangle.

        <h5>Description</h5>
        If the #DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state is enabled for a pipeline, the {@code pDiscardRectangles} member is ignored. If the #DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT dynamic state is not enabled for the pipeline the presence of this structure in the ##VkGraphicsPipelineCreateInfo chain, and a {@code discardRectangleCount} greater than zero, implicitly enables discard rectangles in the pipeline, otherwise discard rectangles <b>must</b> enabled or disabled by #CmdSetDiscardRectangleEnableEXT(). If the #DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT dynamic state is enabled for the pipeline, the {@code discardRectangleMode} member is ignored, and the discard rectangle mode <b>must</b> be set by #CmdSetDiscardRectangleModeEXT().

        When this structure is included in the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo, it defines parameters of the discard rectangle test. If the #DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state is not enabled, and this structure is not included in the {@code pNext} chain, it is equivalent to specifying this structure with a {@code discardRectangleCount} of 0.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code discardRectangleCount} <b>must</b> be less than or equal to ##VkPhysicalDeviceDiscardRectanglePropertiesEXT{@code ::maxDiscardRectangles}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code discardRectangleMode} <b>must</b> be a valid {@code VkDiscardRectangleModeEXT} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkRect2D
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineDiscardRectangleStateCreateFlagsEXT("flags", "reserved for future use.")
    VkDiscardRectangleModeEXT("discardRectangleMode", "a {@code VkDiscardRectangleModeEXT} value determining whether the discard rectangle test is inclusive or exclusive.")
    AutoSize("pDiscardRectangles", optional = true)..uint32_t("discardRectangleCount", "the number of discard rectangles to use.")
    nullable..VkRect2D.const.p("pDiscardRectangles", "a pointer to an array of ##VkRect2D structures defining discard rectangles.")
}

val VkPhysicalDeviceConservativeRasterizationPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing conservative raster properties that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    float("primitiveOverestimationSize", "the size in pixels the generating primitive is increased at each of its edges during conservative rasterization overestimation mode. Even with a size of 0.0, conservative rasterization overestimation rules still apply and if any part of the pixel rectangle is covered by the generating primitive, fragments are generated for the entire pixel. However implementations <b>may</b> make the pixel coverage area even more conservative by increasing the size of the generating primitive.")
    float("maxExtraPrimitiveOverestimationSize", "the maximum size in pixels of extra overestimation the implementation supports in the pipeline state. A value of 0.0 means the implementation does not support any additional overestimation of the generating primitive during conservative rasterization. A value above 0.0 allows the application to further increase the size of the generating primitive during conservative rasterization overestimation.")
    float("extraPrimitiveOverestimationSizeGranularity", "the granularity of extra overestimation that can be specified in the pipeline state between 0.0 and {@code maxExtraPrimitiveOverestimationSize} inclusive. A value of 0.0 means the implementation can use the smallest representable non-zero value in the screen space pixel fixed-point grid.")
    VkBool32("primitiveUnderestimation", "#TRUE if the implementation supports the #CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT conservative rasterization mode in addition to #CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT. Otherwise the implementation only supports #CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.")
    VkBool32("conservativePointAndLineRasterization", "#TRUE if the implementation supports conservative rasterization of point and line primitives as well as triangle primitives. Otherwise the implementation only supports triangle primitives.")
    VkBool32("degenerateTrianglesRasterized", "#FALSE if the implementation culls primitives generated from triangles that become zero area after they are quantized to the fixed-point rasterization pixel grid. {@code degenerateTrianglesRasterized} is #TRUE if these primitives are not culled and the provoking vertex attributes and depth value are used for the fragments. The primitive area calculation is done on the primitive generated from the clipped triangle if applicable. Zero area primitives are backfacing and the application <b>can</b> enable backface culling if desired.")
    VkBool32("degenerateLinesRasterized", "#FALSE if the implementation culls lines that become zero length after they are quantized to the fixed-point rasterization pixel grid. {@code degenerateLinesRasterized} is #TRUE if zero length lines are not culled and the provoking vertex attributes and depth value are used for the fragments.")
    VkBool32("fullyCoveredFragmentShaderInputVariable", "#TRUE if the implementation supports the SPIR-V builtin fragment shader input variable {@code FullyCoveredEXT} specifying that conservative rasterization is enabled and the fragment area is fully covered by the generating primitive.")
    VkBool32("conservativeRasterizationPostDepthCoverage", "#TRUE if the implementation supports conservative rasterization with the {@code PostDepthCoverage} execution mode enabled. Otherwise the {@code PostDepthCoverage} execution mode <b>must</b> not be used when conservative rasterization is enabled.")
}

val VkPipelineRasterizationConservativeStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineRasterizationConservativeStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying conservative raster state.

        <h5>Description</h5>
        If this structure is not included in the {@code pNext} chain, {@code conservativeRasterizationMode} is considered to be #CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT, and and conservative rasterization is disabled.

        Polygon rasterization <b>can</b> be made conservative by setting {@code conservativeRasterizationMode} to #CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT or #CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT in ##VkPipelineRasterizationConservativeStateCreateInfoEXT.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        If <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-conservativePointAndLineRasterization">{@code conservativePointAndLineRasterization}</a> is supported, conservative rasterization can be applied to line and point primitives, otherwise it must be disabled.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code extraPrimitiveOverestimationSize} <b>must</b> be in the range of {@code 0.0} to ##VkPhysicalDeviceConservativeRasterizationPropertiesEXT{@code ::maxExtraPrimitiveOverestimationSize} inclusive</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code conservativeRasterizationMode} <b>must</b> be a valid {@code VkConservativeRasterizationModeEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineRasterizationConservativeStateCreateFlagsEXT("flags", "reserved for future use.")
    VkConservativeRasterizationModeEXT("conservativeRasterizationMode", "the conservative rasterization mode to use.")
    float("extraPrimitiveOverestimationSize", "the extra size in pixels to increase the generating primitive during conservative rasterization at each of its edges in {@code X} and {@code Y} equally in screen space beyond the base overestimation specified in ##VkPhysicalDeviceConservativeRasterizationPropertiesEXT{@code ::primitiveOverestimationSize}. If {@code conservativeRasterizationMode} is not #CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT, this value is ignored.")
}

val VkPhysicalDeviceDepthClipEnableFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDepthClipEnableFeaturesEXT") {
    documentation =
        """
        Structure indicating support for explicit enable of depth clip.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDepthClipEnableFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("depthClipEnable", "indicates that the implementation supports setting the depth clipping operation explicitly via the ##VkPipelineRasterizationDepthClipStateCreateInfoEXT pipeline state. Otherwise depth clipping is only enabled when ##VkPipelineRasterizationStateCreateInfo{@code ::depthClampEnable} is set to #FALSE.")
}

val VkPipelineRasterizationDepthClipStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineRasterizationDepthClipStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying depth clipping state.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineRasterizationDepthClipStateCreateFlagsEXT("flags", "reserved for future use.")
    VkBool32("depthClipEnable", "controls whether depth clipping is enabled as described in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#vertexpostproc-clipping\">Primitive Clipping</a>.")
}

val VkXYColorEXT = struct(Module.VULKAN, "VkXYColorEXT") {
    documentation =
        """
        Specify X,Y chromaticity coordinates.

        <h5>Description</h5>
        Chromaticity coordinates are as specified in CIE 15:2004 “{@code Calculation of chromaticity coordinates}” (Section 7.3) and are limited to between 0 and 1 for real colors for the reference monitor.

        <h5>See Also</h5>
        ##VkHdrMetadataEXT
        """

    float("x", "the <code>x</code> chromaticity coordinate.")
    float("y", "the <code>y</code> chromaticity coordinate.")
}

val VkHdrMetadataEXT = struct(Module.VULKAN, "VkHdrMetadataEXT") {
    documentation =
        """
        Specify Hdr metadata.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_HDR_METADATA_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The validity and use of this data is outside the scope of Vulkan.
        </div>

        <h5>See Also</h5>
        ##VkXYColorEXT, #SetHdrMetadataEXT()
        """

    Expression("#STRUCTURE_TYPE_HDR_METADATA_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkXYColorEXT("displayPrimaryRed", "a ##VkXYColorEXT structure specifying the reference monitor’s red primary in chromaticity coordinates")
    VkXYColorEXT("displayPrimaryGreen", "a ##VkXYColorEXT structure specifying the reference monitor’s green primary in chromaticity coordinates")
    VkXYColorEXT("displayPrimaryBlue", "a ##VkXYColorEXT structure specifying the reference monitor’s blue primary in chromaticity coordinates")
    VkXYColorEXT("whitePoint", "a ##VkXYColorEXT structure specifying the reference monitor’s white-point in chromaticity coordinates")
    float("maxLuminance", "the maximum luminance of the reference monitor in nits")
    float("minLuminance", "the minimum luminance of the reference monitor in nits")
    float("maxContentLightLevel", "content’s maximum luminance in nits")
    float("maxFrameAverageLightLevel", "the maximum frame average light level in nits")
}

val VkPhysicalDeviceImagelessFramebufferFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceImagelessFramebufferFeaturesKHR", alias = VkPhysicalDeviceImagelessFramebufferFeatures) {
    documentation = "See ##VkPhysicalDeviceImagelessFramebufferFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("imagelessFramebuffer", "")
}

val VkFramebufferAttachmentsCreateInfoKHR = struct(Module.VULKAN, "VkFramebufferAttachmentsCreateInfoKHR", alias = VkFramebufferAttachmentsCreateInfo) {
    documentation = "See ##VkFramebufferAttachmentsCreateInfo."

    Expression("#STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pAttachmentImageInfos", optional = true)..uint32_t("attachmentImageInfoCount", "")
    VkFramebufferAttachmentImageInfo.const.p("pAttachmentImageInfos", "")
}

val VkFramebufferAttachmentImageInfoKHR = struct(Module.VULKAN, "VkFramebufferAttachmentImageInfoKHR", alias = VkFramebufferAttachmentImageInfo) {
    documentation = "See ##VkFramebufferAttachmentImageInfo."

    Expression("#STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageCreateFlags("flags", "")
    VkImageUsageFlags("usage", "")
    uint32_t("width", "")
    uint32_t("height", "")
    uint32_t("layerCount", "")
    AutoSize("pViewFormats", optional = true)..uint32_t("viewFormatCount", "")
    VkFormat.const.p("pViewFormats", "")
}

val VkRenderPassAttachmentBeginInfoKHR = struct(Module.VULKAN, "VkRenderPassAttachmentBeginInfoKHR", alias = VkRenderPassAttachmentBeginInfo) {
    documentation = "See ##VkRenderPassAttachmentBeginInfo."

    Expression("#STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pAttachments", optional = true)..uint32_t("attachmentCount", "")
    VkImageView.const.p("pAttachments", "")
}

val VkRenderPassCreateInfo2KHR = struct(Module.VULKAN, "VkRenderPassCreateInfo2KHR", alias = VkRenderPassCreateInfo2) {
    documentation = "See ##VkRenderPassCreateInfo2."

    Expression("#STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkRenderPassCreateFlags("flags", "")
    AutoSize("pAttachments", optional = true)..uint32_t("attachmentCount", "")
    VkAttachmentDescription2.const.p("pAttachments", "")
    AutoSize("pSubpasses")..uint32_t("subpassCount", "")
    VkSubpassDescription2.const.p("pSubpasses", "")
    AutoSize("pDependencies", optional = true)..uint32_t("dependencyCount", "")
    VkSubpassDependency2.const.p("pDependencies", "")
    AutoSize("pCorrelatedViewMasks", optional = true)..uint32_t("correlatedViewMaskCount", "")
    uint32_t.const.p("pCorrelatedViewMasks", "")
}

val VkAttachmentDescription2KHR = struct(Module.VULKAN, "VkAttachmentDescription2KHR", alias = VkAttachmentDescription2) {
    documentation = "See ##VkAttachmentDescription2."

    Expression("#STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkAttachmentDescriptionFlags("flags", "")
    VkFormat("format", "")
    VkSampleCountFlagBits("samples", "")
    VkAttachmentLoadOp("loadOp", "")
    VkAttachmentStoreOp("storeOp", "")
    VkAttachmentLoadOp("stencilLoadOp", "")
    VkAttachmentStoreOp("stencilStoreOp", "")
    VkImageLayout("initialLayout", "")
    VkImageLayout("finalLayout", "")
}

val VkAttachmentReference2KHR = struct(Module.VULKAN, "VkAttachmentReference2KHR", alias = VkAttachmentReference2) {
    documentation = "See ##VkAttachmentReference2."

    Expression("#STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("attachment", "")
    VkImageLayout("layout", "")
    VkImageAspectFlags("aspectMask", "")
}

val VkSubpassDescription2KHR = struct(Module.VULKAN, "VkSubpassDescription2KHR", alias = VkSubpassDescription2) {
    documentation = "See ##VkSubpassDescription2."

    Expression("#STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSubpassDescriptionFlags("flags", "")
    VkPipelineBindPoint("pipelineBindPoint", "")
    uint32_t("viewMask", "")
    AutoSize("pInputAttachments", optional = true)..uint32_t("inputAttachmentCount", "")
    VkAttachmentReference2.const.p("pInputAttachments", "")
    AutoSize("pColorAttachments", "pResolveAttachments", optional = true)..uint32_t("colorAttachmentCount", "")
    VkAttachmentReference2.const.p("pColorAttachments", "")
    nullable..VkAttachmentReference2.const.p("pResolveAttachments", "")
    nullable..VkAttachmentReference2.const.p("pDepthStencilAttachment", "")
    AutoSize("pPreserveAttachments", optional = true)..uint32_t("preserveAttachmentCount", "")
    uint32_t.const.p("pPreserveAttachments", "")
}

val VkSubpassDependency2KHR = struct(Module.VULKAN, "VkSubpassDependency2KHR", alias = VkSubpassDependency2) {
    documentation = "See ##VkSubpassDependency2."

    Expression("#STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("srcSubpass", "")
    uint32_t("dstSubpass", "")
    VkPipelineStageFlags("srcStageMask", "")
    VkPipelineStageFlags("dstStageMask", "")
    VkAccessFlags("srcAccessMask", "")
    VkAccessFlags("dstAccessMask", "")
    VkDependencyFlags("dependencyFlags", "")
    int32_t("viewOffset", "")
}

val VkSubpassBeginInfoKHR = struct(Module.VULKAN, "VkSubpassBeginInfoKHR", alias = VkSubpassBeginInfo) {
    documentation = "See ##VkSubpassBeginInfo."

    Expression("#STRUCTURE_TYPE_SUBPASS_BEGIN_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSubpassContents("contents", "")
}

val VkSubpassEndInfoKHR = struct(Module.VULKAN, "VkSubpassEndInfoKHR", alias = VkSubpassEndInfo) {
    documentation = "See ##VkSubpassEndInfo."

    Expression("#STRUCTURE_TYPE_SUBPASS_END_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
}

val VkSharedPresentSurfaceCapabilitiesKHR = struct(Module.VULKAN, "VkSharedPresentSurfaceCapabilitiesKHR", mutable = false) {
    documentation =
        """
        Structure describing capabilities of a surface for shared presentation.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkImageUsageFlags("sharedPresentSupportedUsageFlags", "a bitmask of {@code VkImageUsageFlagBits} representing the ways the application <b>can</b> use the shared presentable image from a swapchain created with {@code VkPresentModeKHR} set to #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR for the surface on the specified device. #IMAGE_USAGE_COLOR_ATTACHMENT_BIT <b>must</b> be included in the set but implementations <b>may</b> support additional usages.")
}

val VkPhysicalDeviceExternalFenceInfoKHR = struct(Module.VULKAN, "VkPhysicalDeviceExternalFenceInfoKHR", alias = VkPhysicalDeviceExternalFenceInfo) {
    documentation = "See ##VkPhysicalDeviceExternalFenceInfo."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalFenceHandleTypeFlagBits("handleType", "")
}

val VkExternalFencePropertiesKHR = struct(Module.VULKAN, "VkExternalFencePropertiesKHR", mutable = false, alias = VkExternalFenceProperties) {
    documentation = "See ##VkExternalFenceProperties."

    Expression("#STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkExternalFenceHandleTypeFlags("exportFromImportedHandleTypes", "")
    VkExternalFenceHandleTypeFlags("compatibleHandleTypes", "")
    VkExternalFenceFeatureFlags("externalFenceFeatures", "")
}

val VkExportFenceCreateInfoKHR = struct(Module.VULKAN, "VkExportFenceCreateInfoKHR", alias = VkExportFenceCreateInfo) {
    documentation = "See ##VkExportFenceCreateInfo."

    Expression("#STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkExternalFenceHandleTypeFlags("handleTypes", "")
}

val VkImportFenceWin32HandleInfoKHR = struct(Module.VULKAN, "VkImportFenceWin32HandleInfoKHR") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        (None).

        <h5>Description</h5>
        The handle types supported by {@code handleType} are:

        <h6>Handle Types Supported by ##VkImportFenceWin32HandleInfoKHR</h6>
        <table class="lwjgl">
            <thead><tr><th>Handle Type</th><th>Transference</th><th>Permanence Supported</th></tr></thead>
            <tbody>
                <tr><td>#EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT</td><td>Reference</td><td>Temporary,Permanent</td></tr>
                <tr><td>#EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT</td><td>Reference</td><td>Temporary,Permanent</td></tr>
            </tbody>
        </table>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> be a value included in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-fence-handletypes-win32">Handle Types Supported by ##VkImportFenceWin32HandleInfoKHR</a> table</li>
            <li>If {@code handleType} is not #EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, {@code name} <b>must</b> be {@code NULL}</li>
            <li>If {@code handle} is {@code NULL}, {@code name} <b>must</b> name a valid synchronization primitive of the type specified by {@code handleType}</li>
            <li>If {@code name} is {@code NULL}, {@code handle} <b>must</b> be a valid handle of the type specified by {@code handleType}</li>
            <li>If {@code handle} is not {@code NULL}, {@code name} <b>must</b> be {@code NULL}</li>
            <li>If {@code handle} is not {@code NULL}, it <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-fence-handle-types-compatibility">external fence handle types compatibility</a></li>
            <li>If {@code name} is not {@code NULL}, it <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-fence-handle-types-compatibility">external fence handle types compatibility</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code fence} <b>must</b> be a valid {@code VkFence} handle</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkFenceImportFlagBits} values</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code fence} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #ImportFenceWin32HandleKHR()
        """

    Expression("#STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFence("fence", "the fence into which the state will be imported.")
    VkFenceImportFlags("flags", "a bitmask of {@code VkFenceImportFlagBits} specifying additional parameters for the fence payload import operation.")
    VkExternalFenceHandleTypeFlagBits("handleType", "a {@code VkExternalFenceHandleTypeFlagBits} value specifying the type of {@code handle}.")
    HANDLE("handle", "{@code NULL} or the external handle to import.")
    LPCWSTR("name", "{@code NULL} or a null-terminated UTF-16 string naming the underlying synchronization primitive to import.")
}

val VkExportFenceWin32HandleInfoKHR = struct(Module.VULKAN, "VkExportFenceWin32HandleInfoKHR") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Structure specifying additional attributes of Windows handles exported from a fence.

        <h5>Description</h5>
        If ##VkExportFenceCreateInfo is not included in the same {@code pNext} chain, this structure is ignored.

        If ##VkExportFenceCreateInfo is included in the {@code pNext} chain of ##VkFenceCreateInfo with a Windows {@code handleType}, but either ##VkExportFenceWin32HandleInfoKHR is not included in the {@code pNext} chain, or it is included but {@code pAttributes} is set to {@code NULL}, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “{@code Synchronization Object Security and Access Rights}”<sup>1</sup>. Further, if the structure is not present, the access rights will be

        {@code DXGI_SHARED_RESOURCE_READ} | {@code DXGI_SHARED_RESOURCE_WRITE}

        for handles of the following types:

        #EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT

        <dl>
            <dt>1</dt>
            <dd><a href="https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-object-security-and-access-rights</a></dd>
        </dl>

        <h5>Valid Usage</h5>
        <ul>
            <li>If ##VkExportFenceCreateInfo{@code ::handleTypes} does not include #EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, a ##VkExportFenceWin32HandleInfoKHR structure <b>must</b> not be included in the {@code pNext} chain of ##VkFenceCreateInfo</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR</li>
            <li>If {@code pAttributes} is not {@code NULL}, {@code pAttributes} <b>must</b> be a valid pointer to a valid {@code SECURITY_ATTRIBUTES} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    nullable..SECURITY_ATTRIBUTES.const.p("pAttributes", "a pointer to a Windows {@code SECURITY_ATTRIBUTES} structure specifying security attributes of the handle.")
    DWORD("dwAccess", "a {@code DWORD} specifying access rights of the handle.")
    LPCWSTR("name", "a null-terminated UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created fence.")
}

val VkFenceGetWin32HandleInfoKHR = struct(Module.VULKAN, "VkFenceGetWin32HandleInfoKHR") {
    documentation =
        """
        Structure describing a Win32 handle fence export operation.

        <h5>Description</h5>
        The properties of the handle returned depend on the value of {@code handleType}. See {@code VkExternalFenceHandleTypeFlagBits} for a description of the properties of the defined external fence handle types.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> have been included in ##VkExportFenceCreateInfo{@code ::handleTypes} when the {@code fence}’s current payload was created</li>
            <li>If {@code handleType} is defined as an NT handle, #GetFenceWin32HandleKHR() <b>must</b> be called no more than once for each valid unique combination of {@code fence} and {@code handleType}</li>
            <li>{@code fence} <b>must</b> not currently have its payload replaced by an imported payload as described below in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-fences-importing">Importing Fence Payloads</a> unless that imported payload’s handle type was included in ##VkExternalFenceProperties{@code ::exportFromImportedHandleTypes} for {@code handleType}</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code fence} <b>must</b> be signaled, or have an associated <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-fences-signaling">fence signal operation</a> pending execution</li>
            <li>{@code handleType} <b>must</b> be defined as an NT handle or a global share handle</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code fence} <b>must</b> be a valid {@code VkFence} handle</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalFenceHandleTypeFlagBits} value</li>
        </ul>

        <h5>See Also</h5>
        #GetFenceWin32HandleKHR()
        """

    Expression("#STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFence("fence", "the fence from which state will be exported.")
    VkExternalFenceHandleTypeFlagBits("handleType", "a {@code VkExternalFenceHandleTypeFlagBits} value specifying the type of handle requested.")
}

val VkImportFenceFdInfoKHR = struct(Module.VULKAN, "VkImportFenceFdInfoKHR") {
    documentation =
        """
        (None).

        <h5>Description</h5>
        The handle types supported by {@code handleType} are:

        <h6>Handle Types Supported by ##VkImportFenceFdInfoKHR</h6>
        <table class="lwjgl">
            <thead><tr><th>Handle Type</th><th>Transference</th><th>Permanence Supported</th></tr></thead>
            <tbody>
                <tr><td>#EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT</td><td>Reference</td><td>Temporary,Permanent</td></tr>
                <tr><td>#EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT</td><td>Copy</td><td>Temporary</td></tr>
            </tbody>
        </table>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> be a value included in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-fence-handletypes-fd">Handle Types Supported by ##VkImportFenceFdInfoKHR</a> table</li>
            <li>{@code fd} <b>must</b> obey any requirements listed for {@code handleType} in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#external-fence-handle-types-compatibility">external fence handle types compatibility</a></li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code flags} <b>must</b> contain #FENCE_IMPORT_TEMPORARY_BIT</li>
        </ul>

        If {@code handleType} is #EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT, the special value {@code -1} for {@code fd} is treated like a valid sync file descriptor referring to an object that has already signaled. The import operation will succeed and the {@code VkFence} will have a temporarily imported payload as if a valid file descriptor had been provided.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        This special behavior for importing an invalid sync file descriptor allows easier interoperability with other system APIs which use the convention that an invalid sync file descriptor represents work that has already completed and does not need to be waited for. It is consistent with the option for implementations to return a {@code -1} file descriptor when exporting a #EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT from a {@code VkFence} which is signaled.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code fence} <b>must</b> be a valid {@code VkFence} handle</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkFenceImportFlagBits} values</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalFenceHandleTypeFlagBits} value</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code fence} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #ImportFenceFdKHR()
        """

    Expression("#STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFence("fence", "the fence into which the payload will be imported.")
    VkFenceImportFlags("flags", "a bitmask of {@code VkFenceImportFlagBits} specifying additional parameters for the fence payload import operation.")
    VkExternalFenceHandleTypeFlagBits("handleType", "a {@code VkExternalFenceHandleTypeFlagBits} value specifying the type of {@code fd}.")
    int("fd", "the external handle to import.")
}

val VkFenceGetFdInfoKHR = struct(Module.VULKAN, "VkFenceGetFdInfoKHR") {
    documentation =
        """
        Structure describing a POSIX FD fence export operation.

        <h5>Description</h5>
        The properties of the file descriptor returned depend on the value of {@code handleType}. See {@code VkExternalFenceHandleTypeFlagBits} for a description of the properties of the defined external fence handle types.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> have been included in ##VkExportFenceCreateInfo{@code ::handleTypes} when {@code fence}’s current payload was created</li>
            <li>If {@code handleType} refers to a handle type with copy payload transference semantics, {@code fence} <b>must</b> be signaled, or have an associated <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-fences-signaling">fence signal operation</a> pending execution</li>
            <li>{@code fence} <b>must</b> not currently have its payload replaced by an imported payload as described below in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-fences-importing">Importing Fence Payloads</a> unless that imported payload’s handle type was included in ##VkExternalFenceProperties{@code ::exportFromImportedHandleTypes} for {@code handleType}</li>
            <li>{@code handleType} <b>must</b> be defined as a POSIX file descriptor handle</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code fence} <b>must</b> be a valid {@code VkFence} handle</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalFenceHandleTypeFlagBits} value</li>
        </ul>

        <h5>See Also</h5>
        #GetFenceFdKHR()
        """

    Expression("#STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFence("fence", "the fence from which state will be exported.")
    VkExternalFenceHandleTypeFlagBits("handleType", "a {@code VkExternalFenceHandleTypeFlagBits} value specifying the type of handle requested.")
}

val VkPhysicalDevicePerformanceQueryFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDevicePerformanceQueryFeaturesKHR") {
    documentation =
        """
        Structure describing performance query support for an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePerformanceQueryFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePerformanceQueryFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("performanceCounterQueryPools", "indicates whether the implementation supports performance counter query pools.")
    VkBool32("performanceCounterMultipleQueryPools", "indicates whether the implementation supports using multiple performance query pools in a primary command buffer and secondary command buffers executed within it.")
}

val VkPhysicalDevicePerformanceQueryPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDevicePerformanceQueryPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing performance query properties for an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePerformanceQueryPropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("allowCommandBufferQueryCopies", "#TRUE if the performance query pools are allowed to be used with #CmdCopyQueryPoolResults().")
}

val VkPerformanceCounterKHR = struct(Module.VULKAN, "VkPerformanceCounterKHR", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure providing information about a counter.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR()
        """

    Expression("#STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkPerformanceCounterUnitKHR("unit", "a {@code VkPerformanceCounterUnitKHR} specifying the unit that the counter data will record.")
    VkPerformanceCounterScopeKHR("scope", "a {@code VkPerformanceCounterScopeKHR} specifying the scope that the counter belongs to.")
    VkPerformanceCounterStorageKHR("storage", "a {@code VkPerformanceCounterStorageKHR} specifying the storage type that the counter’s data uses.")
    uint8_t("uuid", "an array of size #UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the counter of the physical device.")["VK_UUID_SIZE"]
}

val VkPerformanceCounterDescriptionKHR = struct(Module.VULKAN, "VkPerformanceCounterDescriptionKHR", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure providing more detailed information about a counter.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR()
        """

    Expression("#STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkPerformanceCounterDescriptionFlagsKHR("flags", "a bitmask of {@code VkPerformanceCounterDescriptionFlagBitsKHR} indicating the usage behavior for the counter.")
    charUTF8("name", "an array of size #MAX_DESCRIPTION_SIZE, containing a null-terminated UTF-8 string specifying the name of the counter.")["VK_MAX_DESCRIPTION_SIZE"]
    charUTF8("category", "an array of size #MAX_DESCRIPTION_SIZE, containing a null-terminated UTF-8 string specifying the category of the counter.")["VK_MAX_DESCRIPTION_SIZE"]
    charUTF8("description", "an array of size #MAX_DESCRIPTION_SIZE, containing a null-terminated UTF-8 string specifying the description of the counter.")["VK_MAX_DESCRIPTION_SIZE"]
}

val VkQueryPoolPerformanceCreateInfoKHR = struct(Module.VULKAN, "VkQueryPoolPerformanceCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created performance query pool.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code queueFamilyIndex} <b>must</b> be a valid queue family index of the device</li>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-performanceCounterQueryPools">{@code performanceCounterQueryPools}</a> feature <b>must</b> be enabled</li>
            <li>Each element of {@code pCounterIndices} <b>must</b> be in the range of counters reported by {@code vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR} for the queue family specified in {@code queueFamilyIndex}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR</li>
            <li>{@code pCounterIndices} <b>must</b> be a valid pointer to an array of {@code counterIndexCount} {@code uint32_t} values</li>
            <li>{@code counterIndexCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR()
        """

    Expression("#STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("queueFamilyIndex", "the queue family index to create this performance query pool for.")
    AutoSize("pCounterIndices")..uint32_t("counterIndexCount", "the length of the {@code pCounterIndices} array.")
    uint32_t.const.p("pCounterIndices", "a pointer to an array of indices into the #EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(){@code ::pCounters} to enable in this performance query pool.")
}

val VkPerformanceCounterResultKHR = union(Module.VULKAN, "VkPerformanceCounterResultKHR") {
    documentation =
        """
        Union containing a performance counter result.
        """

    int32_t("int32", "")
    int64_t("int64", "")
    uint32_t("uint32", "")
    uint64_t("uint64", "")
    float("float32", "")
    double("float64", "")
}

val VkAcquireProfilingLockInfoKHR = struct(Module.VULKAN, "VkAcquireProfilingLockInfoKHR") {
    documentation =
        """
        Structure specifying parameters to acquire the profiling lock.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        If {@code timeout} is 0, {@code vkAcquireProfilingLockKHR} will not block while attempting to acquire the profiling lock. If {@code timeout} is {@code UINT64_MAX}, the function will not return until the profiling lock was acquired.

        <h5>See Also</h5>
        #AcquireProfilingLockKHR()
        """

    Expression("#STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAcquireProfilingLockFlagsKHR("flags", "reserved for future use.")
    uint64_t("timeout", "indicates how long the function waits, in nanoseconds, if the profiling lock is not available.")
}

val VkPerformanceQuerySubmitInfoKHR = struct(Module.VULKAN, "VkPerformanceQuerySubmitInfoKHR") {
    documentation =
        """
        Structure indicating which counter pass index is active for performance queries.

        <h5>Description</h5>
        If the ##VkSubmitInfo{@code ::pNext} chain does not include this structure, the batch defaults to use counter pass index 0.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code counterPassIndex} <b>must</b> be less than the number of counter passes required by any queries within the batch. The required number of counter passes for a performance query is obtained by calling #GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR()</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("counterPassIndex", "specifies which counter pass index is active.")
}

val VkPhysicalDevicePointClippingPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDevicePointClippingPropertiesKHR", mutable = false, alias = VkPhysicalDevicePointClippingProperties) {
    documentation = "See ##VkPhysicalDevicePointClippingProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkPointClippingBehavior("pointClippingBehavior", "")
}

val VkRenderPassInputAttachmentAspectCreateInfoKHR = struct(Module.VULKAN, "VkRenderPassInputAttachmentAspectCreateInfoKHR", alias = VkRenderPassInputAttachmentAspectCreateInfo) {
    documentation = "See ##VkRenderPassInputAttachmentAspectCreateInfo."

    Expression("#STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pAspectReferences")..uint32_t("aspectReferenceCount", "")
    VkInputAttachmentAspectReference.const.p("pAspectReferences", "")
}

val VkInputAttachmentAspectReferenceKHR = struct(Module.VULKAN, "VkInputAttachmentAspectReferenceKHR", alias = VkInputAttachmentAspectReference) {
    documentation = "See ##VkInputAttachmentAspectReference."

    uint32_t("subpass", "")
    uint32_t("inputAttachmentIndex", "")
    VkImageAspectFlags("aspectMask", "")
}

val VkImageViewUsageCreateInfoKHR = struct(Module.VULKAN, "VkImageViewUsageCreateInfoKHR", alias = VkImageViewUsageCreateInfo) {
    documentation = "See ##VkImageViewUsageCreateInfo."

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageUsageFlags("usage", "")
}

val VkPipelineTessellationDomainOriginStateCreateInfoKHR = struct(Module.VULKAN, "VkPipelineTessellationDomainOriginStateCreateInfoKHR", alias = VkPipelineTessellationDomainOriginStateCreateInfo) {
    documentation = "See ##VkPipelineTessellationDomainOriginStateCreateInfo."

    Expression("#STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkTessellationDomainOrigin("domainOrigin", "")
}

val VkPhysicalDeviceSurfaceInfo2KHR = struct(Module.VULKAN, "VkPhysicalDeviceSurfaceInfo2KHR") {
    documentation =
        """
        Structure specifying a surface and related swapchain creation parameters.

        <h5>Description</h5>
        The members of ##VkPhysicalDeviceSurfaceInfo2KHR correspond to the arguments to #GetPhysicalDeviceSurfaceCapabilitiesKHR(), with {@code sType} and {@code pNext} added for extensibility.

        Additional capabilities of a surface <b>may</b> be available to swapchains created with different full-screen exclusive settings - particularly if exclusive full-screen access is application controlled. These additional capabilities <b>can</b> be queried by adding a ##VkSurfaceFullScreenExclusiveInfoEXT structure to the {@code pNext} chain of this structure when used to query surface properties. Additionally, for Win32 surfaces with application controlled exclusive full-screen access, chaining a ##VkSurfaceFullScreenExclusiveWin32InfoEXT structure <b>may</b> also report additional surface capabilities. These additional capabilities only apply to swapchains created with the same parameters included in the {@code pNext} chain of ##VkSwapchainCreateInfoKHR.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the {@code pNext} chain includes a ##VkSurfaceFullScreenExclusiveInfoEXT structure with its {@code fullScreenExclusive} member set to #FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and {@code surface} was created using #CreateWin32SurfaceKHR(), a ##VkSurfaceFullScreenExclusiveWin32InfoEXT structure <b>must</b> be included in the {@code pNext} chain</li>
            <li>If the {@link GOOGLESurfacelessQuery VK_GOOGLE_surfaceless_query} extension is not enabled, {@code surface} <b>must</b> be a valid {@code VkSurfaceKHR} handle</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkSurfaceFullScreenExclusiveInfoEXT, ##VkSurfaceFullScreenExclusiveWin32InfoEXT, or ##VkSurfacePresentModeEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>If {@code surface} is not #NULL_HANDLE, {@code surface} <b>must</b> be a valid {@code VkSurfaceKHR} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetDeviceGroupSurfacePresentModes2EXT(), #GetPhysicalDeviceSurfaceCapabilities2KHR(), #GetPhysicalDeviceSurfaceFormats2KHR(), #GetPhysicalDeviceSurfacePresentModes2EXT()
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkSurfaceFullScreenExclusiveInfoEXT", "VkSurfaceFullScreenExclusiveWin32InfoEXT", "VkSurfacePresentModeEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSurfaceKHR("surface", "the surface that will be associated with the swapchain.")
}

val VkSurfaceCapabilities2KHR = struct(Module.VULKAN, "VkSurfaceCapabilities2KHR", mutable = false) {
    documentation =
        """
        Structure describing capabilities of a surface.

        <h5>Description</h5>
        If the {@link GOOGLESurfacelessQuery VK_GOOGLE_surfaceless_query} extension is enabled and ##VkPhysicalDeviceSurfaceInfo2KHR{@code ::surface} in the #GetPhysicalDeviceSurfaceCapabilities2KHR() call is #NULL_HANDLE, the values returned in {@code minImageCount}, {@code maxImageCount}, {@code currentExtent}, and {@code currentTransform} will not reflect that of any surface and will instead be as such:

        <ul>
            <li>{@code minImageCount} and {@code maxImageCount} will be <code>0xFFFFFFFF</code></li>
            <li>{@code currentExtent} will be <code>(0xFFFFFFFF, 0xFFFFFFFF)</code></li>
            <li>{@code currentTransform} will be #SURFACE_TRANSFORM_INHERIT_BIT_KHR</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkDisplayNativeHdrSurfaceCapabilitiesAMD, ##VkSharedPresentSurfaceCapabilitiesKHR, ##VkSurfaceCapabilitiesFullScreenExclusiveEXT, ##VkSurfaceCapabilitiesPresentBarrierNV, ##VkSurfacePresentModeCompatibilityEXT, ##VkSurfacePresentScalingCapabilitiesEXT, or ##VkSurfaceProtectedCapabilitiesKHR</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        ##VkSurfaceCapabilitiesKHR, #GetPhysicalDeviceSurfaceCapabilities2KHR()
        """

    Expression("#STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    PointerSetter(
        "VkDisplayNativeHdrSurfaceCapabilitiesAMD", "VkSharedPresentSurfaceCapabilitiesKHR", "VkSurfaceCapabilitiesFullScreenExclusiveEXT", "VkSurfaceCapabilitiesPresentBarrierNV", "VkSurfacePresentModeCompatibilityEXT", "VkSurfacePresentScalingCapabilitiesEXT", "VkSurfaceProtectedCapabilitiesKHR",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkSurfaceCapabilitiesKHR("surfaceCapabilities", "a ##VkSurfaceCapabilitiesKHR structure describing the capabilities of the specified surface.")
}

val VkSurfaceFormat2KHR = struct(Module.VULKAN, "VkSurfaceFormat2KHR", mutable = false) {
    documentation =
        """
        Structure describing a supported swapchain format tuple.

        <h5>Description</h5>
        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-imageCompressionControlSwapchain">{@code imageCompressionControlSwapchain}</a> feature is supported and a ##VkImageCompressionPropertiesEXT structure is included in the {@code pNext} chain of this structure, then it will be filled with the compression properties that are supported for the {@code surfaceFormat}.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-imageCompressionControlSwapchain">{@code imageCompressionControlSwapchain}</a> feature is not enabled, the {@code pNext} chain <b>must</b> not include an ##VkImageCompressionPropertiesEXT structure</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL} or a pointer to a valid instance of ##VkImageCompressionPropertiesEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        ##VkSurfaceFormatKHR, #GetPhysicalDeviceSurfaceFormats2KHR()
        """

    Expression("#STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    PointerSetter(
        "VkImageCompressionPropertiesEXT",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkSurfaceFormatKHR("surfaceFormat", "a ##VkSurfaceFormatKHR structure describing a format-color space pair that is compatible with the specified surface.")
}

val VkPhysicalDeviceVariablePointerFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceVariablePointerFeaturesKHR", alias = VkPhysicalDeviceVariablePointersFeatures) {
    documentation = "See ##VkPhysicalDeviceVariablePointersFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("variablePointersStorageBuffer", "")
    VkBool32("variablePointers", "")
}

val VkPhysicalDeviceVariablePointersFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceVariablePointersFeaturesKHR", alias = VkPhysicalDeviceVariablePointersFeatures) {
    documentation = "See ##VkPhysicalDeviceVariablePointersFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("variablePointersStorageBuffer", "")
    VkBool32("variablePointers", "")
}

val VkDisplayProperties2KHR = struct(Module.VULKAN, "VkDisplayProperties2KHR", mutable = false) {
    documentation =
        """
        Structure describing an available display device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkDisplayPropertiesKHR, #GetPhysicalDeviceDisplayProperties2KHR()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDisplayPropertiesKHR("displayProperties", "a ##VkDisplayPropertiesKHR structure.")
}

val VkDisplayPlaneProperties2KHR = struct(Module.VULKAN, "VkDisplayPlaneProperties2KHR", mutable = false) {
    documentation =
        """
        Structure describing an available display plane.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkDisplayPlanePropertiesKHR, #GetPhysicalDeviceDisplayPlaneProperties2KHR()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDisplayPlanePropertiesKHR("displayPlaneProperties", "a ##VkDisplayPlanePropertiesKHR structure.")
}

val VkDisplayModeProperties2KHR = struct(Module.VULKAN, "VkDisplayModeProperties2KHR", mutable = false) {
    documentation =
        """
        Structure describing an available display mode.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkDisplayModePropertiesKHR, #GetDisplayModeProperties2KHR()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDisplayModePropertiesKHR("displayModeProperties", "a ##VkDisplayModePropertiesKHR structure.")
}

val VkDisplayPlaneInfo2KHR = struct(Module.VULKAN, "VkDisplayPlaneInfo2KHR") {
    documentation =
        """
        Structure defining the intended configuration of a display plane.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        This parameter also implicitly specifies a display.
        </div>

        <ul>
            <li>{@code planeIndex} is the plane which the application intends to use with the display.</li>
        </ul>

        The members of ##VkDisplayPlaneInfo2KHR correspond to the arguments to #GetDisplayPlaneCapabilitiesKHR(), with {@code sType} and {@code pNext} added for extensibility.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkDisplayModeKHR} handle</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code mode} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #GetDisplayPlaneCapabilities2KHR()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDisplayModeKHR("mode", "the display mode the application intends to program when using the specified plane.")
    uint32_t("planeIndex", "")
}

val VkDisplayPlaneCapabilities2KHR = struct(Module.VULKAN, "VkDisplayPlaneCapabilities2KHR", mutable = false) {
    documentation =
        """
        Structure describing the capabilities of a mode and plane combination.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkDisplayPlaneCapabilitiesKHR, #GetDisplayPlaneCapabilities2KHR()
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDisplayPlaneCapabilitiesKHR("capabilities", "a ##VkDisplayPlaneCapabilitiesKHR structure.")
}

val VkMacOSSurfaceCreateInfoMVK = struct(Module.VULKAN, "VkMacOSSurfaceCreateInfoMVK") {
    documentation =
        """
        Structure specifying parameters of a newly created macOS surface object.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code pView} is a {@code CAMetalLayer} object, it <b>must</b> be a valid {@code CAMetalLayer}</li>
            <li>If {@code pView} is an {@code NSView} object, it <b>must</b> be a valid {@code NSView}, <b>must</b> be backed by a {@code CALayer} object of type {@code CAMetalLayer}, and #CreateMacOSSurfaceMVK() <b>must</b> be called on the main thread</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateMacOSSurfaceMVK()
        """

    Expression("#STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMacOSSurfaceCreateFlagsMVK("flags", "reserved for future use.")
    nullable..opaque_const_p("pView", "a reference to either a {@code CAMetalLayer} object or an {@code NSView} object.")
}

val VkMemoryDedicatedRequirementsKHR = struct(Module.VULKAN, "VkMemoryDedicatedRequirementsKHR", mutable = false, alias = VkMemoryDedicatedRequirements) {
    documentation = "See ##VkMemoryDedicatedRequirements."

    Expression("#STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkBool32("prefersDedicatedAllocation", "")
    VkBool32("requiresDedicatedAllocation", "")
}

val VkMemoryDedicatedAllocateInfoKHR = struct(Module.VULKAN, "VkMemoryDedicatedAllocateInfoKHR", alias = VkMemoryDedicatedAllocateInfo) {
    documentation = "See ##VkMemoryDedicatedAllocateInfo."

    Expression("#STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("image", "")
    VkBuffer("buffer", "")
}

val VkDebugUtilsLabelEXT = struct(Module.VULKAN, "VkDebugUtilsLabelEXT") {
    documentation =
        """
        Specify parameters of a label region.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pLabelName} <b>must</b> be a null-terminated UTF-8 string</li>
        </ul>

        <h5>See Also</h5>
        ##VkDebugUtilsMessengerCallbackDataEXT, #CmdBeginDebugUtilsLabelEXT(), #CmdInsertDebugUtilsLabelEXT(), #QueueBeginDebugUtilsLabelEXT(), #QueueInsertDebugUtilsLabelEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    charUTF8.const.p("pLabelName", "a pointer to a null-terminated UTF-8 string containing the name of the label.")
    float("color", "an optional RGBA color value that can be associated with the label. A particular implementation <b>may</b> choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in {@code color} are set to 0.0 then it is ignored.")[4]
}

val VkDebugUtilsObjectNameInfoEXT = struct(Module.VULKAN, "VkDebugUtilsObjectNameInfoEXT") {
    documentation =
        """
        Specify parameters of a name to give to an object.

        <h5>Description</h5>
        Applications <b>may</b> change the name associated with an object simply by calling {@code vkSetDebugUtilsObjectNameEXT} again with a new string. If {@code pObjectName} is either {@code NULL} or an empty string, then any previously set name is removed.

        The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-graphicsPipelineLibrary">{@code graphicsPipelineLibrary}</a> feature allows the specification of pipelines without the creation of {@code VkShaderModule} objects beforehand. In order to continue to allow naming these shaders independently, ##VkDebugUtilsObjectNameInfoEXT <b>can</b> be included in the {@code pNext} chain of ##VkPipelineShaderStageCreateInfo, which associates a static name with that particular shader.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code objectType} is #OBJECT_TYPE_UNKNOWN, {@code objectHandle} <b>must</b> not be #NULL_HANDLE</li>
            <li>If {@code objectType} is not #OBJECT_TYPE_UNKNOWN, {@code objectHandle} <b>must</b> be #NULL_HANDLE or a valid Vulkan handle of the type associated with {@code objectType} as defined in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#debugging-object-types">{@code VkObjectType} and Vulkan Handle Relationship</a> table</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT</li>
            <li>{@code objectType} <b>must</b> be a valid {@code VkObjectType} value</li>
            <li>If {@code pObjectName} is not {@code NULL}, {@code pObjectName} <b>must</b> be a null-terminated UTF-8 string</li>
        </ul>

        <h5>See Also</h5>
        ##VkDebugUtilsMessengerCallbackDataEXT, #SetDebugUtilsObjectNameEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkObjectType("objectType", "a {@code VkObjectType} specifying the type of the object to be named.")
    uint64_t("objectHandle", "the object to be named.")
    nullable..charUTF8.const.p("pObjectName", "either {@code NULL} or a null-terminated UTF-8 string specifying the name to apply to {@code objectHandle}.")
}

val VkDebugUtilsMessengerCallbackDataEXT = struct(Module.VULKAN, "VkDebugUtilsMessengerCallbackDataEXT") {
    documentation =
        """
        Structure specifying parameters returned to the callback.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        This structure should only be considered valid during the lifetime of the triggered callback.
        </div>

        Since adding queue and command buffer labels behaves like pushing and popping onto a stack, the order of both {@code pQueueLabels} and {@code pCmdBufLabels} is based on the order the labels were defined. The result is that the first label in either {@code pQueueLabels} or {@code pCmdBufLabels} will be the first defined (and therefore the oldest) while the last label in each list will be the most recent.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        {@code pQueueLabels} will only be non-{@code NULL} if one of the objects in {@code pObjects} can be related directly to a defined {@code VkQueue} which has had one or more labels associated with it.

        Likewise, {@code pCmdBufLabels} will only be non-{@code NULL} if one of the objects in {@code pObjects} can be related directly to a defined {@code VkCommandBuffer} which has had one or more labels associated with it. Additionally, while command buffer labels allow for beginning and ending across different command buffers, the debug messaging framework <b>cannot</b> guarantee that labels in {@code pCmdBufLables} will contain those defined outside of the associated command buffer. This is partially due to the fact that the association of one command buffer with another may not have been defined at the time the debug message is triggered.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL} or a pointer to a valid instance of ##VkDeviceAddressBindingCallbackDataEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>If {@code pMessageIdName} is not {@code NULL}, {@code pMessageIdName} <b>must</b> be a null-terminated UTF-8 string</li>
            <li>{@code pMessage} <b>must</b> be a null-terminated UTF-8 string</li>
            <li>If {@code queueLabelCount} is not 0, {@code pQueueLabels} <b>must</b> be a valid pointer to an array of {@code queueLabelCount} valid ##VkDebugUtilsLabelEXT structures</li>
            <li>If {@code cmdBufLabelCount} is not 0, {@code pCmdBufLabels} <b>must</b> be a valid pointer to an array of {@code cmdBufLabelCount} valid ##VkDebugUtilsLabelEXT structures</li>
            <li>If {@code objectCount} is not 0, {@code pObjects} <b>must</b> be a valid pointer to an array of {@code objectCount} valid ##VkDebugUtilsObjectNameInfoEXT structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkDebugUtilsLabelEXT, ##VkDebugUtilsObjectNameInfoEXT, #SubmitDebugUtilsMessageEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkDeviceAddressBindingCallbackDataEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDebugUtilsMessengerCallbackDataFlagsEXT("flags", "0 and is reserved for future use.")
    nullable..charUTF8.const.p("pMessageIdName", "a null-terminated string that identifies the particular message ID that is associated with the provided message. If the message corresponds to a validation layer message, then this string may contain the portion of the Vulkan specification that is believed to have been violated.")
    int32_t("messageIdNumber", "the ID number of the triggering message. If the message corresponds to a validation layer message, then this number is related to the internal number associated with the message being triggered.")
    charUTF8.const.p("pMessage", "a null-terminated string detailing the trigger conditions.")
    AutoSize("pQueueLabels", optional = true)..uint32_t("queueLabelCount", "a count of items contained in the {@code pQueueLabels} array.")
    VkDebugUtilsLabelEXT.const.p("pQueueLabels", "{@code NULL} or a pointer to an array of ##VkDebugUtilsLabelEXT active in the current {@code VkQueue} at the time the callback was triggered. Refer to <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#debugging-queue-labels\">Queue Labels</a> for more information.")
    AutoSize("pCmdBufLabels", optional = true)..uint32_t("cmdBufLabelCount", "a count of items contained in the {@code pCmdBufLabels} array.")
    VkDebugUtilsLabelEXT.const.p("pCmdBufLabels", "{@code NULL} or a pointer to an array of ##VkDebugUtilsLabelEXT active in the current {@code VkCommandBuffer} at the time the callback was triggered. Refer to <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#debugging-command-buffer-labels\">Command Buffer Labels</a> for more information.")
    AutoSize("pObjects", optional = true)..uint32_t("objectCount", "a count of items contained in the {@code pObjects} array.")
    VkDebugUtilsObjectNameInfoEXT.const.p("pObjects", "a pointer to an array of ##VkDebugUtilsObjectNameInfoEXT objects related to the detected issue. The array is roughly in order or importance, but the 0th element is always guaranteed to be the most important object for this message.")
}

val VkDebugUtilsMessengerCreateInfoEXT = struct(Module.VULKAN, "VkDebugUtilsMessengerCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created debug messenger.

        <h5>Description</h5>
        For each {@code VkDebugUtilsMessengerEXT} that is created the ##VkDebugUtilsMessengerCreateInfoEXT{@code ::messageSeverity} and ##VkDebugUtilsMessengerCreateInfoEXT{@code ::messageType} determine when that ##VkDebugUtilsMessengerCreateInfoEXT{@code ::pfnUserCallback} is called. The process to determine if the user’s {@code pfnUserCallback} is triggered when an event occurs is as follows:

        <ul>
            <li>
                The implementation will perform a bitwise AND of the event’s {@code VkDebugUtilsMessageSeverityFlagBitsEXT} with the {@code messageSeverity} provided during creation of the {@code VkDebugUtilsMessengerEXT} object.
                <ul>
                    <li>If the value is 0, the message is skipped.</li>
                </ul>
            </li>
            <li>
                The implementation will perform bitwise AND of the event’s {@code VkDebugUtilsMessageTypeFlagBitsEXT} with the {@code messageType} provided during the creation of the {@code VkDebugUtilsMessengerEXT} object.
                <ul>
                    <li>If the value is 0, the message is skipped.</li>
                </ul>
            </li>
            <li>The callback will trigger a debug message for the current event</li>
        </ul>

        The callback will come directly from the component that detected the event, unless some other layer intercepts the calls for its own purposes (filter them in a different way, log to a system error log, etc.).

        An application <b>can</b> receive multiple callbacks if multiple {@code VkDebugUtilsMessengerEXT} objects are created. A callback will always be executed in the same thread as the originating Vulkan call.

        A callback <b>can</b> be called from multiple threads simultaneously (if the application is making Vulkan calls from multiple threads).

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code pfnUserCallback} <b>must</b> be a valid ##VkDebugUtilsMessengerCallbackEXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code messageSeverity} <b>must</b> be a valid combination of {@code VkDebugUtilsMessageSeverityFlagBitsEXT} values</li>
            <li>{@code messageSeverity} <b>must</b> not be 0</li>
            <li>{@code messageType} <b>must</b> be a valid combination of {@code VkDebugUtilsMessageTypeFlagBitsEXT} values</li>
            <li>{@code messageType} <b>must</b> not be 0</li>
            <li>{@code pfnUserCallback} <b>must</b> be a valid ##VkDebugUtilsMessengerCallbackEXT value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDebugUtilsMessengerCallbackEXT, #CreateDebugUtilsMessengerEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDebugUtilsMessengerCreateFlagsEXT("flags", "0 and is reserved for future use.")
    VkDebugUtilsMessageSeverityFlagsEXT("messageSeverity", "a bitmask of {@code VkDebugUtilsMessageSeverityFlagBitsEXT} specifying which severity of event(s) will cause this callback to be called.")
    VkDebugUtilsMessageTypeFlagsEXT("messageType", "a bitmask of {@code VkDebugUtilsMessageTypeFlagBitsEXT} specifying which type of event(s) will cause this callback to be called.")
    PFN_vkDebugUtilsMessengerCallbackEXT("pfnUserCallback", "the application callback function to call.")
    nullable..opaque_p("pUserData", "user data to be passed to the callback.")
}

val VkDebugUtilsObjectTagInfoEXT = struct(Module.VULKAN, "VkDebugUtilsObjectTagInfoEXT") {
    documentation =
        """
        Specify parameters of a tag to attach to an object.

        <h5>Description</h5>
        The {@code tagName} parameter gives a name or identifier to the type of data being tagged. This can be used by debugging layers to easily filter for only data that can be used by that implementation.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code objectType} <b>must</b> not be #OBJECT_TYPE_UNKNOWN</li>
            <li>{@code objectHandle} <b>must</b> be a valid Vulkan handle of the type associated with {@code objectType} as defined in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#debugging-object-types">{@code VkObjectType} and Vulkan Handle Relationship</a> table</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code objectType} <b>must</b> be a valid {@code VkObjectType} value</li>
            <li>{@code pTag} <b>must</b> be a valid pointer to an array of {@code tagSize} bytes</li>
            <li>{@code tagSize} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        #SetDebugUtilsObjectTagEXT()
        """

    Expression("#STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkObjectType("objectType", "a {@code VkObjectType} specifying the type of the object to be named.")
    uint64_t("objectHandle", "the object to be tagged.")
    uint64_t("tagName", "a numerical identifier of the tag.")
    AutoSize("pTag")..size_t("tagSize", "the number of bytes of data to attach to the object.")
    void.const.p("pTag", "a pointer to an array of {@code tagSize} bytes containing the data to be associated with the object.")
}

val VkAndroidHardwareBufferUsageANDROID = struct(Module.VULKAN, "VkAndroidHardwareBufferUsageANDROID", mutable = false) {
    documentation =
        """
        Struct containing Android hardware buffer usage flags.

        <h5>Description</h5>
        The {@code androidHardwareBufferUsage} field <b>must</b> include Android hardware buffer usage flags listed in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#memory-external-android-hardware-buffer-usage">AHardwareBuffer Usage Equivalence</a> table when the corresponding Vulkan image usage or image creation flags are included in the {@code usage} or {@code flags} fields of ##VkPhysicalDeviceImageFormatInfo2. It <b>must</b> include at least one GPU usage flag ({@code AHARDWAREBUFFER_USAGE_GPU_*}), even if none of the corresponding Vulkan usages or flags are requested.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Requiring at least one GPU usage flag ensures that Android hardware buffer memory will be allocated in a memory pool accessible to the Vulkan implementation, and that specializing the memory layout based on usage flags does not prevent it from being compatible with Vulkan. Implementations <b>may</b> avoid unnecessary restrictions caused by this requirement by using vendor usage flags to indicate that only the Vulkan uses indicated in ##VkImageFormatProperties2 are required.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint64_t("androidHardwareBufferUsage", "returns the Android hardware buffer usage flags.")
}

val VkAndroidHardwareBufferPropertiesANDROID = struct(Module.VULKAN, "VkAndroidHardwareBufferPropertiesANDROID", mutable = false) {
    documentation =
        """
        Properties of External Memory Android Hardware Buffers.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkAndroidHardwareBufferFormatProperties2ANDROID or ##VkAndroidHardwareBufferFormatPropertiesANDROID</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        #GetAndroidHardwareBufferPropertiesANDROID()
        """

    Expression("#STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    PointerSetter(
        "VkAndroidHardwareBufferFormatProperties2ANDROID", "VkAndroidHardwareBufferFormatPropertiesANDROID",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDeviceSize("allocationSize", "the size of the external memory")
    uint32_t("memoryTypeBits", "a bitmask containing one bit set for every memory type which the specified Android hardware buffer <b>can</b> be imported as.")
}

val VkAndroidHardwareBufferFormatPropertiesANDROID = struct(Module.VULKAN, "VkAndroidHardwareBufferFormatPropertiesANDROID", mutable = false) {
    documentation =
        """
        Structure describing the image format properties of an Android hardware buffer.

        <h5>Description</h5>
        If the Android hardware buffer has one of the formats listed in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#memory-external-android-hardware-buffer-formats">Format Equivalence table</a>, then {@code format} <b>must</b> have the equivalent Vulkan format listed in the table. Otherwise, {@code format} <b>may</b> be #FORMAT_UNDEFINED, indicating the Android hardware buffer <b>can</b> only be used with an external format.

        The {@code formatFeatures} member <b>must</b> include #FORMAT_FEATURE_SAMPLED_IMAGE_BIT and at least one of #FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or #FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, and <b>should</b> include #FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT and #FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The {@code formatFeatures} member only indicates the features available when using an <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#memory-external-android-hardware-buffer-external-formats">external-format image</a> created from the Android hardware buffer. Images from Android hardware buffers with a format other than #FORMAT_UNDEFINED are subject to the format capabilities obtained from #GetPhysicalDeviceFormatProperties2(), and #GetPhysicalDeviceImageFormatProperties2() with appropriate parameters. These sets of features are independent of each other, e.g. the external format will support sampler Y′C<sub>B</sub>C<sub>R</sub> conversion even if the non-external format does not, and writing to non-external format images is possible but writing to external format images is not.
        </div>

        Android hardware buffers with the same external format <b>must</b> have the same support for #FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT, #FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT, #FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, #FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT, #FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT, and #FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT. in {@code formatFeatures}. Other format features <b>may</b> differ between Android hardware buffers that have the same external format. This allows applications to use the same {@code VkSamplerYcbcrConversion} object (and samplers and pipelines created from them) for any Android hardware buffers that have the same external format.

        If {@code format} is not #FORMAT_UNDEFINED, then the value of {@code samplerYcbcrConversionComponents} <b>must</b> be valid when used as the {@code components} member of ##VkSamplerYcbcrConversionCreateInfo with that format. If {@code format} is #FORMAT_UNDEFINED, all members of {@code samplerYcbcrConversionComponents} <b>must</b> be the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#resources-image-views-identity-mappings">identity swizzle</a>.

        Implementations <b>may</b> not always be able to determine the color model, numerical range, or chroma offsets of the image contents, so the values in ##VkAndroidHardwareBufferFormatPropertiesANDROID are only suggestions. Applications <b>should</b> treat these values as sensible defaults to use in the absence of more reliable information obtained through some other means. If the underlying physical device is also usable via OpenGL ES with the <a href="https://registry.khronos.org/OpenGL/extensions/OES/OES_EGL_image_external.txt">{@code GL_OES_EGL_image_external}</a> extension, the implementation <b>should</b> suggest values that will produce similar sampled values as would be obtained by sampling the same external image via {@code samplerExternalOES} in OpenGL ES using equivalent sampler parameters.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Since <a href="https://registry.khronos.org/OpenGL/extensions/OES/OES_EGL_image_external.txt">{@code GL_OES_EGL_image_external}</a> does not require the same sampling and conversion calculations as Vulkan does, achieving identical results between APIs <b>may</b> not be possible on some implementations.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID</li>
        </ul>

        <h5>See Also</h5>
        ##VkComponentMapping
        """

    Expression("#STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkFormat("format", "the Vulkan format corresponding to the Android hardware buffer’s format, or #FORMAT_UNDEFINED if there is not an equivalent Vulkan format.")
    uint64_t("externalFormat", "an implementation-defined external format identifier for use with ##VkExternalFormatANDROID. It <b>must</b> not be zero.")
    VkFormatFeatureFlags("formatFeatures", "describes the capabilities of this external format when used with an image bound to memory imported from {@code buffer}.")
    VkComponentMapping("samplerYcbcrConversionComponents", "the component swizzle that <b>should</b> be used in ##VkSamplerYcbcrConversionCreateInfo.")
    VkSamplerYcbcrModelConversion("suggestedYcbcrModel", "a suggested color model to use in the ##VkSamplerYcbcrConversionCreateInfo.")
    VkSamplerYcbcrRange("suggestedYcbcrRange", "a suggested numerical value range to use in ##VkSamplerYcbcrConversionCreateInfo.")
    VkChromaLocation("suggestedXChromaOffset", "a suggested X chroma offset to use in ##VkSamplerYcbcrConversionCreateInfo.")
    VkChromaLocation("suggestedYChromaOffset", "a suggested Y chroma offset to use in ##VkSamplerYcbcrConversionCreateInfo.")
}

val VkImportAndroidHardwareBufferInfoANDROID = struct(Module.VULKAN, "VkImportAndroidHardwareBufferInfoANDROID") {
    documentation =
        """
        Import memory from an Android hardware buffer.

        <h5>Description</h5>
        If the #AllocateMemory() command succeeds, the implementation <b>must</b> acquire a reference to the imported hardware buffer, which it <b>must</b> release when the device memory object is freed. If the command fails, the implementation <b>must</b> not retain a reference.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code buffer} is not {@code NULL}, Android hardware buffers <b>must</b> be supported for import, as reported by ##VkExternalImageFormatProperties or ##VkExternalBufferProperties</li>
            <li>If {@code buffer} is not {@code NULL}, it <b>must</b> be a valid Android hardware buffer object with {@code AHardwareBuffer_Desc}{@code ::usage} compatible with Vulkan as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#memory-external-android-hardware-buffer">Android Hardware Buffers</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID</li>
            <li>{@code buffer} <b>must</b> be a valid pointer to an {@code AHardwareBuffer} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AHardwareBuffer.p("buffer", "the Android hardware buffer to import.")
}

val VkMemoryGetAndroidHardwareBufferInfoANDROID = struct(Module.VULKAN, "VkMemoryGetAndroidHardwareBufferInfoANDROID") {
    documentation =
        """
        Structure describing an Android hardware buffer memory export operation.

        <h5>Valid Usage</h5>
        <ul>
            <li>#EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID <b>must</b> have been included in ##VkExportMemoryAllocateInfo{@code ::handleTypes} when {@code memory} was created</li>
            <li>If the {@code pNext} chain of the ##VkMemoryAllocateInfo used to allocate {@code memory} included a ##VkMemoryDedicatedAllocateInfo with non-{@code NULL} {@code image} member, then that {@code image} <b>must</b> already be bound to {@code memory}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetMemoryAndroidHardwareBufferANDROID()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceMemory("memory", "the memory object from which the Android hardware buffer will be exported.")
}

val VkExternalFormatANDROID = struct(Module.VULKAN, "VkExternalFormatANDROID") {
    documentation =
        """
        Structure containing an Android hardware buffer external format.

        <h5>Description</h5>
        If {@code externalFormat} is zero, the effect is as if the ##VkExternalFormatANDROID structure was not present. Otherwise, the {@code image} will have the specified external format.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code externalFormat} <b>must</b> be 0 or a value returned in the {@code externalFormat} member of ##VkAndroidHardwareBufferFormatPropertiesANDROID by an earlier call to #GetAndroidHardwareBufferPropertiesANDROID()</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint64_t("externalFormat", "an implementation-defined identifier for the external format")
}

val VkAndroidHardwareBufferFormatProperties2ANDROID = struct(Module.VULKAN, "VkAndroidHardwareBufferFormatProperties2ANDROID", mutable = false) {
    documentation =
        """
        Structure describing the image format properties of an Android hardware buffer.

        <h5>Description</h5>
        The bits reported in {@code formatFeatures} <b>must</b> include the bits reported in the corresponding fields of ##VkAndroidHardwareBufferFormatPropertiesANDROID{@code ::formatFeatures}.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID</li>
        </ul>

        <h5>See Also</h5>
        ##VkComponentMapping
        """

    Expression("#STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkFormat("format", "the Vulkan format corresponding to the Android hardware buffer’s format, or #FORMAT_UNDEFINED if there is not an equivalent Vulkan format.")
    uint64_t("externalFormat", "an implementation-defined external format identifier for use with ##VkExternalFormatANDROID. It <b>must</b> not be zero.")
    VkFormatFeatureFlags2("formatFeatures", "describes the capabilities of this external format when used with an image bound to memory imported from {@code buffer}.")
    VkComponentMapping("samplerYcbcrConversionComponents", "the component swizzle that <b>should</b> be used in ##VkSamplerYcbcrConversionCreateInfo.")
    VkSamplerYcbcrModelConversion("suggestedYcbcrModel", "a suggested color model to use in the ##VkSamplerYcbcrConversionCreateInfo.")
    VkSamplerYcbcrRange("suggestedYcbcrRange", "a suggested numerical value range to use in ##VkSamplerYcbcrConversionCreateInfo.")
    VkChromaLocation("suggestedXChromaOffset", "a suggested X chroma offset to use in ##VkSamplerYcbcrConversionCreateInfo.")
    VkChromaLocation("suggestedYChromaOffset", "a suggested Y chroma offset to use in ##VkSamplerYcbcrConversionCreateInfo.")
}

val VkSamplerReductionModeCreateInfoEXT = struct(Module.VULKAN, "VkSamplerReductionModeCreateInfoEXT", alias = VkSamplerReductionModeCreateInfo) {
    documentation = "See ##VkSamplerReductionModeCreateInfo."

    Expression("#STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSamplerReductionMode("reductionMode", "")
}

val VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT", mutable = false, alias = VkPhysicalDeviceSamplerFilterMinmaxProperties) {
    documentation = "See ##VkPhysicalDeviceSamplerFilterMinmaxProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkBool32("filterMinmaxSingleComponentFormats", "")
    VkBool32("filterMinmaxImageComponentMapping", "")
}

val VkPhysicalDeviceShaderEnqueueFeaturesAMDX = struct(Module.VULKAN, "VkPhysicalDeviceShaderEnqueueFeaturesAMDX") {
    documentation =
        """
        Structure describing whether shader enqueue within execution graphs are supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderEnqueueFeaturesAMDX structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderEnqueueFeaturesAMDX <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderEnqueue", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#executiongraphs\">execution graphs</a>.")
}

val VkPhysicalDeviceShaderEnqueuePropertiesAMDX = struct(Module.VULKAN, "VkPhysicalDeviceShaderEnqueuePropertiesAMDX") {
    documentation =
        """
        Structure describing shader enqueue limits of an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderEnqueuePropertiesAMDX structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("maxExecutionGraphDepth", "defines the maximum node chain depth in the graph. The dispatched node is at depth 1 and the node enqueued by it is at depth 2, and so on. If a node enqueues itself, each recursive enqueue increases the depth by 1 as well.")
    uint32_t("maxExecutionGraphShaderOutputNodes", "specifies the maximum number of unique nodes that can be dispatched from a single shader, and must be at least 256.")
    uint32_t("maxExecutionGraphShaderPayloadSize", "specifies the maximum total size of payload declarations in a shader. For any payload declarations that share resources, indicated by {@code NodeSharesPayloadLimitsWithAMDX} decorations, the maximum size of each set of shared payload declarations is taken. The sum of each shared set’s maximum size and the size of each unshared payload is counted against this limit.")
    uint32_t("maxExecutionGraphShaderPayloadCount", "specifies the maximum number of output payloads that can be initialized in a single workgroup.")
    uint32_t("executionGraphDispatchAddressAlignment", "specifies the alignment of non-scratch {@code VkDeviceAddress} arguments consumed by graph dispatch commands.")
}

val VkExecutionGraphPipelineScratchSizeAMDX = struct(Module.VULKAN, "VkExecutionGraphPipelineScratchSizeAMDX") {
    documentation =
        """
        Structure describing the scratch space required to dispatch an execution graph.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX</li>
        </ul>

        <h5>See Also</h5>
        #GetExecutionGraphPipelineScratchSizeAMDX()
        """

    Expression("#STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceSize("size", "indicates the scratch space required for dispatch the queried execution graph.")
}

val VkPipelineLibraryCreateInfoKHR = struct(Module.VULKAN, "VkPipelineLibraryCreateInfoKHR") {
    documentation =
        """
        Structure specifying pipeline libraries to use when creating a pipeline.

        <h5>Valid Usage</h5>
        <ul>
            <li>Each element of {@code pLibraries} <b>must</b> have been created with #PIPELINE_CREATE_LIBRARY_BIT_KHR</li>
            <li>If any library in {@code pLibraries} was created with a shader stage with ##VkPipelineShaderStageModuleIdentifierCreateInfoEXT and {@code identifierSize} not equal to 0, the pipeline <b>must</b> be created with the #PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set</li>
            <li>If any element of {@code pLibraries} was created with #PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, all elements <b>must</b> have been created with #PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT</li>
            <li>If {@code pipeline} is being created with #PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT, every element of {@code pLibraries} <b>must</b> have been created with #PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT</li>
            <li>If {@code pipeline} is being created without #PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT, every element of {@code pLibraries} <b>must</b> have been created without #PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT</li>
            <li>If {@code pipeline} is being created with #PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT, every element of {@code pLibraries} <b>must</b> have been created with #PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT</li>
            <li>If {@code pipeline} is being created without #PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT, every element of {@code pLibraries} <b>must</b> have been created without #PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR</li>
            <li>If {@code libraryCount} is not 0, {@code pLibraries} <b>must</b> be a valid pointer to an array of {@code libraryCount} valid {@code VkPipeline} handles</li>
        </ul>

        <h5>See Also</h5>
        ##VkExecutionGraphPipelineCreateInfoAMDX, ##VkRayTracingPipelineCreateInfoKHR
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pLibraries", optional = true)..uint32_t("libraryCount", "the number of pipeline libraries in {@code pLibraries}.")
    VkPipeline.const.p("pLibraries", "a pointer to an array of {@code VkPipeline} structures specifying pipeline libraries to use when creating a pipeline.")
}

val VkExecutionGraphPipelineCreateInfoAMDX = struct(Module.VULKAN, "VkExecutionGraphPipelineCreateInfoAMDX") {
    documentation =
        """
        Structure specifying parameters of a newly created execution graph pipeline.

        <h5>Description</h5>
        The parameters {@code basePipelineHandle} and {@code basePipelineIndex} are described in more detail in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#pipelines-pipeline-derivatives">Pipeline Derivatives</a>.

        Each shader stage provided when creating an execution graph pipeline (including those in libraries) is associated with a name and an index, determined by the inclusion or omission of a ##VkPipelineShaderStageNodeCreateInfoAMDX structure in its {@code pNext} chain.

        In addition to the shader name and index, an internal "node index" is also generated for each node, which can be queried with #GetExecutionGraphPipelineNodeIndexAMDX(), and is used exclusively for initial dispatch of an execution graph.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, and {@code basePipelineIndex} is -1, {@code basePipelineHandle} <b>must</b> be a valid execution graph {@code VkPipeline} handle</li>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, and {@code basePipelineHandle} is #NULL_HANDLE, {@code basePipelineIndex} <b>must</b> be a valid index into the calling command’s {@code pCreateInfos} parameter</li>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, {@code basePipelineIndex} <b>must</b> be -1 or {@code basePipelineHandle} <b>must</b> be #NULL_HANDLE</li>
            <li>If a push constant block is declared in a shader, a push constant range in {@code layout} <b>must</b> match both the shader stage and range</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader, a descriptor slot in {@code layout} <b>must</b> match the shader stage</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader, and the descriptor type is not #DESCRIPTOR_TYPE_MUTABLE_EXT, a descriptor slot in {@code layout} <b>must</b> match the descriptor type</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader as an array, a descriptor slot in {@code layout} <b>must</b> match the descriptor count</li>
        </ul>

        <ul>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-deviceGeneratedComputePipelines">##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV{@code ::deviceGeneratedComputePipelines}</a> feature <b>must</b> be enabled</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then the {@code pNext} chain <b>must</b> include a pointer to a valid instance of ##VkComputePipelineIndirectBufferInfoNV specifying the address where the pipeline’s metadata will be saved</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineCreationCacheControl">{@code pipelineCreationCacheControl}</a> feature is not enabled, {@code flags} <b>must</b> not include #PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or #PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT</li>
            <li>The {@code stage} member of any element of {@code pStages} <b>must</b> be #SHADER_STAGE_COMPUTE_BIT</li>
            <li>The shader code for the entry point identified by each element of {@code pStages} and the rest of the state identified by this structure <b>must</b> adhere to the pipeline linking rules described in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces">Shader Interfaces</a> chapter</li>
            <li>{@code layout} <b>must</b> be <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#descriptorsets-pipelinelayout-consistency">consistent</a> with the layout of the shaders specified in {@code pStages}</li>
            <li>If {@code pLibraryInfo} is not {@code NULL}, each element of its {@code pLibraries} member <b>must</b> have been created with a {@code layout} that is compatible with the {@code layout} in this pipeline</li>
            <li>The number of resources in {@code layout} accessible to each shader stage that is used by the pipeline <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxPerStageResources}</li>
            <li>If {@code pLibraryInfo} is not {@code NULL}, each element of {@code pLibraryInfo→libraries} <b>must</b> be either a compute pipeline or an execution graph pipeline</li>
            <li>There <b>must</b> be no two nodes in the pipeline that share both the same shader name and index, as specified by ##VkPipelineShaderStageNodeCreateInfoAMDX</li>
            <li>There <b>must</b> be no two nodes in the pipeline that share the same shader name and have input payload declarations with different sizes</li>
            <li>There <b>must</b> be no two nodes in the pipeline that share the same name but have different execution models</li>
            <li>There <b>must</b> be no two nodes in the pipeline that share the same name where one includes {@code CoalescedInputCountAMDX} and the other does not</li>
            <li>There <b>must</b> be no two nodes in the pipeline that share the same name where one includes {@code StaticNumWorkgroupsAMDX} and the other does not</li>
            <li>If an output payload declared in any shader in the pipeline has a {@code PayloadNodeNameAMDX} decoration with a {@code Node} {@code Name} that matches the shader name of any other node in the graph, the size of the output payload <b>must</b> match the size of the input payload in the matching node</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkPipelineCompilerControlCreateInfoAMD or ##VkPipelineCreationFeedbackCreateInfo</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkPipelineCreateFlagBits} values</li>
            <li>If {@code stageCount} is not 0, and {@code pStages} is not {@code NULL}, {@code pStages} <b>must</b> be a valid pointer to an array of {@code stageCount} valid ##VkPipelineShaderStageCreateInfo structures</li>
            <li>If {@code pLibraryInfo} is not {@code NULL}, {@code pLibraryInfo} <b>must</b> be a valid pointer to a valid ##VkPipelineLibraryCreateInfoKHR structure</li>
            <li>{@code layout} <b>must</b> be a valid {@code VkPipelineLayout} handle</li>
            <li>Both of {@code basePipelineHandle}, and {@code layout} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkPipelineLibraryCreateInfoKHR, ##VkPipelineShaderStageCreateInfo, #CreateExecutionGraphPipelinesAMDX()
        """

    Expression("#STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkPipelineCompilerControlCreateInfoAMD", "VkPipelineCreationFeedbackCreateInfo", "VkPipelineCreationFeedbackCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCreateFlags("flags", "a bitmask of {@code VkPipelineCreateFlagBits} specifying how the pipeline will be generated.")
    AutoSize("pStages", optional = true)..uint32_t("stageCount", "the number of entries in the {@code pStages} array.")
    nullable..VkPipelineShaderStageCreateInfo.const.p("pStages", "a pointer to an array of {@code stageCount} ##VkPipelineShaderStageCreateInfo structures describing the set of the shader stages to be included in the execution graph pipeline.")
    nullable..VkPipelineLibraryCreateInfoKHR.const.p("pLibraryInfo", "a pointer to a ##VkPipelineLibraryCreateInfoKHR structure defining pipeline libraries to include.")
    VkPipelineLayout("layout", "the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.")
    VkPipeline("basePipelineHandle", "a pipeline to derive from")
    int32_t("basePipelineIndex", "an index into the {@code pCreateInfos} parameter to use as a pipeline to derive from")
}

val VkDeviceOrHostAddressConstAMDX = union(Module.VULKAN, "VkDeviceOrHostAddressConstAMDX") {
    documentation =
        """
        Union specifying a const device or host address.

        <h5>See Also</h5>
        ##VkDispatchGraphCountInfoAMDX, ##VkDispatchGraphInfoAMDX
        """

    VkDeviceAddress("deviceAddress", "a buffer device address as returned by the #GetBufferDeviceAddressKHR() command.")
    nullable..opaque_const_p("hostAddress", "a const host memory address.")
}

val VkDispatchGraphInfoAMDX = struct(Module.VULKAN, "VkDispatchGraphInfoAMDX") {
    documentation =
        """
        Structure specifying node parameters for execution graph dispatch.

        <h5>Description</h5>
        Whether {@code payloads} is consumed as a device or host pointer is defined by the command this structure is used in.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code payloadCount} <b>must</b> be no greater than <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxExecutionGraphShaderPayloadCount">{@code maxExecutionGraphShaderPayloadCount}</a></li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstAMDX, ##VkDispatchGraphCountInfoAMDX
        """

    uint32_t("nodeIndex", "the index of a node in an execution graph to be dispatched.")
    uint32_t("payloadCount", "the number of payloads to dispatch for the specified node.")
    VkDeviceOrHostAddressConstAMDX("payloads", "a device or host address pointer to a flat array of payloads with size equal to the product of {@code payloadCount} and {@code payloadStride}")
    uint64_t("payloadStride", "the byte stride between successive payloads in {@code payloads}")
}

val VkDispatchGraphCountInfoAMDX = struct(Module.VULKAN, "VkDispatchGraphCountInfoAMDX") {
    documentation =
        """
        Structure specifying count parameters for execution graph dispatch.

        <h5>Description</h5>
        Whether {@code infos} is consumed as a device or host pointer is defined by the command this structure is used in.

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstAMDX, #CmdDispatchGraphAMDX(), #CmdDispatchGraphIndirectAMDX(), #CmdDispatchGraphIndirectCountAMDX()
        """

    uint32_t("count", "the number of dispatches to perform.")
    VkDeviceOrHostAddressConstAMDX("infos", "the device or host address of a flat array of ##VkDispatchGraphInfoAMDX structures")
    uint64_t("stride", "the byte stride between successive ##VkDispatchGraphInfoAMDX structures in {@code infos}")
}

val VkPipelineShaderStageNodeCreateInfoAMDX = struct(Module.VULKAN, "VkPipelineShaderStageNodeCreateInfoAMDX") {
    documentation =
        """
        Structure specifying the shader name and index with an execution graph.

        <h5>Description</h5>
        When included in the {@code pNext} chain of a ##VkPipelineShaderStageCreateInfo structure, this structure specifies the shader name and shader index of a node when creating an execution graph pipeline. If this structure is omitted, the shader name is set to the name of the entry point in SPIR-V and the shader index is set to 0.

        When dispatching a node from another shader, the name is fixed at pipeline creation, but the index <b>can</b> be set dynamically. By associating multiple shaders with the same name but different indexes, applications can dynamically select different nodes to execute. Applications <b>must</b> ensure each node has a unique name and index.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX</li>
            <li>If {@code pName} is not {@code NULL}, {@code pName} <b>must</b> be a null-terminated UTF-8 string</li>
        </ul>

        <h5>See Also</h5>
        #GetExecutionGraphPipelineNodeIndexAMDX()
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    nullable..charUTF8.const.p("pName", "the shader name to use when creating a node in an execution graph. If {@code pName} is {@code NULL}, the name of the entry point specified in SPIR-V is used as the shader name.")
    uint32_t("index", "the shader index to use when creating a node in an execution graph. If {@code index} is #SHADER_INDEX_UNUSED_AMDX then the original index is used, either as specified by the {@code ShaderIndexAMDX} execution mode, or 0 if that too is not specified.")
}

val VkPhysicalDeviceInlineUniformBlockFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT", alias = VkPhysicalDeviceInlineUniformBlockFeatures) {
    documentation = "See ##VkPhysicalDeviceInlineUniformBlockFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("inlineUniformBlock", "")
    VkBool32("descriptorBindingInlineUniformBlockUpdateAfterBind", "")
}

val VkPhysicalDeviceInlineUniformBlockPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceInlineUniformBlockPropertiesEXT", mutable = false, alias = VkPhysicalDeviceInlineUniformBlockProperties) {
    documentation = "See ##VkPhysicalDeviceInlineUniformBlockProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("maxInlineUniformBlockSize", "")
    uint32_t("maxPerStageDescriptorInlineUniformBlocks", "")
    uint32_t("maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", "")
    uint32_t("maxDescriptorSetInlineUniformBlocks", "")
    uint32_t("maxDescriptorSetUpdateAfterBindInlineUniformBlocks", "")
}

val VkWriteDescriptorSetInlineUniformBlockEXT = struct(Module.VULKAN, "VkWriteDescriptorSetInlineUniformBlockEXT", alias = VkWriteDescriptorSetInlineUniformBlock) {
    documentation = "See ##VkWriteDescriptorSetInlineUniformBlock."

    Expression("#STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pData")..uint32_t("dataSize", "")
    void.const.p("pData", "")
}

val VkDescriptorPoolInlineUniformBlockCreateInfoEXT = struct(Module.VULKAN, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT", alias = VkDescriptorPoolInlineUniformBlockCreateInfo) {
    documentation = "See ##VkDescriptorPoolInlineUniformBlockCreateInfo."

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("maxInlineUniformBlockBindings", "")
}

val VkSampleLocationEXT = struct(Module.VULKAN, "VkSampleLocationEXT") {
    documentation =
        """
        Structure specifying the coordinates of a sample location.

        <h5>Description</h5>
        The domain space of the sample location coordinates has an upper-left origin within the pixel in framebuffer space.

        The values specified in a ##VkSampleLocationEXT structure are always clamped to the implementation-dependent sample location coordinate range <code>[sampleLocationCoordinateRange[0],sampleLocationCoordinateRange[1]]</code> that <b>can</b> be queried using ##VkPhysicalDeviceSampleLocationsPropertiesEXT.

        <h5>See Also</h5>
        ##VkSampleLocationsInfoEXT
        """

    float("x", "the horizontal coordinate of the sample’s location.")
    float("y", "the vertical coordinate of the sample’s location.")
}

val VkSampleLocationsInfoEXT = struct(Module.VULKAN, "VkSampleLocationsInfoEXT") {
    documentation =
        """
        Structure specifying a set of sample locations.

        <h5>Description</h5>
        This structure <b>can</b> be used either to specify the sample locations to be used for rendering or to specify the set of sample locations an image subresource has been last rendered with for the purposes of layout transitions of depth/stencil images created with #IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT.

        The sample locations in {@code pSampleLocations} specify {@code sampleLocationsPerPixel} number of sample locations for each pixel in the grid of the size specified in {@code sampleLocationGridSize}. The sample location for sample <code>i</code> at the pixel grid location <code>(x,y)</code> is taken from <code>pSampleLocations[(x + y × sampleLocationGridSize.width) × sampleLocationsPerPixel + i]</code>.

        If the render pass has a fragment density map, the implementation will choose the sample locations for the fragment and the contents of {@code pSampleLocations} <b>may</b> be ignored.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code sampleLocationsPerPixel} <b>must</b> be a bit value that is set in ##VkPhysicalDeviceSampleLocationsPropertiesEXT{@code ::sampleLocationSampleCounts}</li>
            <li>{@code sampleLocationsCount} <b>must</b> equal <code>sampleLocationsPerPixel × sampleLocationGridSize.width × sampleLocationGridSize.height</code></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT</li>
            <li>If {@code sampleLocationsCount} is not 0, {@code pSampleLocations} <b>must</b> be a valid pointer to an array of {@code sampleLocationsCount} ##VkSampleLocationEXT structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkAttachmentSampleLocationsEXT, ##VkExtent2D, ##VkPipelineSampleLocationsStateCreateInfoEXT, ##VkSampleLocationEXT, ##VkSubpassSampleLocationsEXT, #CmdSetSampleLocationsEXT()
        """

    Expression("#STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSampleCountFlagBits("sampleLocationsPerPixel", "a {@code VkSampleCountFlagBits} value specifying the number of sample locations per pixel.")
    VkExtent2D("sampleLocationGridSize", "the size of the sample location grid to select custom sample locations for.")
    AutoSize("pSampleLocations", optional = true)..uint32_t("sampleLocationsCount", "the number of sample locations in {@code pSampleLocations}.")
    VkSampleLocationEXT.const.p("pSampleLocations", "a pointer to an array of {@code sampleLocationsCount} ##VkSampleLocationEXT structures.")
}

val VkAttachmentSampleLocationsEXT = struct(Module.VULKAN, "VkAttachmentSampleLocationsEXT") {
    documentation =
        """
        Structure specifying the sample locations state to use in the initial layout transition of attachments.

        <h5>Description</h5>
        If the image referenced by the framebuffer attachment at index {@code attachmentIndex} was not created with #IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT then the values specified in {@code sampleLocationsInfo} are ignored.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code attachmentIndex} <b>must</b> be less than the {@code attachmentCount} specified in ##VkRenderPassCreateInfo the render pass specified by ##VkRenderPassBeginInfo{@code ::renderPass} was created with</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sampleLocationsInfo} <b>must</b> be a valid ##VkSampleLocationsInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkRenderPassSampleLocationsBeginInfoEXT, ##VkSampleLocationsInfoEXT
        """

    uint32_t("attachmentIndex", "the index of the attachment for which the sample locations state is provided.")
    VkSampleLocationsInfoEXT("sampleLocationsInfo", "the sample locations state to use for the layout transition of the given attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.")
}

val VkSubpassSampleLocationsEXT = struct(Module.VULKAN, "VkSubpassSampleLocationsEXT") {
    documentation =
        """
        Structure specifying the sample locations state to use for layout transitions of attachments performed after a given subpass.

        <h5>Description</h5>
        If the image referenced by the depth/stencil attachment used in the subpass identified by {@code subpassIndex} was not created with #IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT or if the subpass does not use a depth/stencil attachment, and ##VkPhysicalDeviceSampleLocationsPropertiesEXT{@code ::variableSampleLocations} is #TRUE then the values specified in {@code sampleLocationsInfo} are ignored.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code subpassIndex} <b>must</b> be less than the {@code subpassCount} specified in ##VkRenderPassCreateInfo the render pass specified by ##VkRenderPassBeginInfo{@code ::renderPass} was created with</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sampleLocationsInfo} <b>must</b> be a valid ##VkSampleLocationsInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkRenderPassSampleLocationsBeginInfoEXT, ##VkSampleLocationsInfoEXT
        """

    uint32_t("subpassIndex", "the index of the subpass for which the sample locations state is provided.")
    VkSampleLocationsInfoEXT("sampleLocationsInfo", "the sample locations state to use for the layout transition of the depth/stencil attachment away from the image layout the attachment is used with in the subpass specified in {@code subpassIndex}.")
}

val VkRenderPassSampleLocationsBeginInfoEXT = struct(Module.VULKAN, "VkRenderPassSampleLocationsBeginInfoEXT") {
    documentation =
        """
        Structure specifying sample locations to use for the layout transition of custom sample locations compatible depth/stencil attachments.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT</li>
            <li>If {@code attachmentInitialSampleLocationsCount} is not 0, {@code pAttachmentInitialSampleLocations} <b>must</b> be a valid pointer to an array of {@code attachmentInitialSampleLocationsCount} valid ##VkAttachmentSampleLocationsEXT structures</li>
            <li>If {@code postSubpassSampleLocationsCount} is not 0, {@code pPostSubpassSampleLocations} <b>must</b> be a valid pointer to an array of {@code postSubpassSampleLocationsCount} valid ##VkSubpassSampleLocationsEXT structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkAttachmentSampleLocationsEXT, ##VkSubpassSampleLocationsEXT
        """

    Expression("#STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pAttachmentInitialSampleLocations", optional = true)..uint32_t("attachmentInitialSampleLocationsCount", "the number of elements in the {@code pAttachmentInitialSampleLocations} array.")
    VkAttachmentSampleLocationsEXT.const.p("pAttachmentInitialSampleLocations", "a pointer to an array of {@code attachmentInitialSampleLocationsCount} ##VkAttachmentSampleLocationsEXT structures specifying the attachment indices and their corresponding sample location state. Each element of {@code pAttachmentInitialSampleLocations} <b>can</b> specify the sample location state to use in the automatic layout transition performed to transition a depth/stencil attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.")
    AutoSize("pPostSubpassSampleLocations", optional = true)..uint32_t("postSubpassSampleLocationsCount", "the number of elements in the {@code pPostSubpassSampleLocations} array.")
    VkSubpassSampleLocationsEXT.const.p("pPostSubpassSampleLocations", "a pointer to an array of {@code postSubpassSampleLocationsCount} ##VkSubpassSampleLocationsEXT structures specifying the subpass indices and their corresponding sample location state. Each element of {@code pPostSubpassSampleLocations} <b>can</b> specify the sample location state to use in the automatic layout transition performed to transition the depth/stencil attachment used by the specified subpass to the image layout specified in a dependent subpass or to the final layout of the attachment in case the specified subpass is the last subpass using that attachment. In addition, if ##VkPhysicalDeviceSampleLocationsPropertiesEXT{@code ::variableSampleLocations} is #FALSE, each element of {@code pPostSubpassSampleLocations} <b>must</b> specify the sample location state that matches the sample locations used by all pipelines that will be bound to a command buffer during the specified subpass. If {@code variableSampleLocations} is #TRUE, the sample locations used for rasterization do not depend on {@code pPostSubpassSampleLocations}.")
}

val VkPipelineSampleLocationsStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineSampleLocationsStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying sample locations for a pipeline.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT</li>
            <li>{@code sampleLocationsInfo} <b>must</b> be a valid ##VkSampleLocationsInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkSampleLocationsInfoEXT
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("sampleLocationsEnable", "controls whether custom sample locations are used. If {@code sampleLocationsEnable} is #FALSE, the default sample locations are used and the values specified in {@code sampleLocationsInfo} are ignored.")
    VkSampleLocationsInfoEXT("sampleLocationsInfo", "the sample locations to use during rasterization if {@code sampleLocationsEnable} is #TRUE and the graphics pipeline is not created with #DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT.")
}

val VkPhysicalDeviceSampleLocationsPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceSampleLocationsPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing sample location limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceSampleLocationsPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkSampleCountFlags("sampleLocationSampleCounts", "a bitmask of {@code VkSampleCountFlagBits} indicating the sample counts supporting custom sample locations.")
    VkExtent2D("maxSampleLocationGridSize", "the maximum size of the pixel grid in which sample locations <b>can</b> vary that is supported for all sample counts in {@code sampleLocationSampleCounts}.")
    float("sampleLocationCoordinateRange", "the range of supported sample location coordinates.")[2]
    uint32_t("sampleLocationSubPixelBits", "the number of bits of subpixel precision for sample locations.")
    VkBool32("variableSampleLocations", "specifies whether the sample locations used by all pipelines that will be bound to a command buffer during a subpass <b>must</b> match. If set to #TRUE, the implementation supports variable sample locations in a subpass. If set to #FALSE, then the sample locations <b>must</b> stay constant in each subpass.")
}

val VkMultisamplePropertiesEXT = struct(Module.VULKAN, "VkMultisamplePropertiesEXT", mutable = false) {
    documentation =
        """
        Structure returning information about sample count specific additional multisampling capabilities.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, #GetPhysicalDeviceMultisamplePropertiesEXT()
        """

    Expression("#STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkExtent2D("maxSampleLocationGridSize", "the maximum size of the pixel grid in which sample locations <b>can</b> vary.")
}

val VkBufferMemoryRequirementsInfo2KHR = struct(Module.VULKAN, "VkBufferMemoryRequirementsInfo2KHR", alias = VkBufferMemoryRequirementsInfo2) {
    documentation = "See ##VkBufferMemoryRequirementsInfo2."

    Expression("#STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBuffer("buffer", "")
}

val VkImageMemoryRequirementsInfo2KHR = struct(Module.VULKAN, "VkImageMemoryRequirementsInfo2KHR", alias = VkImageMemoryRequirementsInfo2) {
    documentation = "See ##VkImageMemoryRequirementsInfo2."

    Expression("#STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("image", "")
}

val VkImageSparseMemoryRequirementsInfo2KHR = struct(Module.VULKAN, "VkImageSparseMemoryRequirementsInfo2KHR", alias = VkImageSparseMemoryRequirementsInfo2) {
    documentation = "See ##VkImageSparseMemoryRequirementsInfo2."

    Expression("#STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("image", "")
}

val VkMemoryRequirements2KHR = struct(Module.VULKAN, "VkMemoryRequirements2KHR", mutable = false, alias = VkMemoryRequirements2) {
    documentation = "See ##VkMemoryRequirements2."

    Expression("#STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkMemoryRequirements("memoryRequirements", "")
}

val VkSparseImageMemoryRequirements2KHR = struct(Module.VULKAN, "VkSparseImageMemoryRequirements2KHR", mutable = false, alias = VkSparseImageMemoryRequirements2) {
    documentation = "See ##VkSparseImageMemoryRequirements2."

    Expression("#STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkSparseImageMemoryRequirements("memoryRequirements", "")
}

val VkImageFormatListCreateInfoKHR = struct(Module.VULKAN, "VkImageFormatListCreateInfoKHR", alias = VkImageFormatListCreateInfo) {
    documentation = "See ##VkImageFormatListCreateInfo."

    Expression("#STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pViewFormats", optional = true)..uint32_t("viewFormatCount", "")
    VkFormat.const.p("pViewFormats", "")
}

val VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT") {
    documentation =
        """
        Structure describing advanced blending features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("advancedBlendCoherentOperations", "specifies whether blending using <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#framebuffer-blend-advanced\">advanced blend operations</a> is guaranteed to execute atomically and in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#drawing-primitive-order\">primitive order</a>. If this is #TRUE, #ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated the same as #ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blending needs no additional synchronization over basic blending. If this is #FALSE, then memory dependencies are required to guarantee order between two advanced blending operations that occur on the same sample.")
}

val VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing advanced blending limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("advancedBlendMaxColorAttachments", "one greater than the highest color attachment index that <b>can</b> be used in a subpass, for a pipeline that uses an <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#framebuffer-blend-advanced\">advanced blend operation</a>.")
    VkBool32("advancedBlendIndependentBlend", "specifies whether advanced blend operations <b>can</b> vary per-attachment.")
    VkBool32("advancedBlendNonPremultipliedSrcColor", "specifies whether the source color <b>can</b> be treated as non-premultiplied. If this is #FALSE, then ##VkPipelineColorBlendAdvancedStateCreateInfoEXT{@code ::srcPremultiplied} <b>must</b> be #TRUE.")
    VkBool32("advancedBlendNonPremultipliedDstColor", "specifies whether the destination color <b>can</b> be treated as non-premultiplied. If this is #FALSE, then ##VkPipelineColorBlendAdvancedStateCreateInfoEXT{@code ::dstPremultiplied} <b>must</b> be #TRUE.")
    VkBool32("advancedBlendCorrelatedOverlap", "specifies whether the overlap mode <b>can</b> be treated as correlated. If this is #FALSE, then ##VkPipelineColorBlendAdvancedStateCreateInfoEXT{@code ::blendOverlap} <b>must</b> be #BLEND_OVERLAP_UNCORRELATED_EXT.")
    VkBool32("advancedBlendAllOperations", "specifies whether all advanced blend operation enums are supported. See the valid usage of ##VkPipelineColorBlendAttachmentState.")
}

val VkPipelineColorBlendAdvancedStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineColorBlendAdvancedStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters that affect advanced blend operations.

        <h5>Description</h5>
        If this structure is not present, {@code srcPremultiplied} and {@code dstPremultiplied} are both considered to be #TRUE, and {@code blendOverlap} is considered to be #BLEND_OVERLAP_UNCORRELATED_EXT.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-advancedBlendNonPremultipliedSrcColor">non-premultiplied source color</a> property is not supported, {@code srcPremultiplied} <b>must</b> be #TRUE</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-advancedBlendNonPremultipliedDstColor">non-premultiplied destination color</a> property is not supported, {@code dstPremultiplied} <b>must</b> be #TRUE</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-advancedBlendCorrelatedOverlap">correlated overlap</a> property is not supported, {@code blendOverlap} <b>must</b> be #BLEND_OVERLAP_UNCORRELATED_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT</li>
            <li>{@code blendOverlap} <b>must</b> be a valid {@code VkBlendOverlapEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("srcPremultiplied", "specifies whether the source color of the blend operation is treated as premultiplied.")
    VkBool32("dstPremultiplied", "specifies whether the destination color of the blend operation is treated as premultiplied.")
    VkBlendOverlapEXT("blendOverlap", "a {@code VkBlendOverlapEXT} value specifying how the source and destination sample’s coverage is correlated.")
}

val VkPipelineCoverageToColorStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineCoverageToColorStateCreateInfoNV") {
    documentation =
        """
        Structure specifying whether fragment coverage replaces a color.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkPipelineMultisampleStateCreateInfo includes a ##VkPipelineCoverageToColorStateCreateInfoNV structure, then that structure controls whether the fragment coverage is substituted for a fragment color output and, if so, which output is replaced.

        If {@code coverageToColorEnable} is #TRUE, the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-multisampling-coverage-mask">coverage mask</a> replaces the first component of the color value corresponding to the fragment shader output location with {@code Location} equal to {@code coverageToColorLocation} and {@code Index} equal to zero. If the color attachment format has fewer bits than the coverage mask, the low bits of the sample coverage mask are taken without any clamping. If the color attachment format has more bits than the coverage mask, the high bits of the sample coverage mask are filled with zeros.

        If {@code coverageToColorEnable} is #FALSE, these operations are skipped. If this structure is not included in the {@code pNext} chain, it is as if {@code coverageToColorEnable} is #FALSE.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code coverageToColorEnable} is #TRUE, then the render pass subpass indicated by ##VkGraphicsPipelineCreateInfo{@code ::renderPass} and ##VkGraphicsPipelineCreateInfo{@code ::subpass} <b>must</b> have a color attachment at the location selected by {@code coverageToColorLocation}, with a {@code VkFormat} of #FORMAT_R8_UINT, #FORMAT_R8_SINT, #FORMAT_R16_UINT, #FORMAT_R16_SINT, #FORMAT_R32_UINT, or #FORMAT_R32_SINT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCoverageToColorStateCreateFlagsNV("flags", "reserved for future use.")
    VkBool32("coverageToColorEnable", "controls whether the fragment coverage value replaces a fragment color output.")
    uint32_t("coverageToColorLocation", "controls which fragment shader color output value is replaced.")
}

val VkDeviceOrHostAddressKHR = union(Module.VULKAN, "VkDeviceOrHostAddressKHR") {
    documentation =
        """
        Union specifying a device or host address.

        <h5>See Also</h5>
        ##VkAccelerationStructureBuildGeometryInfoKHR, ##VkCopyAccelerationStructureToMemoryInfoKHR, ##VkCopyMicromapToMemoryInfoEXT, ##VkMicromapBuildInfoEXT
        """

    VkDeviceAddress("deviceAddress", "a buffer device address as returned by the #GetBufferDeviceAddressKHR() command.")
    nullable..opaque_p("hostAddress", "a host memory address.")
}

val VkDeviceOrHostAddressConstKHR = union(Module.VULKAN, "VkDeviceOrHostAddressConstKHR") {
    documentation =
        """
        Union specifying a const device or host address.

        <h5>See Also</h5>
        ##VkAccelerationStructureGeometryAabbsDataKHR, ##VkAccelerationStructureGeometryInstancesDataKHR, ##VkAccelerationStructureGeometryMotionTrianglesDataNV, ##VkAccelerationStructureGeometryTrianglesDataKHR, ##VkAccelerationStructureTrianglesDisplacementMicromapNV, ##VkAccelerationStructureTrianglesOpacityMicromapEXT, ##VkCopyMemoryToAccelerationStructureInfoKHR, ##VkCopyMemoryToMicromapInfoEXT, ##VkMicromapBuildInfoEXT
        """

    VkDeviceAddress("deviceAddress", "a buffer device address as returned by the #GetBufferDeviceAddressKHR() command.")
    nullable..opaque_const_p("hostAddress", "a const host memory address.")
}

val VkAccelerationStructureBuildRangeInfoKHR = struct(Module.VULKAN, "VkAccelerationStructureBuildRangeInfoKHR") {
    documentation =
        """
        Structure specifying build offsets and counts for acceleration structure builds.

        <h5>Description</h5>
        The primitive count and primitive offset are interpreted differently depending on the {@code VkGeometryTypeKHR} used:

        <ul>
            <li>
                For geometries of type #GEOMETRY_TYPE_TRIANGLES_KHR, {@code primitiveCount} is the number of triangles to be built, where each triangle is treated as 3 vertices.
                <ul>
                    <li>If the geometry uses indices, <code>primitiveCount × 3</code> indices are consumed from ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::indexData}, starting at an offset of {@code primitiveOffset}. The value of {@code firstVertex} is added to the index values before fetching vertices.</li>
                    <li>If the geometry does not use indices, <code>primitiveCount × 3</code> vertices are consumed from ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::vertexData}, starting at an offset of <code>primitiveOffset + ##VkAccelerationStructureGeometryTrianglesDataKHR::vertexStride × firstVertex</code>.</li>
                    <li>If ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::transformData} is not {@code NULL}, a single ##VkTransformMatrixKHR structure is consumed from ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::transformData}, at an offset of {@code transformOffset}. This matrix describes a transformation from the space in which the vertices for all triangles in this geometry are described to the space in which the acceleration structure is defined.</li>
                </ul>
            </li>
            <li>For geometries of type #GEOMETRY_TYPE_AABBS_KHR, {@code primitiveCount} is the number of axis-aligned bounding boxes. {@code primitiveCount} ##VkAabbPositionsKHR structures are consumed from ##VkAccelerationStructureGeometryAabbsDataKHR{@code ::data}, starting at an offset of {@code primitiveOffset}.</li>
            <li>For geometries of type #GEOMETRY_TYPE_INSTANCES_KHR, {@code primitiveCount} is the number of acceleration structures. {@code primitiveCount} ##VkAccelerationStructureInstanceKHR or ##VkAccelerationStructureMotionInstanceNV structures are consumed from ##VkAccelerationStructureGeometryInstancesDataKHR{@code ::data}, starting at an offset of {@code primitiveOffset}.</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>For geometries of type #GEOMETRY_TYPE_TRIANGLES_KHR, if the geometry uses indices, the offset {@code primitiveOffset} from ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::indexData} <b>must</b> be a multiple of the element size of ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::indexType}</li>
            <li>For geometries of type #GEOMETRY_TYPE_TRIANGLES_KHR, if the geometry does not use indices, the offset {@code primitiveOffset} from ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::vertexData} <b>must</b> be a multiple of the component size of ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::vertexFormat}</li>
            <li>For geometries of type #GEOMETRY_TYPE_TRIANGLES_KHR, the offset {@code transformOffset} from ##VkAccelerationStructureGeometryTrianglesDataKHR{@code ::transformData} <b>must</b> be a multiple of 16</li>
            <li>For geometries of type #GEOMETRY_TYPE_AABBS_KHR, the offset {@code primitiveOffset} from ##VkAccelerationStructureGeometryAabbsDataKHR{@code ::data} <b>must</b> be a multiple of 8</li>
            <li>For geometries of type #GEOMETRY_TYPE_INSTANCES_KHR, the offset {@code primitiveOffset} from ##VkAccelerationStructureGeometryInstancesDataKHR{@code ::data} <b>must</b> be a multiple of 16</li>
        </ul>

        <h5>See Also</h5>
        #BuildAccelerationStructuresKHR(), #CmdBuildAccelerationStructuresKHR()
        """

    uint32_t("primitiveCount", "defines the number of primitives for a corresponding acceleration structure geometry.")
    uint32_t("primitiveOffset", "defines an offset in bytes into the memory where primitive data is defined.")
    uint32_t("firstVertex", "the index of the first vertex to build from for triangle geometry.")
    uint32_t("transformOffset", "defines an offset in bytes into the memory where a transform matrix is defined.")
}

val VkAabbPositionsKHR = struct(Module.VULKAN, "VkAabbPositionsKHR") {
    documentation =
        """
        Structure specifying two opposing corners of an axis-aligned bounding box.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code minX} <b>must</b> be less than or equal to {@code maxX}</li>
            <li>{@code minY} <b>must</b> be less than or equal to {@code maxY}</li>
            <li>{@code minZ} <b>must</b> be less than or equal to {@code maxZ}</li>
        </ul>
        """

    float("minX", "the x position of one opposing corner of a bounding box.")
    float("minY", "the y position of one opposing corner of a bounding box.")
    float("minZ", "the z position of one opposing corner of a bounding box.")
    float("maxX", "the x position of the other opposing corner of a bounding box.")
    float("maxY", "the y position of the other opposing corner of a bounding box.")
    float("maxZ", "the z position of the other opposing corner of a bounding box.")
}

val VkAccelerationStructureGeometryTrianglesDataKHR = struct(Module.VULKAN, "VkAccelerationStructureGeometryTrianglesDataKHR") {
    documentation =
        """
        Structure specifying a triangle geometry in a bottom-level acceleration structure.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Unlike the stride for vertex buffers in ##VkVertexInputBindingDescription for graphics pipelines which must not exceed {@code maxVertexInputBindingStride}, {@code vertexStride} for acceleration structure geometry is instead restricted to being a 32-bit value.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code vertexStride} <b>must</b> be a multiple of the size in bytes of the smallest component of {@code vertexFormat}</li>
            <li>{@code vertexStride} <b>must</b> be less than or equal to <code>2<sup>32</sup>-1</code></li>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#resources-buffer-view-format-features">format features</a> of {@code vertexFormat} <b>must</b> contain #FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR</li>
            <li>{@code indexType} <b>must</b> be #INDEX_TYPE_UINT16, #INDEX_TYPE_UINT32, or #INDEX_TYPE_NONE_KHR</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkAccelerationStructureGeometryMotionTrianglesDataNV, ##VkAccelerationStructureTrianglesDisplacementMicromapNV, or ##VkAccelerationStructureTrianglesOpacityMicromapEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code vertexFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code indexType} <b>must</b> be a valid {@code VkIndexType} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureGeometryDataKHR, ##VkDeviceOrHostAddressConstKHR
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkAccelerationStructureGeometryMotionTrianglesDataNV", "VkAccelerationStructureTrianglesDisplacementMicromapNV", "VkAccelerationStructureTrianglesOpacityMicromapEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFormat("vertexFormat", "the {@code VkFormat} of each vertex element.")
    VkDeviceOrHostAddressConstKHR("vertexData", "a device or host address to memory containing vertex data for this geometry.")
    VkDeviceSize("vertexStride", "the stride in bytes between each vertex.")
    uint32_t("maxVertex", "the highest index of a vertex that will be addressed by a build command using this structure.")
    VkIndexType("indexType", "the {@code VkIndexType} of each index element.")
    VkDeviceOrHostAddressConstKHR("indexData", "a device or host address to memory containing index data for this geometry.")
    VkDeviceOrHostAddressConstKHR("transformData", "a device or host address to memory containing an optional reference to a ##VkTransformMatrixKHR structure describing a transformation from the space in which the vertices in this geometry are described to the space in which the acceleration structure is defined.")
}

val VkTransformMatrixKHR = struct(Module.VULKAN, "VkTransformMatrixKHR") {
    documentation =
        """
        Structure specifying a 3x4 affine transformation matrix.

        <h5>Valid Usage</h5>
        <ul>
            <li>The first three columns of {@code matrix} <b>must</b> define an invertible 3x3 matrix</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureInstanceKHR, ##VkAccelerationStructureMatrixMotionInstanceNV
        """

    float("matrix", "a 3x4 row-major affine transformation matrix.")[3][4]
}

val VkAccelerationStructureGeometryAabbsDataKHR = struct(Module.VULKAN, "VkAccelerationStructureGeometryAabbsDataKHR") {
    documentation =
        """
        Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code stride} <b>must</b> be a multiple of 8</li>
            <li>{@code stride} <b>must</b> be less than or equal to <code>2<sup>32</sup>-1</code></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureGeometryDataKHR, ##VkDeviceOrHostAddressConstKHR
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceOrHostAddressConstKHR("data", "a device or host address to memory containing ##VkAabbPositionsKHR structures containing position data for each axis-aligned bounding box in the geometry.")
    VkDeviceSize("stride", "the stride in bytes between each entry in {@code data}. The stride <b>must</b> be a multiple of 8.")
}

val VkAccelerationStructureGeometryInstancesDataKHR = struct(Module.VULKAN, "VkAccelerationStructureGeometryInstancesDataKHR") {
    documentation =
        """
        Structure specifying a geometry consisting of instances of other acceleration structures.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureGeometryDataKHR, ##VkDeviceOrHostAddressConstKHR
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("arrayOfPointers", "specifies whether {@code data} is used as an array of addresses or just an array.")
    VkDeviceOrHostAddressConstKHR("data", "either the address of an array of device or host addresses referencing individual ##VkAccelerationStructureInstanceKHR structures or packed motion instance information as described in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#acceleration-structure-motion-instances\">motion instances</a> if {@code arrayOfPointers} is #TRUE, or the address of an array of ##VkAccelerationStructureInstanceKHR or ##VkAccelerationStructureMotionInstanceNV structures. Addresses and ##VkAccelerationStructureInstanceKHR structures are tightly packed. ##VkAccelerationStructureMotionInstanceNV structures have a stride of 160 bytes.")
}

val VkAccelerationStructureGeometryDataKHR = union(Module.VULKAN, "VkAccelerationStructureGeometryDataKHR") {
    documentation =
        """
        Union specifying acceleration structure geometry data.

        <h5>See Also</h5>
        ##VkAccelerationStructureGeometryAabbsDataKHR, ##VkAccelerationStructureGeometryInstancesDataKHR, ##VkAccelerationStructureGeometryKHR, ##VkAccelerationStructureGeometryTrianglesDataKHR
        """

    VkAccelerationStructureGeometryTrianglesDataKHR("triangles", "a ##VkAccelerationStructureGeometryTrianglesDataKHR structure.")
    VkAccelerationStructureGeometryAabbsDataKHR("aabbs", "a ##VkAccelerationStructureGeometryAabbsDataKHR structure.")
    VkAccelerationStructureGeometryInstancesDataKHR("instances", "a ##VkAccelerationStructureGeometryInstancesDataKHR structure.")
}

val VkAccelerationStructureGeometryKHR = struct(Module.VULKAN, "VkAccelerationStructureGeometryKHR") {
    documentation =
        """
        Structure specifying geometries to be built into an acceleration structure.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code geometryType} <b>must</b> be a valid {@code VkGeometryTypeKHR} value</li>
            <li>If {@code geometryType} is #GEOMETRY_TYPE_TRIANGLES_KHR, the {@code triangles} member of {@code geometry} <b>must</b> be a valid ##VkAccelerationStructureGeometryTrianglesDataKHR structure</li>
            <li>If {@code geometryType} is #GEOMETRY_TYPE_AABBS_KHR, the {@code aabbs} member of {@code geometry} <b>must</b> be a valid ##VkAccelerationStructureGeometryAabbsDataKHR structure</li>
            <li>If {@code geometryType} is #GEOMETRY_TYPE_INSTANCES_KHR, the {@code instances} member of {@code geometry} <b>must</b> be a valid ##VkAccelerationStructureGeometryInstancesDataKHR structure</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkGeometryFlagBitsKHR} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureBuildGeometryInfoKHR, ##VkAccelerationStructureGeometryDataKHR
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkGeometryTypeKHR("geometryType", "describes which type of geometry this ##VkAccelerationStructureGeometryKHR refers to.")
    VkAccelerationStructureGeometryDataKHR("geometry", "a ##VkAccelerationStructureGeometryDataKHR union describing the geometry data for the relevant geometry type.")
    VkGeometryFlagsKHR("flags", "a bitmask of {@code VkGeometryFlagBitsKHR} values describing additional properties of how the geometry should be built.")
}

val VkAccelerationStructureBuildGeometryInfoKHR = struct(Module.VULKAN, "VkAccelerationStructureBuildGeometryInfoKHR") {
    documentation =
        """
        Structure specifying the geometry data used to build an acceleration structure.

        <h5>Description</h5>
        Only one of {@code pGeometries} or {@code ppGeometries} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}. Each element of the non-{@code NULL} array describes the data used to build each acceleration structure geometry.

        The index of each element of the {@code pGeometries} or {@code ppGeometries} members of ##VkAccelerationStructureBuildGeometryInfoKHR is used as the <em>geometry index</em> during ray traversal. The geometry index is available in ray shaders via the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-builtin-variables-raygeometryindex">{@code RayGeometryIndexKHR} built-in</a>, and is <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#shader-binding-table-hit-shader-indexing">used to determine hit and intersection shaders executed during traversal</a>. The geometry index is available to ray queries via the {@code OpRayQueryGetIntersectionGeometryIndexKHR} instruction.

        Setting #BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in {@code flags} indicates that this build is a motion top level acceleration structure. A motion top level uses instances of format ##VkAccelerationStructureMotionInstanceNV if ##VkAccelerationStructureGeometryInstancesDataKHR{@code ::arrayOfPointers} is #FALSE.

        If ##VkAccelerationStructureGeometryInstancesDataKHR{@code ::arrayOfPointers} is #TRUE, the pointer for each element of the array of instance pointers consists of 4 bits of {@code VkAccelerationStructureMotionInstanceTypeNV} in the low 4 bits of the pointer identifying the type of structure at the pointer. The device address accessed is the value in the array with the low 4 bits set to zero. The structure at the pointer is one of ##VkAccelerationStructureInstanceKHR, ##VkAccelerationStructureMatrixMotionInstanceNV or ##VkAccelerationStructureSRTMotionInstanceNV, depending on the type value encoded in the low 4 bits.

        A top level acceleration structure with either motion instances or vertex motion in its instances <b>must</b> set #BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in {@code flags}.

        Members {@code srcAccelerationStructure} and {@code dstAccelerationStructure} <b>may</b> be the same or different for an update operation (when {@code mode} is #BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR). If they are the same, the update happens in-place. Otherwise, the target acceleration structure is updated and the source is not modified.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code type} <b>must</b> not be #ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR</li>
            <li>Only one of {@code pGeometries} or {@code ppGeometries} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, the {@code geometryType} member of elements of either {@code pGeometries} or {@code ppGeometries} <b>must</b> be #GEOMETRY_TYPE_INSTANCES_KHR</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, {@code geometryCount} <b>must</b> be 1</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR the {@code geometryType} member of elements of either {@code pGeometries} or {@code ppGeometries} <b>must</b> not be #GEOMETRY_TYPE_INSTANCES_KHR</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR then the {@code geometryType} member of each geometry in either {@code pGeometries} or {@code ppGeometries} <b>must</b> be the same</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR then {@code geometryCount} <b>must</b> be less than or equal to ##VkPhysicalDeviceAccelerationStructurePropertiesKHR{@code ::maxGeometryCount}</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR and the {@code geometryType} member of either {@code pGeometries} or {@code ppGeometries} is #GEOMETRY_TYPE_AABBS_KHR, the total number of AABBs in all geometries <b>must</b> be less than or equal to ##VkPhysicalDeviceAccelerationStructurePropertiesKHR{@code ::maxPrimitiveCount}</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR and the {@code geometryType} member of either {@code pGeometries} or {@code ppGeometries} is #GEOMETRY_TYPE_TRIANGLES_KHR, the total number of triangles in all geometries <b>must</b> be less than or equal to ##VkPhysicalDeviceAccelerationStructurePropertiesKHR{@code ::maxPrimitiveCount}</li>
            <li>If {@code flags} has the #BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR bit set, then it <b>must</b> not have the #BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR bit set</li>
            <li>If {@code dstAccelerationStructure} was created with #ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV set in ##VkAccelerationStructureCreateInfoKHR{@code ::flags}, #BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV <b>must</b> be set in {@code flags}</li>
            <li>If #BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV is set in {@code flags}, {@code dstAccelerationStructure} <b>must</b> have been created with #ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV set in ##VkAccelerationStructureCreateInfoKHR{@code ::flags}</li>
            <li>If #BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV is set in {@code flags}, {@code type} <b>must</b> not be #ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR</li>
            <li>If {@code flags} has the #BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT bit set then it <b>must</b> not have the #BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT bit set</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkAccelerationStructureTypeKHR} value</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkBuildAccelerationStructureFlagBitsKHR} values</li>
            <li>If {@code geometryCount} is not 0, and {@code pGeometries} is not {@code NULL}, {@code pGeometries} <b>must</b> be a valid pointer to an array of {@code geometryCount} valid ##VkAccelerationStructureGeometryKHR structures</li>
            <li>If {@code geometryCount} is not 0, and {@code ppGeometries} is not {@code NULL}, {@code ppGeometries} <b>must</b> be a valid pointer to an array of {@code geometryCount} valid pointers to valid ##VkAccelerationStructureGeometryKHR structures</li>
            <li>Both of {@code dstAccelerationStructure}, and {@code srcAccelerationStructure} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureGeometryKHR, ##VkDeviceOrHostAddressKHR, #BuildAccelerationStructuresKHR(), #CmdBuildAccelerationStructuresIndirectKHR(), #CmdBuildAccelerationStructuresKHR(), #GetAccelerationStructureBuildSizesKHR()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureTypeKHR("type", "a {@code VkAccelerationStructureTypeKHR} value specifying the type of acceleration structure being built.")
    VkBuildAccelerationStructureFlagsKHR("flags", "a bitmask of {@code VkBuildAccelerationStructureFlagBitsKHR} specifying additional parameters of the acceleration structure.")
    VkBuildAccelerationStructureModeKHR("mode", "a {@code VkBuildAccelerationStructureModeKHR} value specifying the type of operation to perform.")
    VkAccelerationStructureKHR("srcAccelerationStructure", "a pointer to an existing acceleration structure that is to be used to update the {@code dst} acceleration structure when {@code mode} is #BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR.")
    VkAccelerationStructureKHR("dstAccelerationStructure", "a pointer to the target acceleration structure for the build.")
    AutoSize("pGeometries", "ppGeometries", optional = true)..uint32_t("geometryCount", "specifies the number of geometries that will be built into {@code dstAccelerationStructure}.")
    nullable..VkAccelerationStructureGeometryKHR.const.p("pGeometries", "a pointer to an array of ##VkAccelerationStructureGeometryKHR structures.")
    nullable..VkAccelerationStructureGeometryKHR.const.p.const.p("ppGeometries", "a pointer to an array of pointers to ##VkAccelerationStructureGeometryKHR structures.")
    VkDeviceOrHostAddressKHR("scratchData", "the device or host address to memory that will be used as scratch memory for the build.")
}

val VkAccelerationStructureInstanceKHR = struct(Module.VULKAN, "VkAccelerationStructureInstanceKHR") {
    documentation =
        """
        Structure specifying a single acceleration structure instance for building into an acceleration structure geometry.

        <h5>Description</h5>
        The C language specification does not define the ordering of bit-fields, but in practice, this struct produces the correct layout with existing compilers. The intended bit pattern is for the following:

        <ul>
            <li>
                {@code instanceCustomIndex} and {@code mask} occupy the same memory as if a single {@code uint32_t} was specified in their place
                <ul>
                    <li>{@code instanceCustomIndex} occupies the 24 least significant bits of that memory</li>
                    <li>{@code mask} occupies the 8 most significant bits of that memory</li>
                </ul>
            </li>
            <li>
                {@code instanceShaderBindingTableRecordOffset} and {@code flags} occupy the same memory as if a single {@code uint32_t} was specified in their place
                <ul>
                    <li>{@code instanceShaderBindingTableRecordOffset} occupies the 24 least significant bits of that memory</li>
                    <li>{@code flags} occupies the 8 most significant bits of that memory</li>
                </ul>
            </li>
        </ul>

        If a compiler produces code that diverges from that pattern, applications <b>must</b> employ another method to set values according to the correct bit pattern.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkGeometryInstanceFlagBitsKHR} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureMotionInstanceDataNV, ##VkTransformMatrixKHR
        """

    VkTransformMatrixKHR("transform", "a ##VkTransformMatrixKHR structure describing a transformation to be applied to the acceleration structure.")
    uint32_t("instanceCustomIndex", "a 24-bit user-specified index value accessible to ray shaders in the {@code InstanceCustomIndexKHR} built-in.", bits = 24)
    uint32_t("mask", "an 8-bit visibility mask for the geometry. The instance <b>may</b> only be hit if {@code Cull Mask &amp; instance.mask != 0}", bits = 8)
    uint32_t("instanceShaderBindingTableRecordOffset", "a 24-bit offset used in calculating the hit shader binding table index.", bits = 24)
    VkGeometryInstanceFlagsKHR("flags", "an 8-bit mask of {@code VkGeometryInstanceFlagBitsKHR} values to apply to this instance.", bits = 8)
    uint64_t("accelerationStructureReference", """either:

        <ul>
            <li>a device address containing the value obtained from #GetAccelerationStructureDeviceAddressKHR() or #GetAccelerationStructureHandleNV() (used by device operations which reference acceleration structures) or,</li>
            <li>a {@code VkAccelerationStructureKHR} object (used by host operations which reference acceleration structures).</li>
        </ul>""")
}

val VkAccelerationStructureCreateInfoKHR = struct(Module.VULKAN, "VkAccelerationStructureCreateInfoKHR") {
    documentation =
        """
        Structure specifying the parameters of a newly created acceleration structure object.

        <h5>Description</h5>
        If {@code deviceAddress} is zero, no specific address is requested.

        If {@code deviceAddress} is not zero, {@code deviceAddress} <b>must</b> be an address retrieved from an identically created acceleration structure on the same implementation. The acceleration structure <b>must</b> also be placed on an identically created {@code buffer} and at the same {@code offset}.

        Applications <b>should</b> avoid creating acceleration structures with application-provided addresses and implementation-provided addresses in the same process, to reduce the likelihood of #ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR errors.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The expected usage for this is that a trace capture/replay tool will add the #BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT flag to all buffers that use #BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, and will add #BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT to all buffers used as storage for an acceleration structure where {@code deviceAddress} is not zero. This also means that the tool will need to add #MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT to memory allocations to allow the flag to be set where the application may not have otherwise required it. During capture the tool will save the queried opaque device addresses in the trace. During replay, the buffers will be created specifying the original address so any address values stored in the trace data will remain valid.

        Implementations are expected to separate such buffers in the GPU address space so normal allocations will avoid using these addresses. Apps/tools should avoid mixing app-provided and implementation-provided addresses for buffers created with #BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, to avoid address space allocation conflicts.
        </div>

        Applications <b>should</b> create an acceleration structure with a specific {@code VkAccelerationStructureTypeKHR} other than #ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        #ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR is intended to be used by API translation layers. This can be used at acceleration structure creation time in cases where the actual acceleration structure type (top or bottom) is not yet known. The actual acceleration structure type must be specified as #ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR or #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR when the build is performed.
        </div>

        If the acceleration structure will be the target of a build operation, the required size for an acceleration structure <b>can</b> be queried with #GetAccelerationStructureBuildSizesKHR(). If the acceleration structure is going to be the target of a compacting copy, #CmdWriteAccelerationStructuresPropertiesKHR() or #WriteAccelerationStructuresPropertiesKHR() <b>can</b> be used to obtain the compacted size required.

        If the acceleration structure will be the target of a build operation with #BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV it <b>must</b> include #ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV in {@code createFlags} and include ##VkAccelerationStructureMotionInfoNV as an extension structure in {@code pNext} with the number of instances as metadata for the object.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code deviceAddress} is not zero, {@code createFlags} <b>must</b> include #ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR</li>
            <li>If {@code createFlags} includes #ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR, ##VkPhysicalDeviceAccelerationStructureFeaturesKHR{@code ::accelerationStructureCaptureReplay} <b>must</b> be #TRUE</li>
            <li>{@code buffer} <b>must</b> have been created with a {@code usage} value containing #BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR</li>
            <li>{@code buffer} <b>must</b> not have been created with #BUFFER_CREATE_SPARSE_RESIDENCY_BIT</li>
            <li>The sum of {@code offset} and {@code size} <b>must</b> be less than the size of {@code buffer}</li>
            <li>{@code offset} <b>must</b> be a multiple of 256 bytes</li>
            <li>If #ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV is set in {@code createFlags} and {@code type} is #ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, one member of the {@code pNext} chain <b>must</b> be a pointer to a valid instance of ##VkAccelerationStructureMotionInfoNV</li>
            <li>If any geometry includes ##VkAccelerationStructureGeometryMotionTrianglesDataNV then {@code createFlags} <b>must</b> contain #ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV</li>
            <li>If {@code createFlags} includes #ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-descriptorBufferCaptureReplay">{@code descriptorBufferCaptureReplay}</a> feature <b>must</b> be enabled</li>
            <li>If the {@code pNext} chain includes a ##VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, {@code createFlags} <b>must</b> contain #ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkAccelerationStructureMotionInfoNV or ##VkOpaqueCaptureDescriptorDataCreateInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code createFlags} <b>must</b> be a valid combination of {@code VkAccelerationStructureCreateFlagBitsKHR} values</li>
            <li>{@code buffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code type} <b>must</b> be a valid {@code VkAccelerationStructureTypeKHR} value</li>
        </ul>

        <h5>See Also</h5>
        #CreateAccelerationStructureKHR()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkAccelerationStructureMotionInfoNV", "VkOpaqueCaptureDescriptorDataCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureCreateFlagsKHR("createFlags", "a bitmask of {@code VkAccelerationStructureCreateFlagBitsKHR} specifying additional creation parameters of the acceleration structure.")
    VkBuffer("buffer", "the buffer on which the acceleration structure will be stored.")
    VkDeviceSize("offset", "an offset in bytes from the base address of the buffer at which the acceleration structure will be stored, and <b>must</b> be a multiple of 256.")
    VkDeviceSize("size", "the size required for the acceleration structure.")
    VkAccelerationStructureTypeKHR("type", "a {@code VkAccelerationStructureTypeKHR} value specifying the type of acceleration structure that will be created.")
    VkDeviceAddress("deviceAddress", "the device address requested for the acceleration structure if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-accelerationStructureCaptureReplay\">{@code accelerationStructureCaptureReplay}</a> feature is being used.")
}

val VkWriteDescriptorSetAccelerationStructureKHR = struct(Module.VULKAN, "VkWriteDescriptorSetAccelerationStructureKHR") {
    documentation =
        """
        Structure specifying acceleration structure descriptor information.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code accelerationStructureCount} <b>must</b> be equal to {@code descriptorCount} in the extended structure</li>
            <li>Each acceleration structure in {@code pAccelerationStructures} <b>must</b> have been created with a {@code type} of #ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR or #ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, each element of {@code pAccelerationStructures} <b>must</b> not be #NULL_HANDLE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR</li>
            <li>{@code pAccelerationStructures} <b>must</b> be a valid pointer to an array of {@code accelerationStructureCount} valid or #NULL_HANDLE {@code VkAccelerationStructureKHR} handles</li>
            <li>{@code accelerationStructureCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pAccelerationStructures", optional = true)..uint32_t("accelerationStructureCount", "the number of elements in {@code pAccelerationStructures}.")
    nullable..VkAccelerationStructureKHR.const.p("pAccelerationStructures", "a pointer to an array of {@code VkAccelerationStructureKHR} structures specifying the acceleration structures to update.")
}

val VkPhysicalDeviceAccelerationStructureFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceAccelerationStructureFeaturesKHR") {
    documentation =
        """
        Structure describing the acceleration structure features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceAccelerationStructureFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceAccelerationStructureFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("accelerationStructure", "indicates whether the implementation supports the acceleration structure functionality. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#acceleration-structure\">Acceleration Structures</a>.")
    VkBool32("accelerationStructureCaptureReplay", "indicates whether the implementation supports saving and reusing acceleration structure device addresses, e.g. for trace capture and replay.")
    VkBool32("accelerationStructureIndirectBuild", "indicates whether the implementation supports indirect acceleration structure build commands, e.g. #CmdBuildAccelerationStructuresIndirectKHR().")
    VkBool32("accelerationStructureHostCommands", "indicates whether the implementation supports host side acceleration structure commands, e.g. #BuildAccelerationStructuresKHR(), #CopyAccelerationStructureKHR(), #CopyAccelerationStructureToMemoryKHR(), #CopyMemoryToAccelerationStructureKHR(), #WriteAccelerationStructuresPropertiesKHR().")
    VkBool32("descriptorBindingAccelerationStructureUpdateAfterBind", "indicates whether the implementation supports updating acceleration structure descriptors after a set is bound. If this feature is not enabled, #DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT <b>must</b> not be used with #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR.")
}

val VkPhysicalDeviceAccelerationStructurePropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceAccelerationStructurePropertiesKHR", mutable = false) {
    documentation =
        """
        Properties of the physical device for acceleration structure.

        <h5>Description</h5>
        Due to the fact that the geometry, instance, and primitive counts are specified at acceleration structure creation as 32-bit values, <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxGeometryCount">{@code maxGeometryCount}</a>, <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxInstanceCount">{@code maxInstanceCount}</a>, and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxPrimitiveCount">{@code maxPrimitiveCount}</a> <b>must</b> not exceed <code>2<sup>32</sup>-1</code>.

        If the ##VkPhysicalDeviceAccelerationStructurePropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        Limits specified by this structure <b>must</b> match those specified with the same name in ##VkPhysicalDeviceRayTracingPropertiesNV.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint64_t("maxGeometryCount", "the maximum number of geometries in the bottom level acceleration structure.")
    uint64_t("maxInstanceCount", "the maximum number of instances in the top level acceleration structure.")
    uint64_t("maxPrimitiveCount", "the maximum number of triangles or AABBs in all geometries in the bottom level acceleration structure.")
    uint32_t("maxPerStageDescriptorAccelerationStructures", "the maximum number of acceleration structure bindings that <b>can</b> be accessible to a single shader stage in a pipeline layout. Descriptor bindings with a descriptor type of #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR count against this limit. Only descriptor bindings in descriptor set layouts created without the #DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set count against this limit.")
    uint32_t("maxPerStageDescriptorUpdateAfterBindAccelerationStructures", "similar to {@code maxPerStageDescriptorAccelerationStructures} but counts descriptor bindings from descriptor sets created with or without the #DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set.")
    uint32_t("maxDescriptorSetAccelerationStructures", "the maximum number of acceleration structure descriptors that <b>can</b> be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptor bindings with a descriptor type of #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR count against this limit. Only descriptor bindings in descriptor set layouts created without the #DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set count against this limit.")
    uint32_t("maxDescriptorSetUpdateAfterBindAccelerationStructures", "similar to {@code maxDescriptorSetAccelerationStructures} but counts descriptor bindings from descriptor sets created with or without the #DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set.")
    uint32_t("minAccelerationStructureScratchOffsetAlignment", "the minimum <b>required</b> alignment, in bytes, for scratch data passed in to an acceleration structure build command. The value <b>must</b> be a power of two.")
}

val VkAccelerationStructureDeviceAddressInfoKHR = struct(Module.VULKAN, "VkAccelerationStructureDeviceAddressInfoKHR") {
    documentation =
        """
        Structure specifying the acceleration structure to query an address for.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code accelerationStructure} <b>must</b> be a valid {@code VkAccelerationStructureKHR} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetAccelerationStructureDeviceAddressKHR()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureKHR("accelerationStructure", "specifies the acceleration structure whose address is being queried.")
}

val VkAccelerationStructureVersionInfoKHR = struct(Module.VULKAN, "VkAccelerationStructureVersionInfoKHR") {
    documentation =
        """
        Acceleration structure version information.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        {@code pVersionData} is a <em>pointer</em> to an array of 2×#UUID_SIZE {@code uint8_t} values instead of two #UUID_SIZE arrays as the expected use case for this member is to be pointed at the header of a previously serialized acceleration structure (via #CmdCopyAccelerationStructureToMemoryKHR() or #CopyAccelerationStructureToMemoryKHR()) that is loaded in memory. Using arrays would necessitate extra memory copies of the UUIDs.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pVersionData} <b>must</b> be a valid pointer to an array of 2 &times; {@code VK_UUID_SIZE} {@code uint8_t} values</li>
        </ul>

        <h5>See Also</h5>
        #GetDeviceAccelerationStructureCompatibilityKHR()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint8_t.const.p("pVersionData", "a pointer to the version header of an acceleration structure as defined in #CmdCopyAccelerationStructureToMemoryKHR()")
}

val VkCopyAccelerationStructureToMemoryInfoKHR = struct(Module.VULKAN, "VkCopyAccelerationStructureToMemoryInfoKHR") {
    documentation =
        """
        Parameters for serializing an acceleration structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>The source acceleration structure {@code src} <b>must</b> have been constructed prior to the execution of this command</li>
            <li>The memory pointed to by {@code dst} <b>must</b> be at least as large as the serialization size of {@code src}, as reported by #WriteAccelerationStructuresPropertiesKHR() or #CmdWriteAccelerationStructuresPropertiesKHR() with a query type of #QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR</li>
            <li>{@code mode} <b>must</b> be #COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code src} <b>must</b> be a valid {@code VkAccelerationStructureKHR} handle</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkCopyAccelerationStructureModeKHR} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressKHR, #CmdCopyAccelerationStructureToMemoryKHR(), #CopyAccelerationStructureToMemoryKHR()
        """

    Expression("#STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureKHR("src", "the source acceleration structure for the copy")
    VkDeviceOrHostAddressKHR("dst", "the device or host address to memory which is the target for the copy")
    VkCopyAccelerationStructureModeKHR("mode", "a {@code VkCopyAccelerationStructureModeKHR} value specifying additional operations to perform during the copy.")
}

val VkCopyMemoryToAccelerationStructureInfoKHR = struct(Module.VULKAN, "VkCopyMemoryToAccelerationStructureInfoKHR") {
    documentation =
        """
        Parameters for deserializing an acceleration structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>The source memory pointed to by {@code src} <b>must</b> contain data previously serialized using #CmdCopyAccelerationStructureToMemoryKHR(), potentially modified to relocate acceleration structure references as described in that command</li>
            <li>{@code mode} <b>must</b> be #COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR</li>
            <li>The data in {@code src} <b>must</b> have a format compatible with the destination physical device as returned by #GetDeviceAccelerationStructureCompatibilityKHR()</li>
            <li>{@code dst} <b>must</b> have been created with a {@code size} greater than or equal to that used to serialize the data in {@code src}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code dst} <b>must</b> be a valid {@code VkAccelerationStructureKHR} handle</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkCopyAccelerationStructureModeKHR} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstKHR, #CmdCopyMemoryToAccelerationStructureKHR(), #CopyMemoryToAccelerationStructureKHR()
        """

    Expression("#STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceOrHostAddressConstKHR("src", "the device or host address to memory containing the source data for the copy.")
    VkAccelerationStructureKHR("dst", "the target acceleration structure for the copy.")
    VkCopyAccelerationStructureModeKHR("mode", "a {@code VkCopyAccelerationStructureModeKHR} value specifying additional operations to perform during the copy.")
}

val VkCopyAccelerationStructureInfoKHR = struct(Module.VULKAN, "VkCopyAccelerationStructureInfoKHR") {
    documentation =
        """
        Parameters for copying an acceleration structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code mode} <b>must</b> be #COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR or #COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR</li>
            <li>The source acceleration structure {@code src} <b>must</b> have been constructed prior to the execution of this command</li>
            <li>If {@code mode} is #COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR, {@code src} <b>must</b> have been constructed with #BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR in the build</li>
            <li>The {@code buffer} used to create {@code src} <b>must</b> be bound to device memory</li>
            <li>The {@code buffer} used to create {@code dst} <b>must</b> be bound to device memory</li>
            <li>The range of memory backing {@code dst} that is accessed by this command <b>must</b> not overlap the memory backing {@code src} that is accessed by this command</li>
            <li>{@code dst} <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object via #BindAccelerationStructureMemoryNV()</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code src} <b>must</b> be a valid {@code VkAccelerationStructureKHR} handle</li>
            <li>{@code dst} <b>must</b> be a valid {@code VkAccelerationStructureKHR} handle</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkCopyAccelerationStructureModeKHR} value</li>
            <li>Both of {@code dst}, and {@code src} <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #CmdCopyAccelerationStructureKHR(), #CopyAccelerationStructureKHR()
        """

    Expression("#STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureKHR("src", "the source acceleration structure for the copy.")
    VkAccelerationStructureKHR("dst", "the target acceleration structure for the copy.")
    VkCopyAccelerationStructureModeKHR("mode", "a {@code VkCopyAccelerationStructureModeKHR} value specifying additional operations to perform during the copy.")
}

val VkAccelerationStructureBuildSizesInfoKHR = struct(Module.VULKAN, "VkAccelerationStructureBuildSizesInfoKHR") {
    documentation =
        """
        Structure specifying build sizes for an acceleration structure.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetAccelerationStructureBuildSizesKHR()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceSize("accelerationStructureSize", "the size in bytes required in a {@code VkAccelerationStructureKHR} for a build or update operation.")
    VkDeviceSize("updateScratchSize", "the size in bytes required in a scratch buffer for an update operation.")
    VkDeviceSize("buildScratchSize", "the size in bytes required in a scratch buffer for a build operation.")
}

val VkRayTracingShaderGroupCreateInfoKHR = struct(Module.VULKAN, "VkRayTracingShaderGroupCreateInfoKHR") {
    documentation =
        """
        Structure specifying shaders in a shader group.

        <h5>Description</h5>
        If the pipeline is created with #PIPELINE_CREATE_LIBRARY_BIT_KHR and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineLibraryGroupHandles">pipelineLibraryGroupHandles</a> feature is enabled, {@code pShaderGroupCaptureReplayHandle} is inherited by all pipelines which link against this pipeline and remains bitwise identical for any pipeline which references this pipeline library.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then {@code generalShader} <b>must</b> be a valid index into ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} referring to a shader of #SHADER_STAGE_RAYGEN_BIT_KHR, #SHADER_STAGE_MISS_BIT_KHR, or #SHADER_STAGE_CALLABLE_BIT_KHR</li>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then {@code closestHitShader}, {@code anyHitShader}, and {@code intersectionShader} <b>must</b> be #SHADER_UNUSED_KHR</li>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR then {@code intersectionShader} <b>must</b> be a valid index into ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} referring to a shader of #SHADER_STAGE_INTERSECTION_BIT_KHR</li>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR then {@code intersectionShader} <b>must</b> be #SHADER_UNUSED_KHR</li>
            <li>{@code closestHitShader} <b>must</b> be either #SHADER_UNUSED_KHR or a valid index into ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} referring to a shader of #SHADER_STAGE_CLOSEST_HIT_BIT_KHR</li>
            <li>{@code anyHitShader} <b>must</b> be either #SHADER_UNUSED_KHR or a valid index into ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} referring to a shader of #SHADER_STAGE_ANY_HIT_BIT_KHR</li>
            <li>If ##VkPhysicalDeviceRayTracingPipelineFeaturesKHR{@code ::rayTracingPipelineShaderGroupHandleCaptureReplayMixed} is #FALSE then {@code pShaderGroupCaptureReplayHandle} <b>must</b> not be provided if it has not been provided on a previous call to ray tracing pipeline creation</li>
            <li>If ##VkPhysicalDeviceRayTracingPipelineFeaturesKHR{@code ::rayTracingPipelineShaderGroupHandleCaptureReplayMixed} is #FALSE then the caller <b>must</b> guarantee that no ray tracing pipeline creation commands with {@code pShaderGroupCaptureReplayHandle} provided execute simultaneously with ray tracing pipeline creation commands without {@code pShaderGroupCaptureReplayHandle} provided</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkRayTracingShaderGroupTypeKHR} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkRayTracingPipelineCreateInfoKHR
        """

    Expression("#STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkRayTracingShaderGroupTypeKHR("type", "the type of hit group specified in this structure.")
    uint32_t("generalShader", "the index of the ray generation, miss, or callable shader from ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR, and #SHADER_UNUSED_KHR otherwise.")
    uint32_t("closestHitShader", "the optional index of the closest hit shader from ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and #SHADER_UNUSED_KHR otherwise.")
    uint32_t("anyHitShader", "the optional index of the any-hit shader from ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and #SHADER_UNUSED_KHR otherwise.")
    uint32_t("intersectionShader", "the index of the intersection shader from ##VkRayTracingPipelineCreateInfoKHR{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, and #SHADER_UNUSED_KHR otherwise.")
    nullable..opaque_const_p("pShaderGroupCaptureReplayHandle", "{@code NULL} or a pointer to replay information for this shader group queried from #GetRayTracingCaptureReplayShaderGroupHandlesKHR(), as described in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#ray-tracing-capture-replay\">Ray Tracing Capture Replay</a>. Ignored if ##VkPhysicalDeviceRayTracingPipelineFeaturesKHR{@code ::rayTracingPipelineShaderGroupHandleCaptureReplay} is #FALSE.")
}

val VkRayTracingPipelineInterfaceCreateInfoKHR = struct(Module.VULKAN, "VkRayTracingPipelineInterfaceCreateInfoKHR") {
    documentation =
        """
        Structure specifying additional interface information when using libraries.

        <h5>Description</h5>
        {@code maxPipelineRayPayloadSize} is calculated as the maximum number of bytes used by any block declared in the {@code RayPayloadKHR} or {@code IncomingRayPayloadKHR} storage classes. {@code maxPipelineRayHitAttributeSize} is calculated as the maximum number of bytes used by any block declared in the {@code HitAttributeKHR} storage class. As variables in these storage classes do not have explicit offsets, the size should be calculated as if each variable has a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-alignment-requirements">scalar alignment</a> equal to the largest scalar alignment of any of the block’s members.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        There is no explicit upper limit for {@code maxPipelineRayPayloadSize}, but in practice it should be kept as small as possible. Similar to invocation local memory, it must be allocated for each shader invocation and for devices which support many simultaneous invocations, this storage can rapidly be exhausted, resulting in failure.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code maxPipelineRayHitAttributeSize} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::maxRayHitAttributeSize}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkRayTracingPipelineCreateInfoKHR
        """

    Expression("#STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("maxPipelineRayPayloadSize", "the maximum payload size in bytes used by any shader in the pipeline.")
    uint32_t("maxPipelineRayHitAttributeSize", "the maximum attribute structure size in bytes used by any shader in the pipeline.")
}

val VkRayTracingPipelineCreateInfoKHR = struct(Module.VULKAN, "VkRayTracingPipelineCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters of a newly created ray tracing pipeline.

        <h5>Description</h5>
        The parameters {@code basePipelineHandle} and {@code basePipelineIndex} are described in more detail in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#pipelines-pipeline-derivatives">Pipeline Derivatives</a>.

        When #PIPELINE_CREATE_LIBRARY_BIT_KHR is specified, this pipeline defines a <em>pipeline library</em> which <b>cannot</b> be bound as a ray tracing pipeline directly. Instead, pipeline libraries define common shaders and shader groups which <b>can</b> be included in future pipeline creation.

        If pipeline libraries are included in {@code pLibraryInfo}, shaders defined in those libraries are treated as if they were defined as additional entries in {@code pStages}, appended in the order they appear in the {@code pLibraries} array and in the {@code pStages} array when those libraries were defined.

        When referencing shader groups in order to obtain a shader group handle, groups defined in those libraries are treated as if they were defined as additional entries in {@code pGroups}, appended in the order they appear in the {@code pLibraries} array and in the {@code pGroups} array when those libraries were defined. The shaders these groups reference are set when the pipeline library is created, referencing those specified in the pipeline library, not in the pipeline that includes it.

        The default stack size for a pipeline if #DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR is not provided is computed as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#ray-tracing-pipeline-stack">Ray Tracing Pipeline Stack</a>.

        If a ##VkPipelineCreateFlags2CreateInfoKHR structure is present in the {@code pNext} chain, ##VkPipelineCreateFlags2CreateInfoKHR{@code ::flags} from that structure is used instead of {@code flags} from this structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, and {@code basePipelineIndex} is -1, {@code basePipelineHandle} <b>must</b> be a valid ray tracing {@code VkPipeline} handle</li>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, and {@code basePipelineHandle} is #NULL_HANDLE, {@code basePipelineIndex} <b>must</b> be a valid index into the calling command’s {@code pCreateInfos} parameter</li>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, {@code basePipelineIndex} <b>must</b> be -1 or {@code basePipelineHandle} <b>must</b> be #NULL_HANDLE</li>
            <li>If a push constant block is declared in a shader, a push constant range in {@code layout} <b>must</b> match both the shader stage and range</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader, a descriptor slot in {@code layout} <b>must</b> match the shader stage</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader, and the descriptor type is not #DESCRIPTOR_TYPE_MUTABLE_EXT, a descriptor slot in {@code layout} <b>must</b> match the descriptor type</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader as an array, a descriptor slot in {@code layout} <b>must</b> match the descriptor count</li>
        </ul>

        <ul>
            <li>The shader code for the entry points identified by {@code pStages}, and the rest of the state identified by this structure <b>must</b> adhere to the pipeline linking rules described in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces">Shader Interfaces</a> chapter</li>
            <li>The number of resources in {@code layout} accessible to each shader stage that is used by the pipeline <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxPerStageResources}</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineCreationCacheControl">{@code pipelineCreationCacheControl}</a> feature is not enabled, {@code flags} <b>must</b> not include #PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or #PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT</li>
            <li>If {@code flags} does not include #PIPELINE_CREATE_LIBRARY_BIT_KHR, the {@code stage} member of at least one element of {@code pStages}, including those implicitly added by {@code pLibraryInfo}, <b>must</b> be #SHADER_STAGE_RAYGEN_BIT_KHR</li>
            <li>{@code maxPipelineRayRecursionDepth} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::maxRayRecursionDepth}</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_LIBRARY_BIT_KHR, {@code pLibraryInterface} <b>must</b> not be {@code NULL}</li>
            <li>If {@code pLibraryInfo} is not {@code NULL} and its {@code libraryCount} member is greater than 0, {@code pLibraryInterface} <b>must</b> not be {@code NULL}</li>
            <li>Each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the value of {@code maxPipelineRayRecursionDepth} equal to that in this pipeline</li>
            <li>If {@code pLibraryInfo} is not {@code NULL}, each element of its {@code pLibraries} member <b>must</b> have been created with a {@code layout} that is compatible with the {@code layout} in this pipeline</li>
            <li>If {@code pLibraryInfo} is not {@code NULL}, each element of its {@code pLibraries} member <b>must</b> have been created with values of the {@code maxPipelineRayPayloadSize} and {@code maxPipelineRayHitAttributeSize} members of {@code pLibraryInterface} equal to those in this pipeline</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR bit set</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR bit set</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR bit set</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR bit set</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR bit set</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR bit set</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR bit set</li>
            <li>If the {@link KHRPipelineLibrary VK_KHR_pipeline_library} extension is not enabled, {@code pLibraryInfo} and {@code pLibraryInterface} <b>must</b> be {@code NULL}</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, for any element of {@code pGroups} with a {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the {@code anyHitShader} of that element <b>must</b> not be #SHADER_UNUSED_KHR</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, for any element of {@code pGroups} with a {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the {@code closestHitShader} of that element <b>must</b> not be #SHADER_UNUSED_KHR</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-rayTraversalPrimitiveCulling">{@code rayTraversalPrimitiveCulling}</a> feature is not enabled, {@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-rayTraversalPrimitiveCulling">{@code rayTraversalPrimitiveCulling}</a> feature is not enabled, {@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include both #PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR and #PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR, <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-rayTracingPipelineShaderGroupHandleCaptureReplay">{@code rayTracingPipelineShaderGroupHandleCaptureReplay}</a> <b>must</b> be enabled</li>
            <li>If ##VkPhysicalDeviceRayTracingPipelineFeaturesKHR{@code ::rayTracingPipelineShaderGroupHandleCaptureReplay} is #TRUE and the {@code pShaderGroupCaptureReplayHandle} member of any element of {@code pGroups} is not {@code NULL}, {@code flags} <b>must</b> include #PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR</li>
            <li>If {@code pLibraryInfo} is {@code NULL} or its {@code libraryCount} is 0, {@code stageCount} <b>must</b> not be 0</li>
            <li>If {@code flags} does not include #PIPELINE_CREATE_LIBRARY_BIT_KHR and either {@code pLibraryInfo} is {@code NULL} or its {@code libraryCount} is 0, {@code groupCount} <b>must</b> not be 0</li>
            <li>Any element of the {@code pDynamicStates} member of {@code pDynamicState} <b>must</b> be #DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR</li>
            <li>If ##VkPipelineCreationFeedbackCreateInfo{@code ::pipelineStageCreationFeedbackCount} is not 0, it <b>must</b> be equal to {@code stageCount}</li>
            <li>The {@code stage} value in all {@code pStages} elements <b>must</b> be one of #SHADER_STAGE_RAYGEN_BIT_KHR, #SHADER_STAGE_ANY_HIT_BIT_KHR, #SHADER_STAGE_CLOSEST_HIT_BIT_KHR, #SHADER_STAGE_MISS_BIT_KHR, #SHADER_STAGE_INTERSECTION_BIT_KHR, or #SHADER_STAGE_CALLABLE_BIT_KHR</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT bit set</li>
            <li>If {@code flags} includes #PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV, each element of {@code pLibraryInfo→pLibraries} <b>must</b> have been created with the #PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV bit set</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkPipelineCreateFlags2CreateInfoKHR, ##VkPipelineCreationFeedbackCreateInfo, or ##VkPipelineRobustnessCreateInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkPipelineCreateFlagBits} values</li>
            <li>If {@code stageCount} is not 0, {@code pStages} <b>must</b> be a valid pointer to an array of {@code stageCount} valid ##VkPipelineShaderStageCreateInfo structures</li>
            <li>If {@code groupCount} is not 0, {@code pGroups} <b>must</b> be a valid pointer to an array of {@code groupCount} valid ##VkRayTracingShaderGroupCreateInfoKHR structures</li>
            <li>If {@code pLibraryInfo} is not {@code NULL}, {@code pLibraryInfo} <b>must</b> be a valid pointer to a valid ##VkPipelineLibraryCreateInfoKHR structure</li>
            <li>If {@code pLibraryInterface} is not {@code NULL}, {@code pLibraryInterface} <b>must</b> be a valid pointer to a valid ##VkRayTracingPipelineInterfaceCreateInfoKHR structure</li>
            <li>If {@code pDynamicState} is not {@code NULL}, {@code pDynamicState} <b>must</b> be a valid pointer to a valid ##VkPipelineDynamicStateCreateInfo structure</li>
            <li>{@code layout} <b>must</b> be a valid {@code VkPipelineLayout} handle</li>
            <li>Both of {@code basePipelineHandle}, and {@code layout} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkPipelineDynamicStateCreateInfo, ##VkPipelineLibraryCreateInfoKHR, ##VkPipelineShaderStageCreateInfo, ##VkRayTracingPipelineInterfaceCreateInfoKHR, ##VkRayTracingShaderGroupCreateInfoKHR, #CreateRayTracingPipelinesKHR()
        """

    Expression("#STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkPipelineCreateFlags2CreateInfoKHR", "VkPipelineCreationFeedbackCreateInfo", "VkPipelineCreationFeedbackCreateInfoEXT", "VkPipelineRobustnessCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCreateFlags("flags", "a bitmask of {@code VkPipelineCreateFlagBits} specifying how the pipeline will be generated.")
    AutoSize("pStages", optional = true)..uint32_t("stageCount", "the number of entries in the {@code pStages} array.")
    VkPipelineShaderStageCreateInfo.const.p("pStages", "a pointer to an array of {@code stageCount} ##VkPipelineShaderStageCreateInfo structures describing the set of the shader stages to be included in the ray tracing pipeline.")
    AutoSize("pGroups", optional = true)..uint32_t("groupCount", "the number of entries in the {@code pGroups} array.")
    VkRayTracingShaderGroupCreateInfoKHR.const.p("pGroups", "a pointer to an array of {@code groupCount} ##VkRayTracingShaderGroupCreateInfoKHR structures describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.")
    uint32_t("maxPipelineRayRecursionDepth", "the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#ray-tracing-recursion-depth\">maximum recursion depth</a> of shaders executed by this pipeline.")
    nullable..VkPipelineLibraryCreateInfoKHR.const.p("pLibraryInfo", "a pointer to a ##VkPipelineLibraryCreateInfoKHR structure defining pipeline libraries to include.")
    nullable..VkRayTracingPipelineInterfaceCreateInfoKHR.const.p("pLibraryInterface", "a pointer to a ##VkRayTracingPipelineInterfaceCreateInfoKHR structure defining additional information when using pipeline libraries.")
    nullable..VkPipelineDynamicStateCreateInfo.const.p("pDynamicState", "a pointer to a ##VkPipelineDynamicStateCreateInfo structure, and is used to indicate which properties of the pipeline state object are dynamic and <b>can</b> be changed independently of the pipeline state. This <b>can</b> be {@code NULL}, which means no state in the pipeline is considered dynamic.")
    VkPipelineLayout("layout", "the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.")
    VkPipeline("basePipelineHandle", "a pipeline to derive from.")
    int32_t("basePipelineIndex", "an index into the {@code pCreateInfos} parameter to use as a pipeline to derive from.")
}

val VkPhysicalDeviceRayTracingPipelineFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingPipelineFeaturesKHR") {
    documentation =
        """
        Structure describing the ray tracing features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRayTracingPipelineFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRayTracingPipelineFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code rayTracingPipelineShaderGroupHandleCaptureReplayMixed} is #TRUE, {@code rayTracingPipelineShaderGroupHandleCaptureReplay} <b>must</b> also be #TRUE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rayTracingPipeline", "indicates whether the implementation supports the ray tracing pipeline functionality. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#ray-tracing\">Ray Tracing</a>.")
    VkBool32("rayTracingPipelineShaderGroupHandleCaptureReplay", "indicates whether the implementation supports saving and reusing shader group handles, e.g. for trace capture and replay.")
    VkBool32("rayTracingPipelineShaderGroupHandleCaptureReplayMixed", "indicates whether the implementation supports reuse of shader group handles being arbitrarily mixed with creation of non-reused shader group handles. If this is #FALSE, all reused shader group handles <b>must</b> be specified before any non-reused handles <b>may</b> be created.")
    VkBool32("rayTracingPipelineTraceRaysIndirect", "indicates whether the implementation supports indirect ray tracing commands, e.g. #CmdTraceRaysIndirectKHR().")
    VkBool32("rayTraversalPrimitiveCulling", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#ray-traversal-culling-primitive\">primitive culling during ray traversal</a>.")
}

val VkPhysicalDeviceRayTracingPipelinePropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingPipelinePropertiesKHR", mutable = false) {
    documentation =
        """
        Properties of the physical device for ray tracing.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        Limits specified by this structure <b>must</b> match those specified with the same name in ##VkPhysicalDeviceRayTracingPropertiesNV.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("shaderGroupHandleSize", "the size in bytes of the shader header.")
    uint32_t("maxRayRecursionDepth", "the maximum number of levels of ray recursion allowed in a trace command.")
    uint32_t("maxShaderGroupStride", "the maximum stride in bytes allowed between shader groups in the shader binding table.")
    uint32_t("shaderGroupBaseAlignment", "the <b>required</b> alignment in bytes for the base of the shader binding table.")
    uint32_t("shaderGroupHandleCaptureReplaySize", "the number of bytes for the information required to do capture and replay for shader group handles.")
    uint32_t("maxRayDispatchInvocationCount", "the maximum number of ray generation shader invocations which <b>may</b> be produced by a single #CmdTraceRaysIndirectKHR() or #CmdTraceRaysKHR() command.")
    uint32_t("shaderGroupHandleAlignment", "the <b>required</b> alignment in bytes for each shader binding table entry. The value <b>must</b> be a power of two.")
    uint32_t("maxRayHitAttributeSize", "the maximum size in bytes for a ray attribute structure")
}

val VkStridedDeviceAddressRegionKHR = struct(Module.VULKAN, "VkStridedDeviceAddressRegionKHR") {
    documentation =
        """
        Structure specifying a region of device addresses with a stride.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code size} is not zero, all addresses between {@code deviceAddress} and <code>deviceAddress + size - 1</code> <b>must</b> be in the buffer device address range of the same buffer</li>
            <li>If {@code size} is not zero, {@code stride} <b>must</b> be less than or equal to the size of the buffer from which {@code deviceAddress} was queried</li>
        </ul>

        <h5>See Also</h5>
        #CmdTraceRaysIndirectKHR(), #CmdTraceRaysKHR()
        """

    VkDeviceAddress("deviceAddress", "the device address (as returned by the #GetBufferDeviceAddress() command) at which the region starts, or zero if the region is unused.")
    VkDeviceSize("stride", "the byte stride between consecutive elements.")
    VkDeviceSize("size", "the size in bytes of the region starting at {@code deviceAddress}.")
}

val VkTraceRaysIndirectCommandKHR = struct(Module.VULKAN, "VkTraceRaysIndirectCommandKHR") {
    documentation =
        """
        Structure specifying the parameters of an indirect ray tracing command.

        <h5>Description</h5>
        The members of ##VkTraceRaysIndirectCommandKHR have the same meaning as the similarly named parameters of #CmdTraceRaysKHR().

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code width} <b>must</b> be less than or equal to <code>##VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] × ##VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]</code></li>
            <li>{@code height} <b>must</b> be less than or equal to <code>##VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] × ##VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]</code></li>
            <li>{@code depth} <b>must</b> be less than or equal to <code>##VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] × ##VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]</code></li>
            <li><code>width × height × depth</code> <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::maxRayDispatchInvocationCount}</li>
        </ul>
        """

    uint32_t("width", "the width of the ray trace query dimensions.")
    uint32_t("height", "height of the ray trace query dimensions.")
    uint32_t("depth", "depth of the ray trace query dimensions.")
}

val VkPhysicalDeviceRayQueryFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceRayQueryFeaturesKHR") {
    documentation =
        """
        Structure describing the ray query features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRayQueryFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRayQueryFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rayQuery", "indicates whether the implementation supports ray query ({@code OpRayQueryProceedKHR}) functionality.")
}

val VkPipelineCoverageModulationStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineCoverageModulationStateCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters controlling coverage modulation.

        <h5>Description</h5>
        If {@code coverageModulationTableEnable} is #FALSE, then for each color sample the associated bits of the pixel coverage are counted and divided by the number of associated bits to produce a modulation factor <code>R</code> in the range <code>(0,1]</code> (a value of zero would have been killed due to a color coverage of 0). Specifically:

        <ul>
            <li><code>N</code> = value of {@code rasterizationSamples}</li>
            <li><code>M</code> = value of ##VkAttachmentDescription{@code ::samples} for any color attachments</li>
            <li><code>R = popcount(associated coverage bits) / (N / M)</code></li>
        </ul>

        If {@code coverageModulationTableEnable} is #TRUE, the value <code>R</code> is computed using a programmable lookup table. The lookup table has <code>N / M</code> elements, and the element of the table is selected by:

        <ul>
            <li><code>R = pCoverageModulationTable[popcount(associated coverage bits)-1]</code></li>
        </ul>

        Note that the table does not have an entry for <code>popcount(associated coverage bits) = 0</code>, because such samples would have been killed.

        The values of {@code pCoverageModulationTable} <b>may</b> be rounded to an implementation-dependent precision, which is at least as fine as <code>1 / N</code>, and clamped to <code>[0,1]</code>.

        For each color attachment with a floating point or normalized color format, each fragment output color value is replicated to <code>M</code> values which <b>can</b> each be modulated (multiplied) by that color sample’s associated value of <code>R</code>. Which components are modulated is controlled by {@code coverageModulationMode}.

        If this structure is not included in the {@code pNext} chain, it is as if {@code coverageModulationMode} is #COVERAGE_MODULATION_MODE_NONE_NV.

        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#fragops-coverage-reduction">coverage reduction mode</a> is #COVERAGE_REDUCTION_MODE_TRUNCATE_NV, each color sample is associated with only a single coverage sample. In this case, it is as if {@code coverageModulationMode} is #COVERAGE_MODULATION_MODE_NONE_NV.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code coverageModulationTableEnable} is #TRUE, {@code coverageModulationTableCount} <b>must</b> be equal to the number of rasterization samples divided by the number of color samples in the subpass</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code coverageModulationMode} <b>must</b> be a valid {@code VkCoverageModulationModeNV} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCoverageModulationStateCreateFlagsNV("flags", "reserved for future use.")
    VkCoverageModulationModeNV("coverageModulationMode", "a {@code VkCoverageModulationModeNV} value controlling which color components are modulated.")
    VkBool32("coverageModulationTableEnable", "controls whether the modulation factor is looked up from a table in {@code pCoverageModulationTable}.")
    AutoSize("pCoverageModulationTable", optional = true)..uint32_t("coverageModulationTableCount", "the number of elements in {@code pCoverageModulationTable}.")
    nullable..float.const.p("pCoverageModulationTable", "a table of modulation factors containing a value for each number of covered samples.")
}

val VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing shader SM Builtins properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderSMBuiltinsPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("shaderSMCount", "the number of SMs on the device.")
    uint32_t("shaderWarpsPerSM", "the maximum number of simultaneously executing warps on an SM.")
}

val VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV") {
    documentation =
        """
        Structure describing the shader SM Builtins features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderSMBuiltinsFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderSMBuiltins", "indicates whether the implementation supports the SPIR-V {@code ShaderSMBuiltinsNV} capability.")
}

val VkSamplerYcbcrConversionCreateInfoKHR = struct(Module.VULKAN, "VkSamplerYcbcrConversionCreateInfoKHR", alias = VkSamplerYcbcrConversionCreateInfo) {
    documentation = "See ##VkSamplerYcbcrConversionCreateInfo."

    Expression("#STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkFormat("format", "")
    VkSamplerYcbcrModelConversion("ycbcrModel", "")
    VkSamplerYcbcrRange("ycbcrRange", "")
    VkComponentMapping("components", "")
    VkChromaLocation("xChromaOffset", "")
    VkChromaLocation("yChromaOffset", "")
    VkFilter("chromaFilter", "")
    VkBool32("forceExplicitReconstruction", "")
}

val VkSamplerYcbcrConversionInfoKHR = struct(Module.VULKAN, "VkSamplerYcbcrConversionInfoKHR", alias = VkSamplerYcbcrConversionInfo) {
    documentation = "See ##VkSamplerYcbcrConversionInfo."

    Expression("#STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSamplerYcbcrConversion("conversion", "")
}

val VkBindImagePlaneMemoryInfoKHR = struct(Module.VULKAN, "VkBindImagePlaneMemoryInfoKHR", alias = VkBindImagePlaneMemoryInfo) {
    documentation = "See ##VkBindImagePlaneMemoryInfo."

    Expression("#STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageAspectFlagBits("planeAspect", "")
}

val VkImagePlaneMemoryRequirementsInfoKHR = struct(Module.VULKAN, "VkImagePlaneMemoryRequirementsInfoKHR", alias = VkImagePlaneMemoryRequirementsInfo) {
    documentation = "See ##VkImagePlaneMemoryRequirementsInfo."

    Expression("#STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageAspectFlagBits("planeAspect", "")
}

val VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR", alias = VkPhysicalDeviceSamplerYcbcrConversionFeatures) {
    documentation = "See ##VkPhysicalDeviceSamplerYcbcrConversionFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("samplerYcbcrConversion", "")
}

val VkSamplerYcbcrConversionImageFormatPropertiesKHR = struct(Module.VULKAN, "VkSamplerYcbcrConversionImageFormatPropertiesKHR", mutable = false, alias = VkSamplerYcbcrConversionImageFormatProperties) {
    documentation = "See ##VkSamplerYcbcrConversionImageFormatProperties."

    Expression("#STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("combinedImageSamplerDescriptorCount", "")
}

val VkBindBufferMemoryInfoKHR = struct(Module.VULKAN, "VkBindBufferMemoryInfoKHR", alias = VkBindBufferMemoryInfo) {
    documentation = "See ##VkBindBufferMemoryInfo."

    Expression("#STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBuffer("buffer", "")
    VkDeviceMemory("memory", "")
    VkDeviceSize("memoryOffset", "")
}

val VkBindImageMemoryInfoKHR = struct(Module.VULKAN, "VkBindImageMemoryInfoKHR", alias = VkBindImageMemoryInfo) {
    documentation = "See ##VkBindImageMemoryInfo."

    Expression("#STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("image", "")
    VkDeviceMemory("memory", "")
    VkDeviceSize("memoryOffset", "")
}

val VkDrmFormatModifierPropertiesEXT = struct(Module.VULKAN, "VkDrmFormatModifierPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure specifying properties of a format when combined with a DRM format modifier.

        <h5>Description</h5>
        The returned {@code drmFormatModifierTilingFeatures} <b>must</b> contain at least one bit.

        The implementation <b>must</b> not return {@code DRM_FORMAT_MOD_INVALID} in {@code drmFormatModifier}.

        An image’s <em>memory planecount</em> (as returned by {@code drmFormatModifierPlaneCount}) is distinct from its <em>format planecount</em> (in the sense of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-requiring-sampler-ycbcr-conversion">multi-planar</a> Y′C<sub>B</sub>C<sub>R</sub> formats). In {@code VkImageAspectFlags}, each <code>VK_IMAGE_ASPECT_MEMORY_PLANE<em>_i_</em>BIT_EXT</code> represents a <em>memory plane</em> and each <code>VK_IMAGE_ASPECT_PLANE<em>_i_</em>BIT</code> a <em>format plane</em>.

        An image’s set of <em>format planes</em> is an ordered partition of the image’s <b>content</b> into separable groups of format components. The ordered partition is encoded in the name of each {@code VkFormat}. For example, #FORMAT_G8_B8R8_2PLANE_420_UNORM contains two <em>format planes</em>; the first plane contains the green component and the second plane contains the blue component and red component. If the format name does not contain {@code PLANE}, then the format contains a single plane; for example, #FORMAT_R8G8B8A8_UNORM. Some commands, such as #CmdCopyBufferToImage(), do not operate on all format components in the image, but instead operate only on the <em>format planes</em> explicitly chosen by the application and operate on each <em>format plane</em> independently.

        An image’s set of <em>memory planes</em> is an ordered partition of the image’s <b>memory</b> rather than the image’s <b>content</b>. Each <em>memory plane</em> is a contiguous range of memory. The union of an image’s <em>memory planes</em> is not necessarily contiguous.

        If an image is <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#glossary-linear-resource">linear</a>, then the partition is the same for <em>memory planes</em> and for <em>format planes</em>. Therefore, if the returned {@code drmFormatModifier} is {@code DRM_FORMAT_MOD_LINEAR}, then {@code drmFormatModifierPlaneCount} <b>must</b> equal the <em>format planecount</em>, and {@code drmFormatModifierTilingFeatures} <b>must</b> be identical to the ##VkFormatProperties2{@code ::linearTilingFeatures} returned in the same {@code pNext} chain.

        If an image is <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#glossary-linear-resource">non-linear</a>, then the partition of the image’s <b>memory</b> into <em>memory planes</em> is implementation-specific and <b>may</b> be unrelated to the partition of the image’s <b>content</b> into <em>format planes</em>. For example, consider an image whose {@code format} is #FORMAT_G8_B8_R8_3PLANE_420_UNORM, {@code tiling} is #IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, whose {@code drmFormatModifier} is not {@code DRM_FORMAT_MOD_LINEAR}, and {@code flags} lacks #IMAGE_CREATE_DISJOINT_BIT. The image has 3 <em>format planes</em>, and commands such #CmdCopyBufferToImage() act on each <em>format plane</em> independently as if the data of each <em>format plane</em> were separable from the data of the other planes. In a straightforward implementation, the implementation <b>may</b> store the image’s content in 3 adjacent <em>memory planes</em> where each <em>memory plane</em> corresponds exactly to a <em>format plane</em>. However, the implementation <b>may</b> also store the image’s content in a single <em>memory plane</em> where all format components are combined using an implementation-private block-compressed format; or the implementation <b>may</b> store the image’s content in a collection of 7 adjacent <em>memory planes</em> using an implementation-private sharding technique. Because the image is non-linear and non-disjoint, the implementation has much freedom when choosing the image’s placement in memory.

        The <em>memory planecount</em> applies to function parameters and structures only when the API specifies an explicit requirement on {@code drmFormatModifierPlaneCount}. In all other cases, the <em>memory planecount</em> is ignored.

        <h5>See Also</h5>
        ##VkDrmFormatModifierPropertiesListEXT
        """

    uint64_t("drmFormatModifier", "a <em>Linux DRM format modifier</em>.")
    uint32_t("drmFormatModifierPlaneCount", "the number of <em>memory planes</em> in any image created with {@code format} and {@code drmFormatModifier}. An image’s <em>memory planecount</em> is distinct from its <em>format planecount</em>, as explained below.")
    VkFormatFeatureFlags("drmFormatModifierTilingFeatures", "a bitmask of {@code VkFormatFeatureFlagBits} that are supported by any image created with {@code format} and {@code drmFormatModifier}.")
}

val VkDrmFormatModifierPropertiesListEXT = struct(Module.VULKAN, "VkDrmFormatModifierPropertiesListEXT", mutable = false) {
    documentation =
        """
        Structure specifying the list of DRM format modifiers supported for a format.

        <h5>Description</h5>
        If {@code pDrmFormatModifierProperties} is {@code NULL}, then the function returns in {@code drmFormatModifierCount} the number of modifiers compatible with the queried {@code format}. Otherwise, the application <b>must</b> set {@code drmFormatModifierCount} to the length of the array {@code pDrmFormatModifierProperties}; the function will write at most {@code drmFormatModifierCount} elements to the array, and will return in {@code drmFormatModifierCount} the number of elements written.

        Among the elements in array {@code pDrmFormatModifierProperties}, each returned {@code drmFormatModifier} <b>must</b> be unique.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkDrmFormatModifierPropertiesEXT
        """

    Expression("#STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    AutoSize("pDrmFormatModifierProperties", optional = true)..uint32_t("drmFormatModifierCount", "an inout parameter related to the number of modifiers compatible with the {@code format}, as described below.")
    nullable..VkDrmFormatModifierPropertiesEXT.p("pDrmFormatModifierProperties", "either {@code NULL} or a pointer to an array of ##VkDrmFormatModifierPropertiesEXT structures.")
}

val VkPhysicalDeviceImageDrmFormatModifierInfoEXT = struct(Module.VULKAN, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT") {
    documentation =
        """
        Structure specifying a DRM format modifier as image creation parameter.

        <h5>Description</h5>
        If the {@code drmFormatModifier} is incompatible with the parameters specified in ##VkPhysicalDeviceImageFormatInfo2 and its {@code pNext} chain, then #GetPhysicalDeviceImageFormatProperties2() returns #ERROR_FORMAT_NOT_SUPPORTED. The implementation <b>must</b> support the query of any {@code drmFormatModifier}, including unknown and invalid modifier values.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code sharingMode} is #SHARING_MODE_CONCURRENT, then {@code pQueueFamilyIndices} <b>must</b> be a valid pointer to an array of {@code queueFamilyIndexCount} {@code uint32_t} values</li>
            <li>If {@code sharingMode} is #SHARING_MODE_CONCURRENT, then {@code queueFamilyIndexCount} <b>must</b> be greater than 1</li>
            <li>If {@code sharingMode} is #SHARING_MODE_CONCURRENT, each element of {@code pQueueFamilyIndices} <b>must</b> be unique and <b>must</b> be less than the {@code pQueueFamilyPropertyCount} returned by #GetPhysicalDeviceQueueFamilyProperties2() for the {@code physicalDevice} that was used to create {@code device}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT</li>
            <li>{@code sharingMode} <b>must</b> be a valid {@code VkSharingMode} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint64_t("drmFormatModifier", "the image’s <em>Linux DRM format modifier</em>, corresponding to ##VkImageDrmFormatModifierExplicitCreateInfoEXT{@code ::modifier} or to ##VkImageDrmFormatModifierListCreateInfoEXT{@code ::pModifiers}.")
    VkSharingMode("sharingMode", "specifies how the image will be accessed by multiple queue families.")
    AutoSize("pQueueFamilyIndices", optional = true)..uint32_t("queueFamilyIndexCount", "the number of entries in the {@code pQueueFamilyIndices} array.")
    nullable..uint32_t.const.p("pQueueFamilyIndices", "a pointer to an array of queue families that will access the image. It is ignored if {@code sharingMode} is not #SHARING_MODE_CONCURRENT.")
}

val VkImageDrmFormatModifierListCreateInfoEXT = struct(Module.VULKAN, "VkImageDrmFormatModifierListCreateInfoEXT") {
    documentation =
        """
        Specify that an image must be created with a DRM format modifier from the provided list.

        <h5>Valid Usage</h5>
        <ul>
            <li>Each <em>modifier</em> in {@code pDrmFormatModifiers} <b>must</b> be compatible with the parameters in ##VkImageCreateInfo and its {@code pNext} chain, as determined by querying ##VkPhysicalDeviceImageFormatInfo2 extended with ##VkPhysicalDeviceImageDrmFormatModifierInfoEXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT</li>
            <li>{@code pDrmFormatModifiers} <b>must</b> be a valid pointer to an array of {@code drmFormatModifierCount} {@code uint64_t} values</li>
            <li>{@code drmFormatModifierCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pDrmFormatModifiers")..uint32_t("drmFormatModifierCount", "the length of the {@code pDrmFormatModifiers} array.")
    uint64_t.const.p("pDrmFormatModifiers", "a pointer to an array of <em>Linux DRM format modifiers</em>.")
}

val VkImageDrmFormatModifierExplicitCreateInfoEXT = struct(Module.VULKAN, "VkImageDrmFormatModifierExplicitCreateInfoEXT") {
    documentation =
        """
        Specify that an image be created with the provided DRM format modifier and explicit memory layout.

        <h5>Description</h5>
        The {@code i}<sup>th</sup> member of {@code pPlaneLayouts} describes the layout of the image’s {@code i}<sup>th</sup> <em>memory plane</em> (that is, <code>VK_IMAGE_ASPECT_MEMORY_PLANE<em>_i_</em>BIT_EXT</code>). In each element of {@code pPlaneLayouts}, the implementation <b>must</b> ignore {@code size}. The implementation calculates the size of each plane, which the application <b>can</b> query with #GetImageSubresourceLayout().

        When creating an image with ##VkImageDrmFormatModifierExplicitCreateInfoEXT, it is the application’s responsibility to satisfy all valid usage requirements. However, the implementation <b>must</b> validate that the provided {@code pPlaneLayouts}, when combined with the provided {@code drmFormatModifier} and other creation parameters in ##VkImageCreateInfo and its {@code pNext} chain, produce a valid image. (This validation is necessarily implementation-dependent and outside the scope of Vulkan, and therefore not described by valid usage requirements). If this validation fails, then #CreateImage() returns #ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code drmFormatModifier} <b>must</b> be compatible with the parameters in ##VkImageCreateInfo and its {@code pNext} chain, as determined by querying ##VkPhysicalDeviceImageFormatInfo2 extended with ##VkPhysicalDeviceImageDrmFormatModifierInfoEXT</li>
            <li>{@code drmFormatModifierPlaneCount} <b>must</b> be equal to the ##VkDrmFormatModifierPropertiesEXT{@code ::drmFormatModifierPlaneCount} associated with ##VkImageCreateInfo{@code ::format} and {@code drmFormatModifier}, as found by querying ##VkDrmFormatModifierPropertiesListEXT</li>
            <li>For each element of {@code pPlaneLayouts}, {@code size} <b>must</b> be 0</li>
            <li>For each element of {@code pPlaneLayouts}, {@code arrayPitch} <b>must</b> be 0 if ##VkImageCreateInfo{@code ::arrayLayers} is 1</li>
            <li>For each element of {@code pPlaneLayouts}, {@code depthPitch} <b>must</b> be 0 if ##VkImageCreateInfo{@code ::extent.depth} is 1</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT</li>
            <li>{@code pPlaneLayouts} <b>must</b> be a valid pointer to an array of {@code drmFormatModifierPlaneCount} ##VkSubresourceLayout structures</li>
            <li>{@code drmFormatModifierPlaneCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkSubresourceLayout
        """

    Expression("#STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint64_t("drmFormatModifier", "the <em>Linux DRM format modifier</em> with which the image will be created.")
    AutoSize("pPlaneLayouts")..uint32_t("drmFormatModifierPlaneCount", "the number of <em>memory planes</em> in the image (as reported by ##VkDrmFormatModifierPropertiesEXT) as well as the length of the {@code pPlaneLayouts} array.")
    VkSubresourceLayout.const.p("pPlaneLayouts", "a pointer to an array of ##VkSubresourceLayout structures describing the image’s <em>memory planes</em>.")
}

val VkImageDrmFormatModifierPropertiesEXT = struct(Module.VULKAN, "VkImageDrmFormatModifierPropertiesEXT", mutable = false) {
    documentation =
        """
        Properties of an image’s Linux DRM format modifier.

        <h5>Description</h5>
        If the {@code image} was created with ##VkImageDrmFormatModifierListCreateInfoEXT, then the returned {@code drmFormatModifier} <b>must</b> belong to the list of modifiers provided at time of image creation in ##VkImageDrmFormatModifierListCreateInfoEXT{@code ::pDrmFormatModifiers}. If the {@code image} was created with ##VkImageDrmFormatModifierExplicitCreateInfoEXT, then the returned {@code drmFormatModifier} <b>must</b> be the modifier provided at time of image creation in ##VkImageDrmFormatModifierExplicitCreateInfoEXT{@code ::drmFormatModifier}.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetImageDrmFormatModifierPropertiesEXT()
        """

    Expression("#STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint64_t("drmFormatModifier", "returns the image’s <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#glossary-drm-format-modifier\">Linux DRM format modifier</a>.")
}

val VkDrmFormatModifierProperties2EXT = struct(Module.VULKAN, "VkDrmFormatModifierProperties2EXT", mutable = false) {
    documentation =
        """
        Structure specifying properties of a format when combined with a DRM format modifier.

        <h5>See Also</h5>
        ##VkDrmFormatModifierPropertiesList2EXT
        """

    uint64_t("drmFormatModifier", "a <em>Linux DRM format modifier</em>.")
    uint32_t("drmFormatModifierPlaneCount", "the number of <em>memory planes</em> in any image created with {@code format} and {@code drmFormatModifier}. An image’s <em>memory planecount</em> is distinct from its <em>format planecount</em>, as explained below.")
    VkFormatFeatureFlags2("drmFormatModifierTilingFeatures", "a bitmask of {@code VkFormatFeatureFlagBits2} that are supported by any image created with {@code format} and {@code drmFormatModifier}.")
}

val VkDrmFormatModifierPropertiesList2EXT = struct(Module.VULKAN, "VkDrmFormatModifierPropertiesList2EXT", mutable = false) {
    documentation =
        """
        Structure specifying the list of DRM format modifiers supported for a format.

        <h5>Description</h5>
        If {@code pDrmFormatModifierProperties} is {@code NULL}, the number of modifiers compatible with the queried {@code format} is returned in {@code drmFormatModifierCount}. Otherwise, the application <b>must</b> set {@code drmFormatModifierCount} to the length of the array {@code pDrmFormatModifierProperties}; the function will write at most {@code drmFormatModifierCount} elements to the array, and will return in {@code drmFormatModifierCount} the number of elements written.

        Among the elements in array {@code pDrmFormatModifierProperties}, each returned {@code drmFormatModifier} <b>must</b> be unique.

        Among the elements in array {@code pDrmFormatModifierProperties}, the bits reported in {@code drmFormatModifierTilingFeatures} <b>must</b> include the bits reported in the corresponding element of ##VkDrmFormatModifierPropertiesListEXT{@code ::pDrmFormatModifierProperties}.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkDrmFormatModifierProperties2EXT
        """

    Expression("#STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    AutoSize("pDrmFormatModifierProperties", optional = true)..uint32_t("drmFormatModifierCount", "an inout parameter related to the number of modifiers compatible with the {@code format}, as described below.")
    nullable..VkDrmFormatModifierProperties2EXT.p("pDrmFormatModifierProperties", "either {@code NULL} or a pointer to an array of ##VkDrmFormatModifierProperties2EXT structures.")
}

val VkValidationCacheCreateInfoEXT = struct(Module.VULKAN, "VkValidationCacheCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created validation cache.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code initialDataSize} is not 0, it <b>must</b> be equal to the size of {@code pInitialData}, as returned by {@code vkGetValidationCacheDataEXT} when {@code pInitialData} was originally retrieved</li>
            <li>If {@code initialDataSize} is not 0, {@code pInitialData} <b>must</b> have been retrieved from a previous call to {@code vkGetValidationCacheDataEXT}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>If {@code initialDataSize} is not 0, {@code pInitialData} <b>must</b> be a valid pointer to an array of {@code initialDataSize} bytes</li>
        </ul>

        <h5>See Also</h5>
        #CreateValidationCacheEXT()
        """

    Expression("#STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkValidationCacheCreateFlagsEXT("flags", "reserved for future use.")
    AutoSize("pInitialData", optional = true)..size_t("initialDataSize", "the number of bytes in {@code pInitialData}. If {@code initialDataSize} is zero, the validation cache will initially be empty.")
    void.const.p("pInitialData", "a pointer to previously retrieved validation cache data. If the validation cache data is incompatible (as defined below) with the device, the validation cache will be initially empty. If {@code initialDataSize} is zero, {@code pInitialData} is ignored.")
}

val VkShaderModuleValidationCacheCreateInfoEXT = struct(Module.VULKAN, "VkShaderModuleValidationCacheCreateInfoEXT") {
    documentation =
        """
        Specify validation cache to use during shader module creation.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT</li>
            <li>{@code validationCache} <b>must</b> be a valid {@code VkValidationCacheEXT} handle</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkValidationCacheEXT("validationCache", "the validation cache object from which the results of prior validation attempts will be written, and to which new validation results for this {@code VkShaderModule} will be written (if not already present).")
}

val VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = struct(Module.VULKAN, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT", alias = VkDescriptorSetLayoutBindingFlagsCreateInfo) {
    documentation = "See ##VkDescriptorSetLayoutBindingFlagsCreateInfo."

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pBindingFlags", optional = true)..uint32_t("bindingCount", "")
    nullable..VkDescriptorBindingFlags.const.p("pBindingFlags", "")
}

val VkPhysicalDeviceDescriptorIndexingFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT", alias = VkPhysicalDeviceDescriptorIndexingFeatures) {
    documentation = "See ##VkPhysicalDeviceDescriptorIndexingFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderInputAttachmentArrayDynamicIndexing", "")
    VkBool32("shaderUniformTexelBufferArrayDynamicIndexing", "")
    VkBool32("shaderStorageTexelBufferArrayDynamicIndexing", "")
    VkBool32("shaderUniformBufferArrayNonUniformIndexing", "")
    VkBool32("shaderSampledImageArrayNonUniformIndexing", "")
    VkBool32("shaderStorageBufferArrayNonUniformIndexing", "")
    VkBool32("shaderStorageImageArrayNonUniformIndexing", "")
    VkBool32("shaderInputAttachmentArrayNonUniformIndexing", "")
    VkBool32("shaderUniformTexelBufferArrayNonUniformIndexing", "")
    VkBool32("shaderStorageTexelBufferArrayNonUniformIndexing", "")
    VkBool32("descriptorBindingUniformBufferUpdateAfterBind", "")
    VkBool32("descriptorBindingSampledImageUpdateAfterBind", "")
    VkBool32("descriptorBindingStorageImageUpdateAfterBind", "")
    VkBool32("descriptorBindingStorageBufferUpdateAfterBind", "")
    VkBool32("descriptorBindingUniformTexelBufferUpdateAfterBind", "")
    VkBool32("descriptorBindingStorageTexelBufferUpdateAfterBind", "")
    VkBool32("descriptorBindingUpdateUnusedWhilePending", "")
    VkBool32("descriptorBindingPartiallyBound", "")
    VkBool32("descriptorBindingVariableDescriptorCount", "")
    VkBool32("runtimeDescriptorArray", "")
}

val VkPhysicalDeviceDescriptorIndexingPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT", mutable = false, alias = VkPhysicalDeviceDescriptorIndexingProperties) {
    documentation = "See ##VkPhysicalDeviceDescriptorIndexingProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("maxUpdateAfterBindDescriptorsInAllPools", "")
    VkBool32("shaderUniformBufferArrayNonUniformIndexingNative", "")
    VkBool32("shaderSampledImageArrayNonUniformIndexingNative", "")
    VkBool32("shaderStorageBufferArrayNonUniformIndexingNative", "")
    VkBool32("shaderStorageImageArrayNonUniformIndexingNative", "")
    VkBool32("shaderInputAttachmentArrayNonUniformIndexingNative", "")
    VkBool32("robustBufferAccessUpdateAfterBind", "")
    VkBool32("quadDivergentImplicitLod", "")
    uint32_t("maxPerStageDescriptorUpdateAfterBindSamplers", "")
    uint32_t("maxPerStageDescriptorUpdateAfterBindUniformBuffers", "")
    uint32_t("maxPerStageDescriptorUpdateAfterBindStorageBuffers", "")
    uint32_t("maxPerStageDescriptorUpdateAfterBindSampledImages", "")
    uint32_t("maxPerStageDescriptorUpdateAfterBindStorageImages", "")
    uint32_t("maxPerStageDescriptorUpdateAfterBindInputAttachments", "")
    uint32_t("maxPerStageUpdateAfterBindResources", "")
    uint32_t("maxDescriptorSetUpdateAfterBindSamplers", "")
    uint32_t("maxDescriptorSetUpdateAfterBindUniformBuffers", "")
    uint32_t("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", "")
    uint32_t("maxDescriptorSetUpdateAfterBindStorageBuffers", "")
    uint32_t("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", "")
    uint32_t("maxDescriptorSetUpdateAfterBindSampledImages", "")
    uint32_t("maxDescriptorSetUpdateAfterBindStorageImages", "")
    uint32_t("maxDescriptorSetUpdateAfterBindInputAttachments", "")
}

val VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = struct(Module.VULKAN, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT", alias = VkDescriptorSetVariableDescriptorCountAllocateInfo) {
    documentation = "See ##VkDescriptorSetVariableDescriptorCountAllocateInfo."

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pDescriptorCounts", optional = true)..uint32_t("descriptorSetCount", "")
    uint32_t.const.p("pDescriptorCounts", "")
}

val VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = struct(Module.VULKAN, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT", mutable = false, alias = VkDescriptorSetVariableDescriptorCountLayoutSupport) {
    documentation = "See ##VkDescriptorSetVariableDescriptorCountLayoutSupport."

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("maxVariableDescriptorCount", "")
}

val VkPhysicalDevicePortabilitySubsetFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDevicePortabilitySubsetFeaturesKHR") {
    documentation =
        """
        Structure describing the features that may not be supported by an implementation of the Vulkan 1.0 Portability Subset.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePortabilitySubsetFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePortabilitySubsetFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("constantAlphaColorBlendFactors", "indicates whether this implementation supports constant <em>alpha</em> <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#framebuffer-blendfactors\">Blend Factors</a> used as source or destination <em>color</em> <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#framebuffer-blending\">Blending</a>.")
    VkBool32("events", "indicates whether this implementation supports synchronization using <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#synchronization-events\">Events</a>.")
    VkBool32("imageViewFormatReinterpretation", "indicates whether this implementation supports a {@code VkImageView} being created with a texel format containing a different number of components, or a different number of bits in each component, than the texel format of the underlying {@code VkImage}.")
    VkBool32("imageViewFormatSwizzle", "indicates whether this implementation supports remapping format components using ##VkImageViewCreateInfo{@code ::components}.")
    VkBool32("imageView2DOn3DImage", "indicates whether this implementation supports a {@code VkImage} being created with the #IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT flag set, permitting a 2D or 2D array image view to be created on a 3D {@code VkImage}.")
    VkBool32("multisampleArrayImage", "indicates whether this implementation supports a {@code VkImage} being created as a 2D array with multiple samples per texel.")
    VkBool32("mutableComparisonSamplers", "indicates whether this implementation allows descriptors with comparison samplers to be <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#descriptorsets-updates\">updated</a>.")
    VkBool32("pointPolygons", "indicates whether this implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast\">Rasterization</a> using a <em>point</em> <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-polygonmode\">Polygon Mode</a>.")
    VkBool32("samplerMipLodBias", "indicates whether this implementation supports setting a <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#samplers-mipLodBias\">mipmap LOD bias value</a> when <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#samplers\">creating a sampler</a>.")
    VkBool32("separateStencilMaskRef", "indicates whether this implementation supports separate front and back <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-stencil\">Stencil Test</a> reference values.")
    VkBool32("shaderSampleRateInterpolationFunctions", "indicates whether this implementation supports fragment shaders which use the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#spirvenv-capabilities-table-InterpolationFunction\">{@code InterpolationFunction}</a> capability and the extended instructions {@code InterpolateAtCentroid}, {@code InterpolateAtOffset}, and {@code InterpolateAtSample} from the {@code GLSL.std.450} extended instruction set. This member is only meaningful if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-sampleRateShading\">{@code sampleRateShading}</a> feature is supported.")
    VkBool32("tessellationIsolines", "indicates whether this implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#tessellation-isoline-tessellation\">isoline output</a> from the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#tessellation\">Tessellation</a> stage of a graphics pipeline. This member is only meaningful if <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-tessellationShader\">{@code tessellationShader}</a> are supported.")
    VkBool32("tessellationPointMode", "indicates whether this implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#tessellation-point-mode\">point output</a> from the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#tessellation\">Tessellation</a> stage of a graphics pipeline. This member is only meaningful if <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-tessellationShader\">{@code tessellationShader}</a> are supported.")
    VkBool32("triangleFans", "indicates whether this implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#drawing-triangle-fans\">Triangle Fans</a> primitive topology.")
    VkBool32("vertexAttributeAccessBeyondStride", "indicates whether this implementation supports accessing a vertex input attribute beyond the stride of the corresponding vertex input binding.")
}

val VkPhysicalDevicePortabilitySubsetPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDevicePortabilitySubsetPropertiesKHR") {
    documentation =
        """
        Structure describing additional properties supported by a portable implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePortabilitySubsetPropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("minVertexInputBindingStrideAlignment", "indicates the minimum alignment for vertex input strides. ##VkVertexInputBindingDescription{@code ::stride} <b>must</b> be a multiple of, and at least as large as, this value. The value <b>must</b> be a power of two.")
}

val VkShadingRatePaletteNV = struct(Module.VULKAN, "VkShadingRatePaletteNV") {
    documentation =
        """
        Structure specifying a single shading rate palette.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code shadingRatePaletteEntryCount} <b>must</b> be between 1 and ##VkPhysicalDeviceShadingRateImagePropertiesNV{@code ::shadingRatePaletteSize}, inclusive</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code pShadingRatePaletteEntries} <b>must</b> be a valid pointer to an array of {@code shadingRatePaletteEntryCount} valid {@code VkShadingRatePaletteEntryNV} values</li>
            <li>{@code shadingRatePaletteEntryCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkPipelineViewportShadingRateImageStateCreateInfoNV, #CmdSetViewportShadingRatePaletteNV()
        """

    AutoSize("pShadingRatePaletteEntries")..uint32_t("shadingRatePaletteEntryCount", "specifies the number of entries in the shading rate image palette.")
    VkShadingRatePaletteEntryNV.const.p("pShadingRatePaletteEntries", "a pointer to an array of {@code VkShadingRatePaletteEntryNV} enums defining the shading rate for each palette entry.")
}

val VkPipelineViewportShadingRateImageStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineViewportShadingRateImageStateCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters controlling shading rate image usage.

        <h5>Description</h5>
        If this structure is not present, {@code shadingRateImageEnable} is considered to be #FALSE, and the shading rate image and palettes are not used.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-multiViewport">{@code multiViewport}</a> feature is not enabled, {@code viewportCount} <b>must</b> be 0 or 1</li>
            <li>{@code viewportCount} <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxViewports}</li>
            <li>If {@code shadingRateImageEnable} is #TRUE, {@code viewportCount} <b>must</b> be greater or equal to the {@code viewportCount} member of ##VkPipelineViewportStateCreateInfo</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV</li>
        </ul>

        <h5>See Also</h5>
        ##VkShadingRatePaletteNV
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shadingRateImageEnable", "specifies whether shading rate image and palettes are used during rasterization.")
    AutoSize("pShadingRatePalettes", optional = true)..uint32_t("viewportCount", "specifies the number of per-viewport palettes used to translate values stored in shading rate images.")
    nullable..VkShadingRatePaletteNV.const.p("pShadingRatePalettes", "a pointer to an array of ##VkShadingRatePaletteNV structures defining the palette for each viewport. If the shading rate palette state is dynamic, this member is ignored.")
}

val VkPhysicalDeviceShadingRateImageFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceShadingRateImageFeaturesNV") {
    documentation =
        """
        Structure describing shading rate image features that can be supported by an implementation.

        <h5>Description</h5>
        See <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-shading-rate-image">Shading Rate Image</a> for more information.

        If the ##VkPhysicalDeviceShadingRateImageFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShadingRateImageFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shadingRateImage", "indicates that the implementation supports the use of a shading rate image to derive an effective shading rate for fragment processing. It also indicates that the implementation supports the {@code ShadingRateNV} SPIR-V execution mode.")
    VkBool32("shadingRateCoarseSampleOrder", "indicates that the implementation supports a user-configurable ordering of coverage samples in fragments larger than one pixel.")
}

val VkPhysicalDeviceShadingRateImagePropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceShadingRateImagePropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing shading rate image limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShadingRateImagePropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These properties are related to the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-shading-rate-image">shading rate image</a> feature.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkExtent2D("shadingRateTexelSize", "indicates the width and height of the portion of the framebuffer corresponding to each texel in the shading rate image.")
    uint32_t("shadingRatePaletteSize", "indicates the maximum number of palette entries supported for the shading rate image.")
    uint32_t("shadingRateMaxCoarseSamples", "specifies the maximum number of coverage samples supported in a single fragment. If the product of the fragment size derived from the base shading rate and the number of coverage samples per pixel exceeds this limit, the final shading rate will be adjusted so that its product does not exceed the limit.")
}

val VkCoarseSampleLocationNV = struct(Module.VULKAN, "VkCoarseSampleLocationNV") {
    documentation =
        """
        Structure specifying parameters controlling shading rate image usage.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code pixelX} <b>must</b> be less than the width (in pixels) of the fragment</li>
            <li>{@code pixelY} <b>must</b> be less than the height (in pixels) of the fragment</li>
            <li>{@code sample} <b>must</b> be less than the number of coverage samples in each pixel belonging to the fragment</li>
        </ul>

        <h5>See Also</h5>
        ##VkCoarseSampleOrderCustomNV
        """

    uint32_t("pixelX", "added to the x coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.")
    uint32_t("pixelY", "added to the y coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.")
    uint32_t("sample", "the number of the coverage sample in the pixel identified by {@code pixelX} and {@code pixelY}.")
}

val VkCoarseSampleOrderCustomNV = struct(Module.VULKAN, "VkCoarseSampleOrderCustomNV") {
    documentation =
        """
        Structure specifying parameters controlling shading rate image usage.

        <h5>Description</h5>
        The ##VkCoarseSampleOrderCustomNV structure is used with a coverage sample ordering type of #COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV to specify the order of coverage samples for one combination of fragment width, fragment height, and coverage sample count.

        When using a custom sample ordering, element <em>j</em> in {@code pSampleLocations} specifies a specific pixel location and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-multisampling-coverage-mask">sample index</a> that corresponds to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-multisampling-coverage-mask">coverage index</a> <em>j</em> in the multi-pixel fragment.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code shadingRate} <b>must</b> be a shading rate that generates fragments with more than one pixel</li>
            <li>{@code sampleCount} <b>must</b> correspond to a sample count enumerated in {@code VkSampleCountFlags} whose corresponding bit is set in ##VkPhysicalDeviceLimits{@code ::framebufferNoAttachmentsSampleCounts}</li>
            <li>{@code sampleLocationCount} <b>must</b> be equal to the product of {@code sampleCount}, the fragment width for {@code shadingRate}, and the fragment height for {@code shadingRate}</li>
            <li>{@code sampleLocationCount} <b>must</b> be less than or equal to the value of ##VkPhysicalDeviceShadingRateImagePropertiesNV{@code ::shadingRateMaxCoarseSamples}</li>
            <li>The array {@code pSampleLocations} <b>must</b> contain exactly one entry for every combination of valid values for {@code pixelX}, {@code pixelY}, and {@code sample} in the structure ##VkCoarseSampleOrderCustomNV</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code shadingRate} <b>must</b> be a valid {@code VkShadingRatePaletteEntryNV} value</li>
            <li>{@code pSampleLocations} <b>must</b> be a valid pointer to an array of {@code sampleLocationCount} ##VkCoarseSampleLocationNV structures</li>
            <li>{@code sampleLocationCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkCoarseSampleLocationNV, ##VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, #CmdSetCoarseSampleOrderNV()
        """

    VkShadingRatePaletteEntryNV("shadingRate", "a shading rate palette entry that identifies the fragment width and height for the combination of fragment area and per-pixel coverage sample count to control.")
    uint32_t("sampleCount", "identifies the per-pixel coverage sample count for the combination of fragment area and coverage sample count to control.")
    AutoSize("pSampleLocations")..uint32_t("sampleLocationCount", "specifies the number of sample locations in the custom ordering.")
    VkCoarseSampleLocationNV.const.p("pSampleLocations", "a pointer to an array of ##VkCoarseSampleLocationNV structures specifying the location of each sample in the custom ordering.")
}

val VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters controlling sample order in coarse fragments.

        <h5>Description</h5>
        If this structure is not present, {@code sampleOrderType} is considered to be #COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV.

        If {@code sampleOrderType} is #COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, the coverage sample order used for any combination of fragment area and coverage sample count not enumerated in {@code pCustomSampleOrders} will be identical to that used for #COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV.

        If the pipeline was created with #DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV, the contents of this structure (if present) are ignored, and the coverage sample order is instead specified by #CmdSetCoarseSampleOrderNV().

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code sampleOrderType} is not #COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, {@code customSamplerOrderCount} <b>must</b> be 0</li>
            <li>The array {@code pCustomSampleOrders} <b>must</b> not contain two structures with matching values for both the {@code shadingRate} and {@code sampleCount} members</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV</li>
            <li>{@code sampleOrderType} <b>must</b> be a valid {@code VkCoarseSampleOrderTypeNV} value</li>
            <li>If {@code customSampleOrderCount} is not 0, {@code pCustomSampleOrders} <b>must</b> be a valid pointer to an array of {@code customSampleOrderCount} valid ##VkCoarseSampleOrderCustomNV structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkCoarseSampleOrderCustomNV
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkCoarseSampleOrderTypeNV("sampleOrderType", "specifies the mechanism used to order coverage samples in fragments larger than one pixel.")
    AutoSize("pCustomSampleOrders", optional = true)..uint32_t("customSampleOrderCount", "specifies the number of custom sample orderings to use when ordering coverage samples.")
    VkCoarseSampleOrderCustomNV.const.p("pCustomSampleOrders", "a pointer to an array of {@code customSampleOrderCount} ##VkCoarseSampleOrderCustomNV structures, each structure specifying the coverage sample order for a single combination of fragment area and coverage sample count.")
}

val VkRayTracingShaderGroupCreateInfoNV = struct(Module.VULKAN, "VkRayTracingShaderGroupCreateInfoNV") {
    documentation =
        """
        Structure specifying shaders in a shader group.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then {@code generalShader} <b>must</b> be a valid index into ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} referring to a shader of #SHADER_STAGE_RAYGEN_BIT_NV, #SHADER_STAGE_MISS_BIT_NV, or #SHADER_STAGE_CALLABLE_BIT_NV</li>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then {@code closestHitShader}, {@code anyHitShader}, and {@code intersectionShader} <b>must</b> be #SHADER_UNUSED_NV</li>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV then {@code intersectionShader} <b>must</b> be a valid index into ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} referring to a shader of #SHADER_STAGE_INTERSECTION_BIT_NV</li>
            <li>If {@code type} is #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV then {@code intersectionShader} <b>must</b> be #SHADER_UNUSED_NV</li>
            <li>{@code closestHitShader} <b>must</b> be either #SHADER_UNUSED_NV or a valid index into ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} referring to a shader of #SHADER_STAGE_CLOSEST_HIT_BIT_NV</li>
            <li>{@code anyHitShader} <b>must</b> be either #SHADER_UNUSED_NV or a valid index into ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} referring to a shader of #SHADER_STAGE_ANY_HIT_BIT_NV</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkRayTracingShaderGroupTypeKHR} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkRayTracingPipelineCreateInfoNV
        """

    Expression("#STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkRayTracingShaderGroupTypeKHR("type", "the type of hit group specified in this structure.")
    uint32_t("generalShader", "the index of the ray generation, miss, or callable shader from ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV, and #SHADER_UNUSED_NV otherwise.")
    uint32_t("closestHitShader", "the optional index of the closest hit shader from ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and #SHADER_UNUSED_NV otherwise.")
    uint32_t("anyHitShader", "the optional index of the any-hit shader from ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and #SHADER_UNUSED_NV otherwise.")
    uint32_t("intersectionShader", "the index of the intersection shader from ##VkRayTracingPipelineCreateInfoNV{@code ::pStages} in the group if the shader group has {@code type} of #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV, and #SHADER_UNUSED_NV otherwise.")
}

val VkRayTracingPipelineCreateInfoNV = struct(Module.VULKAN, "VkRayTracingPipelineCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters of a newly created ray tracing pipeline.

        <h5>Description</h5>
        The parameters {@code basePipelineHandle} and {@code basePipelineIndex} are described in more detail in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#pipelines-pipeline-derivatives">Pipeline Derivatives</a>.

        If a ##VkPipelineCreateFlags2CreateInfoKHR structure is present in the {@code pNext} chain, ##VkPipelineCreateFlags2CreateInfoKHR{@code ::flags} from that structure is used instead of {@code flags} from this structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, and {@code basePipelineIndex} is -1, {@code basePipelineHandle} <b>must</b> be a valid ray tracing {@code VkPipeline} handle</li>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, and {@code basePipelineHandle} is #NULL_HANDLE, {@code basePipelineIndex} <b>must</b> be a valid index into the calling command’s {@code pCreateInfos} parameter</li>
            <li>If {@code flags} contains the #PIPELINE_CREATE_DERIVATIVE_BIT flag, {@code basePipelineIndex} <b>must</b> be -1 or {@code basePipelineHandle} <b>must</b> be #NULL_HANDLE</li>
            <li>If a push constant block is declared in a shader, a push constant range in {@code layout} <b>must</b> match both the shader stage and range</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader, a descriptor slot in {@code layout} <b>must</b> match the shader stage</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader, and the descriptor type is not #DESCRIPTOR_TYPE_MUTABLE_EXT, a descriptor slot in {@code layout} <b>must</b> match the descriptor type</li>
            <li>If a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-resources">resource variables</a> is declared in a shader as an array, a descriptor slot in {@code layout} <b>must</b> match the descriptor count</li>
        </ul>

        <ul>
            <li>The shader code for the entry points identified by {@code pStages}, and the rest of the state identified by this structure <b>must</b> adhere to the pipeline linking rules described in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces">Shader Interfaces</a> chapter</li>
            <li>The number of resources in {@code layout} accessible to each shader stage that is used by the pipeline <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxPerStageResources}</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-pipelineCreationCacheControl">{@code pipelineCreationCacheControl}</a> feature is not enabled, {@code flags} <b>must</b> not include #PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or #PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT</li>
            <li>The {@code stage} member of at least one element of {@code pStages} <b>must</b> be #SHADER_STAGE_RAYGEN_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_LIBRARY_BIT_KHR</li>
            <li>{@code maxRecursionDepth} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPropertiesNV{@code ::maxRecursionDepth}</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV</li>
            <li>{@code flags} <b>must</b> not include both #PIPELINE_CREATE_DEFER_COMPILE_BIT_NV and #PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT at the same time</li>
            <li>If ##VkPipelineCreationFeedbackCreateInfo{@code ::pipelineStageCreationFeedbackCount} is not 0, it <b>must</b> be equal to {@code stageCount}</li>
            <li>The {@code stage} value in all {@code pStages} elements <b>must</b> be one of #SHADER_STAGE_RAYGEN_BIT_KHR, #SHADER_STAGE_ANY_HIT_BIT_KHR, #SHADER_STAGE_CLOSEST_HIT_BIT_KHR, #SHADER_STAGE_MISS_BIT_KHR, #SHADER_STAGE_INTERSECTION_BIT_KHR, or #SHADER_STAGE_CALLABLE_BIT_KHR</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT</li>
            <li>{@code flags} <b>must</b> not include #PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkPipelineCreateFlags2CreateInfoKHR or ##VkPipelineCreationFeedbackCreateInfo</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkPipelineCreateFlagBits} values</li>
            <li>{@code pStages} <b>must</b> be a valid pointer to an array of {@code stageCount} valid ##VkPipelineShaderStageCreateInfo structures</li>
            <li>{@code pGroups} <b>must</b> be a valid pointer to an array of {@code groupCount} valid ##VkRayTracingShaderGroupCreateInfoNV structures</li>
            <li>{@code layout} <b>must</b> be a valid {@code VkPipelineLayout} handle</li>
            <li>{@code stageCount} <b>must</b> be greater than 0</li>
            <li>{@code groupCount} <b>must</b> be greater than 0</li>
            <li>Both of {@code basePipelineHandle}, and {@code layout} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkPipelineShaderStageCreateInfo, ##VkRayTracingShaderGroupCreateInfoNV, #CreateRayTracingPipelinesNV()
        """

    Expression("#STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkPipelineCreateFlags2CreateInfoKHR", "VkPipelineCreationFeedbackCreateInfo", "VkPipelineCreationFeedbackCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCreateFlags("flags", "a bitmask of {@code VkPipelineCreateFlagBits} specifying how the pipeline will be generated.")
    AutoSize("pStages")..uint32_t("stageCount", "the number of entries in the {@code pStages} array.")
    VkPipelineShaderStageCreateInfo.const.p("pStages", "a pointer to an array of ##VkPipelineShaderStageCreateInfo structures specifying the set of the shader stages to be included in the ray tracing pipeline.")
    AutoSize("pGroups")..uint32_t("groupCount", "the number of entries in the {@code pGroups} array.")
    VkRayTracingShaderGroupCreateInfoNV.const.p("pGroups", "a pointer to an array of ##VkRayTracingShaderGroupCreateInfoNV structures describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.")
    uint32_t("maxRecursionDepth", "the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#ray-tracing-recursion-depth\">maximum recursion depth</a> of shaders executed by this pipeline.")
    VkPipelineLayout("layout", "the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.")
    VkPipeline("basePipelineHandle", "a pipeline to derive from.")
    int32_t("basePipelineIndex", "an index into the {@code pCreateInfos} parameter to use as a pipeline to derive from.")
}

val VkGeometryTrianglesNV = struct(Module.VULKAN, "VkGeometryTrianglesNV") {
    documentation =
        """
        Structure specifying a triangle geometry in a bottom-level acceleration structure.

        <h5>Description</h5>
        If {@code indexType} is #INDEX_TYPE_NONE_NV, then this structure describes a set of triangles determined by {@code vertexCount}. Otherwise, this structure describes a set of indexed triangles determined by {@code indexCount}.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code vertexOffset} <b>must</b> be less than the size of {@code vertexData}</li>
            <li>{@code vertexOffset} <b>must</b> be a multiple of the component size of {@code vertexFormat}</li>
            <li>{@code vertexFormat} <b>must</b> be one of #FORMAT_R32G32B32_SFLOAT, #FORMAT_R32G32_SFLOAT, #FORMAT_R16G16B16_SFLOAT, #FORMAT_R16G16_SFLOAT, #FORMAT_R16G16_SNORM, or #FORMAT_R16G16B16_SNORM</li>
            <li>{@code vertexStride} <b>must</b> be less than or equal to <code>2<sup>32</sup>-1</code></li>
            <li>{@code indexOffset} <b>must</b> be less than the size of {@code indexData}</li>
            <li>{@code indexOffset} <b>must</b> be a multiple of the element size of {@code indexType}</li>
            <li>{@code indexType} <b>must</b> be #INDEX_TYPE_UINT16, #INDEX_TYPE_UINT32, or #INDEX_TYPE_NONE_NV</li>
            <li>{@code indexData} <b>must</b> be #NULL_HANDLE if {@code indexType} is #INDEX_TYPE_NONE_NV</li>
            <li>{@code indexData} <b>must</b> be a valid {@code VkBuffer} handle if {@code indexType} is not #INDEX_TYPE_NONE_NV</li>
            <li>{@code indexCount} <b>must</b> be 0 if {@code indexType} is #INDEX_TYPE_NONE_NV</li>
            <li>{@code transformOffset} <b>must</b> be less than the size of {@code transformData}</li>
            <li>{@code transformOffset} <b>must</b> be a multiple of 16</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>If {@code vertexData} is not #NULL_HANDLE, {@code vertexData} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code vertexFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>If {@code indexData} is not #NULL_HANDLE, {@code indexData} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code indexType} <b>must</b> be a valid {@code VkIndexType} value</li>
            <li>If {@code transformData} is not #NULL_HANDLE, {@code transformData} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>Each of {@code indexData}, {@code transformData}, and {@code vertexData} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkGeometryDataNV
        """

    Expression("#STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBuffer("vertexData", "the buffer containing vertex data for this geometry.")
    VkDeviceSize("vertexOffset", "the offset in bytes within {@code vertexData} containing vertex data for this geometry.")
    uint32_t("vertexCount", "the number of valid vertices.")
    VkDeviceSize("vertexStride", "the stride in bytes between each vertex.")
    VkFormat("vertexFormat", "a {@code VkFormat} describing the format of each vertex element.")
    VkBuffer("indexData", "the buffer containing index data for this geometry.")
    VkDeviceSize("indexOffset", "the offset in bytes within {@code indexData} containing index data for this geometry.")
    uint32_t("indexCount", "the number of indices to include in this geometry.")
    VkIndexType("indexType", "a {@code VkIndexType} describing the format of each index.")
    VkBuffer("transformData", "an optional buffer containing an ##VkTransformMatrixNV structure defining a transformation to be applied to this geometry.")
    VkDeviceSize("transformOffset", "the offset in bytes in {@code transformData} of the transform information described above.")
}

val VkGeometryAABBNV = struct(Module.VULKAN, "VkGeometryAABBNV") {
    documentation =
        """
        Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure.

        <h5>Description</h5>
        The AABB data in memory is six 32-bit floats consisting of the minimum x, y, and z values followed by the maximum x, y, and z values.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code offset} <b>must</b> be less than the size of {@code aabbData}</li>
            <li>{@code offset} <b>must</b> be a multiple of 8</li>
            <li>{@code stride} <b>must</b> be a multiple of 8</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GEOMETRY_AABB_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>If {@code aabbData} is not #NULL_HANDLE, {@code aabbData} <b>must</b> be a valid {@code VkBuffer} handle</li>
        </ul>

        <h5>See Also</h5>
        ##VkGeometryDataNV
        """

    Expression("#STRUCTURE_TYPE_GEOMETRY_AABB_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBuffer("aabbData", "the buffer containing axis-aligned bounding box data.")
    uint32_t("numAABBs", "the number of AABBs in this geometry.")
    uint32_t("stride", "the stride in bytes between AABBs in {@code aabbData}.")
    VkDeviceSize("offset", "the offset in bytes of the first AABB in {@code aabbData}.")
}

val VkGeometryDataNV = struct(Module.VULKAN, "VkGeometryDataNV") {
    documentation =
        """
        Structure specifying geometry in a bottom-level acceleration structure.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code triangles} <b>must</b> be a valid ##VkGeometryTrianglesNV structure</li>
            <li>{@code aabbs} <b>must</b> be a valid ##VkGeometryAABBNV structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkGeometryAABBNV, ##VkGeometryNV, ##VkGeometryTrianglesNV
        """

    VkGeometryTrianglesNV("triangles", "contains triangle data if ##VkGeometryNV{@code ::geometryType} is #GEOMETRY_TYPE_TRIANGLES_NV.")
    VkGeometryAABBNV("aabbs", "contains axis-aligned bounding box data if ##VkGeometryNV{@code ::geometryType} is #GEOMETRY_TYPE_AABBS_NV.")
}

val VkGeometryNV = struct(Module.VULKAN, "VkGeometryNV") {
    documentation =
        """
        Structure specifying a geometry in a bottom-level acceleration structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code geometryType} <b>must</b> be #GEOMETRY_TYPE_TRIANGLES_NV or #GEOMETRY_TYPE_AABBS_NV</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GEOMETRY_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code geometryType} <b>must</b> be a valid {@code VkGeometryTypeKHR} value</li>
            <li>{@code geometry} <b>must</b> be a valid ##VkGeometryDataNV structure</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkGeometryFlagBitsKHR} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureInfoNV, ##VkGeometryDataNV
        """

    Expression("#STRUCTURE_TYPE_GEOMETRY_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkGeometryTypeKHR("geometryType", "specifies the {@code VkGeometryTypeKHR} which this geometry refers to.")
    VkGeometryDataNV("geometry", "contains the geometry data as described in ##VkGeometryDataNV.")
    VkGeometryFlagsKHR("flags", "has {@code VkGeometryFlagBitsKHR} describing options for this geometry.")
}

val VkAccelerationStructureInfoNV = struct(Module.VULKAN, "VkAccelerationStructureInfoNV") {
    documentation =
        """
        Structure specifying the parameters of acceleration structure object.

        <h5>Description</h5>
        ##VkAccelerationStructureInfoNV contains information that is used both for acceleration structure creation with #CreateAccelerationStructureNV() and in combination with the actual geometric data to build the acceleration structure with #CmdBuildAccelerationStructureNV().

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code geometryCount} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPropertiesNV{@code ::maxGeometryCount}</li>
            <li>{@code instanceCount} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPropertiesNV{@code ::maxInstanceCount}</li>
            <li>The total number of triangles in all geometries <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPropertiesNV{@code ::maxTriangleCount}</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV then {@code geometryCount} <b>must</b> be 0</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then {@code instanceCount} <b>must</b> be 0</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then the {@code geometryType} member of each geometry in {@code pGeometries} <b>must</b> be the same</li>
            <li>{@code type} <b>must</b> not be #ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR</li>
            <li>If {@code flags} has the #BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV bit set, then it <b>must</b> not have the #BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set</li>
            <li>{@code scratch} <b>must</b> have been created with #BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag</li>
            <li>If {@code instanceData} is not #NULL_HANDLE, {@code instanceData} <b>must</b> have been created with #BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkAccelerationStructureTypeKHR} value</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkBuildAccelerationStructureFlagBitsNV} values</li>
            <li>If {@code geometryCount} is not 0, {@code pGeometries} <b>must</b> be a valid pointer to an array of {@code geometryCount} valid ##VkGeometryNV structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureCreateInfoNV, ##VkGeometryNV, #CmdBuildAccelerationStructureNV()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureTypeKHR("type", "a {@code VkAccelerationStructureTypeNV} value specifying the type of acceleration structure that will be created.")
    VkBuildAccelerationStructureFlagsNV("flags", "a bitmask of {@code VkBuildAccelerationStructureFlagBitsNV} specifying additional parameters of the acceleration structure.")
    uint32_t("instanceCount", "specifies the number of instances that will be in the new acceleration structure.")
    AutoSize("pGeometries", optional = true)..uint32_t("geometryCount", "specifies the number of geometries that will be in the new acceleration structure.")
    VkGeometryNV.const.p("pGeometries", "a pointer to an array of {@code geometryCount} ##VkGeometryNV structures containing the scene data being passed into the acceleration structure.")
}

val VkAccelerationStructureCreateInfoNV = struct(Module.VULKAN, "VkAccelerationStructureCreateInfoNV") {
    documentation =
        """
        Structure specifying the parameters of a newly created acceleration structure object.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code compactedSize} is not 0 then both {@code info.geometryCount} and {@code info.instanceCount} <b>must</b> be 0</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL} or a pointer to a valid instance of ##VkOpaqueCaptureDescriptorDataCreateInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code info} <b>must</b> be a valid ##VkAccelerationStructureInfoNV structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureInfoNV, #CreateAccelerationStructureNV()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkOpaqueCaptureDescriptorDataCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceSize("compactedSize", "the size from the result of #CmdWriteAccelerationStructuresPropertiesNV() if this acceleration structure is going to be the target of a compacting copy.")
    VkAccelerationStructureInfoNV("info", "the ##VkAccelerationStructureInfoNV structure specifying further parameters of the created acceleration structure.")
}

val VkBindAccelerationStructureMemoryInfoNV = struct(Module.VULKAN, "VkBindAccelerationStructureMemoryInfoNV") {
    documentation =
        """
        Structure specifying acceleration structure memory binding.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code accelerationStructure} <b>must</b> not already be backed by a memory object</li>
            <li>{@code memoryOffset} <b>must</b> be less than the size of {@code memory}</li>
            <li>{@code memory} <b>must</b> have been allocated using one of the memory types allowed in the {@code memoryTypeBits} member of the ##VkMemoryRequirements structure returned from a call to #GetAccelerationStructureMemoryRequirementsNV() with {@code accelerationStructure} and {@code type} of #ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV</li>
            <li>{@code memoryOffset} <b>must</b> be an integer multiple of the {@code alignment} member of the ##VkMemoryRequirements structure returned from a call to #GetAccelerationStructureMemoryRequirementsNV() with {@code accelerationStructure} and {@code type} of #ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV</li>
            <li>The {@code size} member of the ##VkMemoryRequirements structure returned from a call to #GetAccelerationStructureMemoryRequirementsNV() with {@code accelerationStructure} and {@code type} of #ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV <b>must</b> be less than or equal to the size of {@code memory} minus {@code memoryOffset}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code accelerationStructure} <b>must</b> be a valid {@code VkAccelerationStructureNV} handle</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
            <li>If {@code deviceIndexCount} is not 0, {@code pDeviceIndices} <b>must</b> be a valid pointer to an array of {@code deviceIndexCount} {@code uint32_t} values</li>
            <li>Both of {@code accelerationStructure}, and {@code memory} <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #BindAccelerationStructureMemoryNV()
        """

    Expression("#STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureNV("accelerationStructure", "the acceleration structure to be attached to memory.")
    VkDeviceMemory("memory", "a {@code VkDeviceMemory} object describing the device memory to attach.")
    VkDeviceSize("memoryOffset", "the start offset of the region of memory that is to be bound to the acceleration structure. The number of bytes returned in the ##VkMemoryRequirements{@code ::size} member in {@code memory}, starting from {@code memoryOffset} bytes, will be bound to the specified acceleration structure.")
    AutoSize("pDeviceIndices", optional = true)..uint32_t("deviceIndexCount", "the number of elements in {@code pDeviceIndices}.")
    uint32_t.const.p("pDeviceIndices", "a pointer to an array of device indices.")
}

val VkWriteDescriptorSetAccelerationStructureNV = struct(Module.VULKAN, "VkWriteDescriptorSetAccelerationStructureNV") {
    documentation =
        """
        Structure specifying acceleration structure descriptor information.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code accelerationStructureCount} <b>must</b> be equal to {@code descriptorCount} in the extended structure</li>
            <li>Each acceleration structure in {@code pAccelerationStructures} <b>must</b> have been created with #ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, each member of {@code pAccelerationStructures} <b>must</b> not be #NULL_HANDLE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV</li>
            <li>{@code pAccelerationStructures} <b>must</b> be a valid pointer to an array of {@code accelerationStructureCount} valid or #NULL_HANDLE {@code VkAccelerationStructureNV} handles</li>
            <li>{@code accelerationStructureCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pAccelerationStructures", optional = true)..uint32_t("accelerationStructureCount", "the number of elements in {@code pAccelerationStructures}.")
    nullable..VkAccelerationStructureNV.const.p("pAccelerationStructures", "a pointer to an array of {@code VkAccelerationStructureNV} structures specifying the acceleration structures to update.")
}

val VkAccelerationStructureMemoryRequirementsInfoNV = struct(Module.VULKAN, "VkAccelerationStructureMemoryRequirementsInfoNV") {
    documentation =
        """
        Structure specifying acceleration to query for memory requirements.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkAccelerationStructureMemoryRequirementsTypeNV} value</li>
            <li>{@code accelerationStructure} <b>must</b> be a valid {@code VkAccelerationStructureNV} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetAccelerationStructureMemoryRequirementsNV()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureMemoryRequirementsTypeNV("type", "selects the type of memory requirement being queried. #ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV returns the memory requirements for the object itself. #ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV returns the memory requirements for the scratch memory when doing a build. #ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV returns the memory requirements for the scratch memory when doing an update.")
    VkAccelerationStructureNV("accelerationStructure", "the acceleration structure to be queried for memory requirements.")
}

val VkPhysicalDeviceRayTracingPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingPropertiesNV", mutable = false) {
    documentation =
        """
        Properties of the physical device for ray tracing.

        <h5>Description</h5>
        Due to the fact that the geometry, instance, and triangle counts are specified at acceleration structure creation as 32-bit values, {@code maxGeometryCount}, {@code maxInstanceCount}, and {@code maxTriangleCount} <b>must</b> not exceed <code>2<sup>32</sup>-1</code>.

        If the ##VkPhysicalDeviceRayTracingPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        Limits specified by this structure <b>must</b> match those specified with the same name in ##VkPhysicalDeviceAccelerationStructurePropertiesKHR and ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("shaderGroupHandleSize", "the size in bytes of the shader header.")
    uint32_t("maxRecursionDepth", "the maximum number of levels of recursion allowed in a trace command.")
    uint32_t("maxShaderGroupStride", "the maximum stride in bytes allowed between shader groups in the shader binding table.")
    uint32_t("shaderGroupBaseAlignment", "the <b>required</b> alignment in bytes for the base of the shader binding table.")
    uint64_t("maxGeometryCount", "the maximum number of geometries in the bottom level acceleration structure.")
    uint64_t("maxInstanceCount", "the maximum number of instances in the top level acceleration structure.")
    uint64_t("maxTriangleCount", "the maximum number of triangles in all geometries in the bottom level acceleration structure.")
    uint32_t("maxDescriptorSetAccelerationStructures", "the maximum number of acceleration structure descriptors that are allowed in a descriptor set.")
}

val VkTransformMatrixNV = struct(Module.VULKAN, "VkTransformMatrixNV", alias = VkTransformMatrixKHR) {
    documentation = "See ##VkTransformMatrixKHR."

    float("matrix", "")[3][4]
}

val VkAabbPositionsNV = struct(Module.VULKAN, "VkAabbPositionsNV", alias = VkAabbPositionsKHR) {
    documentation = "See ##VkAabbPositionsKHR."

    float("minX", "")
    float("minY", "")
    float("minZ", "")
    float("maxX", "")
    float("maxY", "")
    float("maxZ", "")
}

val VkAccelerationStructureInstanceNV = struct(Module.VULKAN, "VkAccelerationStructureInstanceNV", alias = VkAccelerationStructureInstanceKHR) {
    documentation = "See ##VkAccelerationStructureInstanceKHR."

    VkTransformMatrixKHR("transform", "")
    uint32_t("instanceCustomIndex", "", bits = 24)
    uint32_t("mask", "", bits = 8)
    uint32_t("instanceShaderBindingTableRecordOffset", "", bits = 24)
    VkGeometryInstanceFlagsKHR("flags", "", bits = 8)
    uint64_t("accelerationStructureReference", "")
}

val VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV") {
    documentation =
        """
        Structure describing the representative fragment test features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("representativeFragmentTest", "indicates whether the implementation supports the representative fragment test. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-rep-frag-test\">Representative Fragment Test</a>.")
}

val VkPipelineRepresentativeFragmentTestStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineRepresentativeFragmentTestStateCreateInfoNV") {
    documentation =
        """
        Structure specifying representative fragment test.

        <h5>Description</h5>
        If this structure is not included in the {@code pNext} chain, {@code representativeFragmentTestEnable} is considered to be #FALSE, and the representative fragment test is disabled.

        If the active fragment shader does not specify the {@code EarlyFragmentTests} execution mode, the representative fragment shader test has no effect, even if enabled.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("representativeFragmentTestEnable", "controls whether the representative fragment test is enabled.")
}

val VkPhysicalDeviceMaintenance3PropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceMaintenance3PropertiesKHR", mutable = false, alias = VkPhysicalDeviceMaintenance3Properties) {
    documentation = "See ##VkPhysicalDeviceMaintenance3Properties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("maxPerSetDescriptors", "")
    VkDeviceSize("maxMemoryAllocationSize", "")
}

val VkDescriptorSetLayoutSupportKHR = struct(Module.VULKAN, "VkDescriptorSetLayoutSupportKHR", mutable = false, alias = VkDescriptorSetLayoutSupport) {
    documentation = "See ##VkDescriptorSetLayoutSupport."

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkBool32("supported", "")
}

val VkPhysicalDeviceImageViewImageFormatInfoEXT = struct(Module.VULKAN, "VkPhysicalDeviceImageViewImageFormatInfoEXT") {
    documentation =
        """
        Structure for providing image view type.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT</li>
            <li>{@code imageViewType} <b>must</b> be a valid {@code VkImageViewType} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageViewType("imageViewType", "a {@code VkImageViewType} value specifying the type of the image view.")
}

val VkFilterCubicImageViewImageFormatPropertiesEXT = struct(Module.VULKAN, "VkFilterCubicImageViewImageFormatPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure for querying cubic filtering capabilities of an image view type.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>If the {@code pNext} chain of the ##VkImageFormatProperties2 structure includes a ##VkFilterCubicImageViewImageFormatPropertiesEXT structure, the {@code pNext} chain of the ##VkPhysicalDeviceImageFormatInfo2 structure <b>must</b> include a ##VkPhysicalDeviceImageViewImageFormatInfoEXT structure with an {@code imageViewType} that is compatible with {@code imageType}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("filterCubic", "tells if image format, image type and image view type <b>can</b> be used with cubic filtering. This field is set by the implementation. User-specified value is ignored.")
    VkBool32("filterCubicMinmax", "tells if image format, image type and image view type <b>can</b> be used with cubic filtering and minmax filtering. This field is set by the implementation. User-specified value is ignored.")
}

val _VkDeviceQueueGlobalPriorityCreateInfoKHR = struct(Module.VULKAN, "VkDeviceQueueGlobalPriorityCreateInfoKHR")
val VkDeviceQueueGlobalPriorityCreateInfoEXT = struct(Module.VULKAN, "VkDeviceQueueGlobalPriorityCreateInfoEXT", alias = _VkDeviceQueueGlobalPriorityCreateInfoKHR) {
    documentation = "See ##VkDeviceQueueGlobalPriorityCreateInfoKHR."

    Expression("#STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkQueueGlobalPriorityKHR("globalPriority", "")
}

val VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR", alias = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) {
    documentation = "See ##VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderSubgroupExtendedTypes", "")
}

val VkPhysicalDevice8BitStorageFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDevice8BitStorageFeaturesKHR", alias = VkPhysicalDevice8BitStorageFeatures) {
    documentation = "See ##VkPhysicalDevice8BitStorageFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("storageBuffer8BitAccess", "")
    VkBool32("uniformAndStorageBuffer8BitAccess", "")
    VkBool32("storagePushConstant8", "")
}

val VkImportMemoryHostPointerInfoEXT = struct(Module.VULKAN, "VkImportMemoryHostPointerInfoEXT") {
    documentation =
        """
        Import memory from a host pointer.

        <h5>Description</h5>
        Importing memory from a host pointer shares ownership of the memory between the host and the Vulkan implementation. The application <b>can</b> continue to access the memory through the host pointer but it is the application’s responsibility to synchronize device and non-device access to the payload as defined in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#memory-device-hostaccess">Host Access to Device Memory Objects</a>.

        Applications <b>can</b> import the same payload into multiple instances of Vulkan and multiple times into a given Vulkan instance. However, implementations <b>may</b> fail to import the same payload multiple times into a given physical device due to platform constraints.

        Importing memory from a particular host pointer <b>may</b> not be possible due to additional platform-specific restrictions beyond the scope of this specification in which case the implementation <b>must</b> fail the memory import operation with the error code #ERROR_INVALID_EXTERNAL_HANDLE_KHR.

        Whether device memory objects imported from a host pointer hold a reference to their payload is undefined. As such, the application <b>must</b> ensure that the imported memory range remains valid and accessible for the lifetime of the imported memory object.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code handleType} is not 0, it <b>must</b> be supported for import, as reported in ##VkExternalMemoryProperties</li>
            <li>If {@code handleType} is not 0, it <b>must</b> be #EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or #EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT</li>
            <li>{@code pHostPointer} <b>must</b> be a pointer aligned to an integer multiple of ##VkPhysicalDeviceExternalMemoryHostPropertiesEXT{@code ::minImportedHostPointerAlignment}</li>
            <li>If {@code handleType} is #EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, {@code pHostPointer} <b>must</b> be a pointer to {@code allocationSize} number of bytes of host memory, where {@code allocationSize} is the member of the ##VkMemoryAllocateInfo structure this structure is chained to</li>
            <li>If {@code handleType} is #EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, {@code pHostPointer} <b>must</b> be a pointer to {@code allocationSize} number of bytes of host mapped foreign memory, where {@code allocationSize} is the member of the ##VkMemoryAllocateInfo structure this structure is chained to</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalMemoryHandleTypeFlagBits} value</li>
            <li>{@code pHostPointer} <b>must</b> be a pointer value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExternalMemoryHandleTypeFlagBits("handleType", "a {@code VkExternalMemoryHandleTypeFlagBits} value specifying the handle type.")
    opaque_p("pHostPointer", "the host pointer to import from.")
}

val VkMemoryHostPointerPropertiesEXT = struct(Module.VULKAN, "VkMemoryHostPointerPropertiesEXT", mutable = false) {
    documentation =
        """
        Properties of external memory host pointer.

        <h5>Description</h5>
        The value returned by {@code memoryTypeBits} <b>must</b> only include bits that identify memory types which are host visible.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetMemoryHostPointerPropertiesEXT()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("memoryTypeBits", "a bitmask containing one bit set for every memory type which the specified host pointer <b>can</b> be imported as.")
}

val VkPhysicalDeviceExternalMemoryHostPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing external memory host pointer limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDeviceSize("minImportedHostPointerAlignment", "the minimum <b>required</b> alignment, in bytes, for the base address and size of host pointers that <b>can</b> be imported to a Vulkan memory object. The value <b>must</b> be a power of two.")
}

val VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR", alias = VkPhysicalDeviceShaderAtomicInt64Features) {
    documentation = "See ##VkPhysicalDeviceShaderAtomicInt64Features."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderBufferInt64Atomics", "")
    VkBool32("shaderSharedInt64Atomics", "")
}

val VkPhysicalDeviceShaderClockFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderClockFeaturesKHR") {
    documentation =
        """
        Structure describing features supported by VK_KHR_shader_clock.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderClockFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderClockFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderSubgroupClock", "indicates whether shaders <b>can</b> perform {@code Subgroup} scoped clock reads.")
    VkBool32("shaderDeviceClock", "indicates whether shaders <b>can</b> perform {@code Device} scoped clock reads.")
}

val VkPipelineCompilerControlCreateInfoAMD = struct(Module.VULKAN, "VkPipelineCompilerControlCreateInfoAMD") {
    documentation =
        """
        Structure used to pass compilation control flags to a pipeline.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD</li>
            <li>{@code compilerControlFlags} <b>must</b> be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCompilerControlFlagsAMD("compilerControlFlags", "a bitmask of {@code VkPipelineCompilerControlFlagBitsAMD} affecting how the pipeline will be compiled.")
}

val VkCalibratedTimestampInfoEXT = struct(Module.VULKAN, "VkCalibratedTimestampInfoEXT") {
    documentation =
        """
        Structure specifying the input parameters of a calibrated timestamp query.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code timeDomain} <b>must</b> be one of the {@code VkTimeDomainEXT} values returned by #GetPhysicalDeviceCalibrateableTimeDomainsEXT()</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code timeDomain} <b>must</b> be a valid {@code VkTimeDomainEXT} value</li>
        </ul>

        <h5>See Also</h5>
        #GetCalibratedTimestampsEXT()
        """

    Expression("#STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkTimeDomainEXT("timeDomain", "a {@code VkTimeDomainEXT} value specifying the time domain from which the calibrated timestamp value should be returned.")
}

val VkPhysicalDeviceShaderCorePropertiesAMD = struct(Module.VULKAN, "VkPhysicalDeviceShaderCorePropertiesAMD", mutable = false) {
    documentation =
        """
        Structure describing shader core properties that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderCorePropertiesAMD structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("shaderEngineCount", "an unsigned integer value indicating the number of shader engines found inside the shader core of the physical device.")
    uint32_t("shaderArraysPerEngineCount", "an unsigned integer value indicating the number of shader arrays inside a shader engine. Each shader array has its own scan converter, set of compute units, and a render back end (color and depth attachments). Shader arrays within a shader engine share shader processor input (wave launcher) and shader export (export buffer) units. Currently, a shader engine can have one or two shader arrays.")
    uint32_t("computeUnitsPerShaderArray", "an unsigned integer value indicating the physical number of compute units within a shader array. The active number of compute units in a shader array <b>may</b> be lower. A compute unit houses a set of SIMDs along with a sequencer module and a local data store.")
    uint32_t("simdPerComputeUnit", "an unsigned integer value indicating the number of SIMDs inside a compute unit. Each SIMD processes a single instruction at a time.")
    uint32_t("wavefrontsPerSimd", "")
    uint32_t("wavefrontSize", "an unsigned integer value indicating the maximum size of a subgroup.")
    uint32_t("sgprsPerSimd", "an unsigned integer value indicating the number of physical Scalar General-Purpose Registers (SGPRs) per SIMD.")
    uint32_t("minSgprAllocation", "an unsigned integer value indicating the minimum number of SGPRs allocated for a wave.")
    uint32_t("maxSgprAllocation", "an unsigned integer value indicating the maximum number of SGPRs allocated for a wave.")
    uint32_t("sgprAllocationGranularity", "an unsigned integer value indicating the granularity of SGPR allocation for a wave.")
    uint32_t("vgprsPerSimd", "an unsigned integer value indicating the number of physical Vector General-Purpose Registers (VGPRs) per SIMD.")
    uint32_t("minVgprAllocation", "an unsigned integer value indicating the minimum number of VGPRs allocated for a wave.")
    uint32_t("maxVgprAllocation", "an unsigned integer value indicating the maximum number of VGPRs allocated for a wave.")
    uint32_t("vgprAllocationGranularity", "an unsigned integer value indicating the granularity of VGPR allocation for a wave.")
}

val VkVideoDecodeH265ProfileInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH265ProfileInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifying H.265 decode profile.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoH265ProfileIdc("stdProfileIdc", "a {@code StdVideoH265ProfileIdc} value specifying the H.265 codec profile IDC, as defined in section A3 of the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#itu-t-h265\">ITU-T H.265 Specification</a>.")
}

val VkVideoDecodeH265CapabilitiesKHR = struct(Module.VULKAN, "VkVideoDecodeH265CapabilitiesKHR", mutable = false) {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure describing H.265 decode capabilities.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    StdVideoH265LevelIdc("maxLevelIdc", "a {@code StdVideoH265LevelIdc} value specifying the maximum H.265 level supported by the profile, where enum constant {@code STD_VIDEO_H265_LEVEL_IDC_&lt;major&gt;_&lt;minor&gt;} identifies H.265 level {@code &lt;major&gt;.&lt;minor&gt;} as defined in section A.4 of the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#itu-t-h265\">ITU-T H.265 Specification</a>.")
}

val VkVideoDecodeH265SessionParametersAddInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH265SessionParametersAddInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 decoder parameter set information.

        <h5>Description</h5>
        This structure <b>can</b> be specified in the following places:

        <ul>
            <li>In the {@code pParametersAddInfo} member of the ##VkVideoDecodeH265SessionParametersCreateInfoKHR structure specified in the {@code pNext} chain of ##VkVideoSessionParametersCreateInfoKHR used to create a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-session-parameters">video session parameters</a> object. In this case, if the video codec operation the video session parameters object is created with is #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then it defines the set of initial parameters to add to the created object (see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#creating-video-session-parameters">Creating Video Session Parameters</a>).</li>
            <li>In the {@code pNext} chain of ##VkVideoSessionParametersUpdateInfoKHR. In this case, if the video codec operation the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-session-parameters">video session parameters</a> object to be updated was created with is #VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then it defines the set of parameters to add to it (see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-session-parameters-update">Updating Video Session Parameters</a>).</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code vps_video_parameter_set_id} member of each {@code StdVideoH265VideoParameterSet} structure specified in the elements of {@code pStdVPSs} <b>must</b> be unique within {@code pStdVPSs}</li>
            <li>The pair constructed from the {@code sps_video_parameter_set_id} and {@code sps_seq_parameter_set_id} members of each {@code StdVideoH265SequenceParameterSet} structure specified in the elements of {@code pStdSPSs} <b>must</b> be unique within {@code pStdSPSs}</li>
            <li>The triplet constructed from the {@code sps_video_parameter_set_id}, {@code pps_seq_parameter_set_id}, and {@code pps_pic_parameter_set_id} members of each {@code StdVideoH265PictureParameterSet} structure specified in the elements of {@code pStdPPSs} <b>must</b> be unique within {@code pStdPPSs}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR</li>
            <li>If {@code stdVPSCount} is not 0, {@code pStdVPSs} <b>must</b> be a valid pointer to an array of {@code stdVPSCount} {@code StdVideoH265VideoParameterSet} values</li>
            <li>If {@code stdSPSCount} is not 0, {@code pStdSPSs} <b>must</b> be a valid pointer to an array of {@code stdSPSCount} {@code StdVideoH265SequenceParameterSet} values</li>
            <li>If {@code stdPPSCount} is not 0, {@code pStdPPSs} <b>must</b> be a valid pointer to an array of {@code stdPPSCount} {@code StdVideoH265PictureParameterSet} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoDecodeH265SessionParametersCreateInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pStdVPSs", optional = true)..uint32_t("stdVPSCount", "the number of elements in the {@code pStdVPSs} array.")
    StdVideoH265VideoParameterSet.const.p("pStdVPSs", "a pointer to an array of {@code StdVideoH265VideoParameterSet} structures describing the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h265-vps\">H.265 VPS</a> entries to add.")
    AutoSize("pStdSPSs", optional = true)..uint32_t("stdSPSCount", "the number of elements in the {@code pStdSPSs} array.")
    StdVideoH265SequenceParameterSet.const.p("pStdSPSs", "a pointer to an array of {@code StdVideoH265SequenceParameterSet} structures describing the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h265-sps\">H.265 SPS</a> entries to add.")
    AutoSize("pStdPPSs", optional = true)..uint32_t("stdPPSCount", "the number of elements in the {@code pStdPPSs} array.")
    StdVideoH265PictureParameterSet.const.p("pStdPPSs", "a pointer to an array of {@code StdVideoH265PictureParameterSet} structures describing the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h265-pps\">H.265 PPS</a> entries to add.")
}

val VkVideoDecodeH265SessionParametersCreateInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH265SessionParametersCreateInfoKHR") {
    documentation =
        """
        Structure specifies H.265 decoder parameter set information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR</li>
            <li>If {@code pParametersAddInfo} is not {@code NULL}, {@code pParametersAddInfo} <b>must</b> be a valid pointer to a valid ##VkVideoDecodeH265SessionParametersAddInfoKHR structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoDecodeH265SessionParametersAddInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("maxStdVPSCount", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h265-vps\">H.265 VPS</a> entries the created {@code VkVideoSessionParametersKHR} <b>can</b> contain.")
    uint32_t("maxStdSPSCount", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h265-sps\">H.265 SPS</a> entries the created {@code VkVideoSessionParametersKHR} <b>can</b> contain.")
    uint32_t("maxStdPPSCount", "the maximum number of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h265-pps\">H.265 PPS</a> entries the created {@code VkVideoSessionParametersKHR} <b>can</b> contain.")
    nullable..VkVideoDecodeH265SessionParametersAddInfoKHR.const.p("pParametersAddInfo", "{@code NULL} or a pointer to a ##VkVideoDecodeH265SessionParametersAddInfoKHR structure specifying H.265 parameters to add upon object creation.")
}

val VkVideoDecodeH265PictureInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH265PictureInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 picture information when decoding a frame.

        <h5>Description</h5>
        This structure is specified in the {@code pNext} chain of the ##VkVideoDecodeInfoKHR structure passed to #CmdDecodeVideoKHR() to specify the codec-specific picture information for an <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265">H.265 decode operation</a>.

        <dl>
            <dt>Decode Output Picture Information</dt>
            <dd><ul>
                <li>The image subregion used is determined according to the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-picture-data-access">H.265 Decode Picture Data Access</a> section.</li>
                <li>The decode output picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-picture-info">H.265 picture information</a> provided in {@code pStdPictureInfo}.</li>
            </ul></dd>
        </dl>

        <dl>
            <dt>Std Picture Information</dt>
            <dd><ul>
                <li>{@code reserved} is used only for padding purposes and is otherwise ignored;</li>
                <li>{@code flags.IrapPicFlag} as defined in section 3.73 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>{@code flags.IdrPicFlag} as defined in section 3.67 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>{@code flags.IsReference} as defined in section 3.132 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>{@code sps_video_parameter_set_id}, {@code pps_seq_parameter_set_id}, and {@code pps_pic_parameter_set_id} are used to identify the active parameter sets, as described below;</li>
                <li>{@code PicOrderCntVal} as defined in section 8.3.1 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>{@code NumBitsForSTRefPicSetInSlice} is the number of bits used in {@code st_ref_pic_set} when {@code short_term_ref_pic_set_sps_flag} is 0, or 0 otherwise, as defined in sections 7.4.7 and 7.4.8 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>{@code NumDeltaPocsOfRefRpsIdx} is the value of {@code NumDeltaPocs[RefRpsIdx]} when {@code short_term_ref_pic_set_sps_flag} is 1, or 0 otherwise, as defined in sections 7.4.7 and 7.4.8 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>{@code RefPicSetStCurrBefore}, {@code RefPicSetStCurrAfter}, and {@code RefPicSetLtCurr} are interpreted as defined in section 8.3.2 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a> where each element of these arrays either identifies an <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-active-reference-picture-info">active reference picture</a> using its <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#dpb-slot">DPB slot</a> index or contains the value 0xFF to indicate "no reference picture";</li>
                <li>all other members are interpreted as defined in section 8.3.2 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>.</li>
            </ul></dd>

            <dt>Active Parameter Sets</dt>
            <dd><ul>
                <li>The <em>active VPS</em> is the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-vps">VPS</a> identified by the key specified in {@code StdVideoDecodeH265PictureInfo}{@code ::sps_video_parameter_set_id}.</li>
                <li>The <em>active SPS</em> is the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-sps">SPS</a> identified by the key specified by the pair constructed from {@code StdVideoDecodeH265PictureInfo}{@code ::sps_video_parameter_set_id} and {@code StdVideoDecodeH265PictureInfo}{@code ::pps_seq_parameter_set_id}.</li>
                <li>The <em>active PPS</em> is the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-pps">PPS</a> identified by the key specified by the triplet constructed from {@code StdVideoDecodeH265PictureInfo}{@code ::sps_video_parameter_set_id}, {@code StdVideoDecodeH265PictureInfo}{@code ::pps_seq_parameter_set_id}, and {@code StdVideoDecodeH265PictureInfo}{@code ::pps_pic_parameter_set_id}.</li>
            </ul></dd>
        </dl>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR</li>
            <li>{@code pStdPictureInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoDecodeH265PictureInfo} value</li>
            <li>{@code pSliceSegmentOffsets} <b>must</b> be a valid pointer to an array of {@code sliceSegmentCount} {@code uint32_t} values</li>
            <li>{@code sliceSegmentCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoDecodeH265PictureInfo.const.p("pStdPictureInfo", "a pointer to a {@code StdVideoDecodeH265PictureInfo} structure specifying <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#decode-h265-picture-info\">H.265 picture information</a>.")
    AutoSize("pSliceSegmentOffsets")..uint32_t("sliceSegmentCount", "the number of elements in {@code pSliceSegmentOffsets}.")
    uint32_t.const.p("pSliceSegmentOffsets", "a pointer to an array of {@code sliceSegmentCount} offsets specifying the start offset of the slice segments of the picture within the video bitstream buffer range specified in ##VkVideoDecodeInfoKHR.")
}

val VkVideoDecodeH265DpbSlotInfoKHR = struct(Module.VULKAN, "VkVideoDecodeH265DpbSlotInfoKHR") {
    javaImport("org.lwjgl.vulkan.video.*")
    documentation =
        """
        Structure specifies H.265 DPB information when decoding a frame.

        <h5>Description</h5>
        This structure is specified in the {@code pNext} chain of ##VkVideoDecodeInfoKHR{@code ::pSetupReferenceSlot}, if not {@code NULL}, and the {@code pNext} chain of the elements of ##VkVideoDecodeInfoKHR{@code ::pReferenceSlots} to specify the codec-specific reference picture information for an <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265">H.265 decode operation</a>.

        <dl>
            <dt>Active Reference Picture Information</dt>
            <dd><ul>
                <li>The image subregion used is determined according to the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-picture-data-access">H.265 Decode Picture Data Access</a> section.</li>
                <li>The reference picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#dpb-slot">DPB slot</a> index specified in the {@code slotIndex} member of the corresponding element of ##VkVideoDecodeInfoKHR{@code ::pReferenceSlots}.</li>
                <li>The reference picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-reference-info">H.265 reference information</a> provided in {@code pStdReferenceInfo}.</li>
            </ul></dd>
        </dl>

        <dl>
            <dt>Reconstructed Picture Information</dt>
            <dd><ul>
                <li>The image subregion used is determined according to the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-picture-data-access">H.265 Decode Picture Data Access</a> section.</li>
                <li>The reconstructed picture is used to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#dpb-slot-states">activate</a> the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#dpb-slot">DPB slot</a> with the index specified in ##VkVideoDecodeInfoKHR{@code ::pSetupReferenceSlot→slotIndex}.</li>
                <li>The reconstructed picture is associated with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#decode-h265-reference-info">H.265 reference information</a> provided in {@code pStdReferenceInfo}.</li>
            </ul></dd>
        </dl>

        <dl>
            <dt>Std Reference Information</dt>
            <dd><ul>
                <li>{@code flags.used_for_long_term_reference} is used to indicate whether the picture is marked as “used for long-term reference” as defined in section 8.3.2 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>{@code flags.unused_for_reference} is used to indicate whether the picture is marked as “unused for reference” as defined in section 8.3.2 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>;</li>
                <li>all other members are interpreted as defined in section 8.3 of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#itu-t-h265">ITU-T H.265 Specification</a>.</li>
            </ul></dd>
        </dl>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR</li>
            <li>{@code pStdReferenceInfo} <b>must</b> be a valid pointer to a valid {@code StdVideoDecodeH265ReferenceInfo} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    StdVideoDecodeH265ReferenceInfo.const.p("pStdReferenceInfo", "a pointer to a {@code StdVideoDecodeH265ReferenceInfo} structure specifying reference picture information described in section 8.3 of the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#itu-t-h265\">ITU-T H.265 Specification</a>.")
}

val VkDeviceQueueGlobalPriorityCreateInfoKHR = struct(Module.VULKAN, "VkDeviceQueueGlobalPriorityCreateInfoKHR") {
    documentation =
        """
        Specify a system wide priority.

        <h5>Description</h5>
        Queues created without specifying ##VkDeviceQueueGlobalPriorityCreateInfoKHR will default to #QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR</li>
            <li>{@code globalPriority} <b>must</b> be a valid {@code VkQueueGlobalPriorityKHR} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkQueueGlobalPriorityKHR("globalPriority", "the system-wide priority associated to these queues as specified by {@code VkQueueGlobalPriorityEXT}")
}

val VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR") {
    documentation =
        """
        Structure describing whether global priority query can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("globalPriorityQuery", "indicates whether the implementation supports the ability to query global queue priorities.")
}

val VkQueueFamilyGlobalPriorityPropertiesKHR = struct(Module.VULKAN, "VkQueueFamilyGlobalPriorityPropertiesKHR") {
    javaImport("static org.lwjgl.vulkan.KHRGlobalPriority.*")
    documentation =
        """
        Return structure for queue family global priority information query.

        <h5>Description</h5>
        If the ##VkQueueFamilyGlobalPriorityPropertiesKHR structure is included in the {@code pNext} chain of the ##VkQueueFamilyProperties2 structure passed to #GetPhysicalDeviceQueueFamilyProperties2(), it is filled in with the list of supported global queue priorities for the indicated family.

        The valid elements of {@code priorities} <b>must</b> not contain any duplicate values.

        The valid elements of {@code priorities} <b>must</b> be a continuous sequence of {@code VkQueueGlobalPriorityKHR} enums in the ascending order.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        For example, returning {@code priorityCount} as 3 with supported {@code priorities} as #QUEUE_GLOBAL_PRIORITY_LOW_KHR, #QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR and #QUEUE_GLOBAL_PRIORITY_REALTIME_KHR is not allowed.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR</li>
            <li>Each element of {@code priorities} <b>must</b> be a valid {@code VkQueueGlobalPriorityKHR} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("priorityCount", "the number of supported global queue priorities in this queue family, and it <b>must</b> be greater than 0.")
    VkQueueGlobalPriorityKHR("priorities", "an array of #MAX_GLOBAL_PRIORITY_SIZE_EXT {@code VkQueueGlobalPriorityEXT} enums representing all supported global queue priorities in this queue family. The first {@code priorityCount} elements of the array will be valid.")["VK_MAX_GLOBAL_PRIORITY_SIZE_KHR"]
}

val VkDeviceMemoryOverallocationCreateInfoAMD = struct(Module.VULKAN, "VkDeviceMemoryOverallocationCreateInfoAMD") {
    documentation =
        """
        Specify memory overallocation behavior for a Vulkan device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD</li>
            <li>{@code overallocationBehavior} <b>must</b> be a valid {@code VkMemoryOverallocationBehaviorAMD} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMemoryOverallocationBehaviorAMD("overallocationBehavior", "the desired overallocation behavior.")
}

val VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing max value of vertex attribute divisor that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxVertexAttribDivisor", "the maximum value of the number of instances that will repeat the value of vertex attribute data when instanced rendering is enabled.")
}

val VkVertexInputBindingDivisorDescriptionEXT = struct(Module.VULKAN, "VkVertexInputBindingDivisorDescriptionEXT") {
    documentation =
        """
        Structure specifying a divisor used in instanced rendering.

        <h5>Description</h5>
        If this structure is not used to define a divisor value for an attribute, then the divisor has a logical default value of 1.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code binding} <b>must</b> be less than ##VkPhysicalDeviceLimits{@code ::maxVertexInputBindings}</li>
            <li>If the {@code vertexAttributeInstanceRateZeroDivisor} feature is not enabled, {@code divisor} <b>must</b> not be 0</li>
            <li>If the {@code vertexAttributeInstanceRateDivisor} feature is not enabled, {@code divisor} <b>must</b> be 1</li>
            <li>{@code divisor} <b>must</b> be a value between 0 and ##VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{@code ::maxVertexAttribDivisor}, inclusive</li>
            <li>##VkVertexInputBindingDescription{@code ::inputRate} <b>must</b> be of type #VERTEX_INPUT_RATE_INSTANCE for this {@code binding}</li>
        </ul>

        <h5>See Also</h5>
        ##VkPipelineVertexInputDivisorStateCreateInfoEXT
        """

    uint32_t("binding", "the binding number for which the divisor is specified.")
    uint32_t("divisor", "the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of {@code divisor} is implementation-dependent and can be queried using ##VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{@code ::maxVertexAttribDivisor}. A value of 0 <b>can</b> be used for the divisor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-vertexAttributeInstanceRateZeroDivisor\">{@code vertexAttributeInstanceRateZeroDivisor}</a> feature is enabled. In this case, the same vertex attribute will be applied to all instances.")
}

val VkPipelineVertexInputDivisorStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineVertexInputDivisorStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying vertex attributes assignment during instanced rendering.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT</li>
            <li>{@code pVertexBindingDivisors} <b>must</b> be a valid pointer to an array of {@code vertexBindingDivisorCount} ##VkVertexInputBindingDivisorDescriptionEXT structures</li>
            <li>{@code vertexBindingDivisorCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkVertexInputBindingDivisorDescriptionEXT
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pVertexBindingDivisors")..uint32_t("vertexBindingDivisorCount", "the number of elements in the {@code pVertexBindingDivisors} array.")
    VkVertexInputBindingDivisorDescriptionEXT.const.p("pVertexBindingDivisors", "a pointer to an array of ##VkVertexInputBindingDivisorDescriptionEXT structures specifying the divisor value for each binding.")
}

val VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT") {
    documentation =
        """
        Structure describing if fetching of vertex attribute may be repeated for instanced rendering.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("vertexAttributeInstanceRateDivisor", "specifies whether vertex attribute fetching may be repeated in case of instanced rendering.")
    VkBool32("vertexAttributeInstanceRateZeroDivisor", "specifies whether a zero value for ##VkVertexInputBindingDivisorDescriptionEXT{@code ::divisor} is supported.")
}

val VkPipelineCreationFeedbackCreateInfoEXT = struct(Module.VULKAN, "VkPipelineCreationFeedbackCreateInfoEXT", alias = VkPipelineCreationFeedbackCreateInfo) {
    documentation = "See ##VkPipelineCreationFeedbackCreateInfo."

    Expression("#STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPipelineCreationFeedback.p("pPipelineCreationFeedback", "")
    AutoSize("pPipelineStageCreationFeedbacks", optional = true)..uint32_t("pipelineStageCreationFeedbackCount", "")
    VkPipelineCreationFeedback.p("pPipelineStageCreationFeedbacks", "")
}

val VkPipelineCreationFeedbackEXT = struct(Module.VULKAN, "VkPipelineCreationFeedbackEXT", mutable = false, alias = VkPipelineCreationFeedback) {
    documentation = "See ##VkPipelineCreationFeedback."

    VkPipelineCreationFeedbackFlags("flags", "")
    uint64_t("duration", "")
}

val VkConformanceVersionKHR = struct(Module.VULKAN, "VkConformanceVersionKHR", alias = VkConformanceVersion) {
    documentation = "See ##VkConformanceVersion."

    uint8_t("major", "")
    uint8_t("minor", "")
    uint8_t("subminor", "")
    uint8_t("patch", "")
}

val VkPhysicalDeviceDriverPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceDriverPropertiesKHR", mutable = false, alias = VkPhysicalDeviceDriverProperties) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation = "See ##VkPhysicalDeviceDriverProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkDriverId("driverID", "")
    charUTF8("driverName", "")["VK_MAX_DRIVER_NAME_SIZE"]
    charUTF8("driverInfo", "")["VK_MAX_DRIVER_INFO_SIZE"]
    VkConformanceVersion("conformanceVersion", "")
}

val VkPhysicalDeviceFloatControlsPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceFloatControlsPropertiesKHR", mutable = false, alias = VkPhysicalDeviceFloatControlsProperties) {
    documentation = "See ##VkPhysicalDeviceFloatControlsProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkShaderFloatControlsIndependence("denormBehaviorIndependence", "")
    VkShaderFloatControlsIndependence("roundingModeIndependence", "")
    VkBool32("shaderSignedZeroInfNanPreserveFloat16", "")
    VkBool32("shaderSignedZeroInfNanPreserveFloat32", "")
    VkBool32("shaderSignedZeroInfNanPreserveFloat64", "")
    VkBool32("shaderDenormPreserveFloat16", "")
    VkBool32("shaderDenormPreserveFloat32", "")
    VkBool32("shaderDenormPreserveFloat64", "")
    VkBool32("shaderDenormFlushToZeroFloat16", "")
    VkBool32("shaderDenormFlushToZeroFloat32", "")
    VkBool32("shaderDenormFlushToZeroFloat64", "")
    VkBool32("shaderRoundingModeRTEFloat16", "")
    VkBool32("shaderRoundingModeRTEFloat32", "")
    VkBool32("shaderRoundingModeRTEFloat64", "")
    VkBool32("shaderRoundingModeRTZFloat16", "")
    VkBool32("shaderRoundingModeRTZFloat32", "")
    VkBool32("shaderRoundingModeRTZFloat64", "")
}

val VkSubpassDescriptionDepthStencilResolveKHR = struct(Module.VULKAN, "VkSubpassDescriptionDepthStencilResolveKHR", alias = VkSubpassDescriptionDepthStencilResolve) {
    documentation = "See ##VkSubpassDescriptionDepthStencilResolve."

    Expression("#STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkResolveModeFlagBits("depthResolveMode", "")
    VkResolveModeFlagBits("stencilResolveMode", "")
    nullable..VkAttachmentReference2.const.p("pDepthStencilResolveAttachment", "")
}

val VkPhysicalDeviceDepthStencilResolvePropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceDepthStencilResolvePropertiesKHR", mutable = false, alias = VkPhysicalDeviceDepthStencilResolveProperties) {
    documentation = "See ##VkPhysicalDeviceDepthStencilResolveProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkResolveModeFlags("supportedDepthResolveModes", "")
    VkResolveModeFlags("supportedStencilResolveModes", "")
    VkBool32("independentResolveNone", "")
    VkBool32("independentResolve", "")
}

val VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV") {
    documentation =
        """
        Structure describing compute shader derivative features that can be supported by an implementation.

        <h5>Description</h5>
        See <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#shaders-scope-quad">Quad shader scope</a> for more information.

        If the {@code VkPhysicalDeviceComputeShaderDerivativesFeaturesNVfeatures}. structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. {@code VkPhysicalDeviceComputeShaderDerivativesFeaturesNVfeatures}. <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("computeDerivativeGroupQuads", "indicates that the implementation supports the {@code ComputeDerivativeGroupQuadsNV} SPIR-V capability.")
    VkBool32("computeDerivativeGroupLinear", "indicates that the implementation supports the {@code ComputeDerivativeGroupLinearNV} SPIR-V capability.")
}

val VkPhysicalDeviceMeshShaderFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceMeshShaderFeaturesNV") {
    documentation =
        """
        Structure describing mesh shading features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMeshShaderFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMeshShaderFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("taskShader", "specifies whether task shaders are supported. If this feature is not enabled, the #SHADER_STAGE_TASK_BIT_NV and #PIPELINE_STAGE_TASK_SHADER_BIT_NV enum values <b>must</b> not be used.")
    VkBool32("meshShader", "specifies whether mesh shaders are supported. If this feature is not enabled, the #SHADER_STAGE_MESH_BIT_NV and #PIPELINE_STAGE_MESH_SHADER_BIT_NV enum values <b>must</b> not be used.")
}

val VkPhysicalDeviceMeshShaderPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceMeshShaderPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing mesh shading properties.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMeshShaderPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxDrawMeshTasksCount", "the maximum number of local workgroups that <b>can</b> be launched by a single draw mesh tasks command. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#drawing-mesh-shading\">Programmable Mesh Shading</a>.")
    uint32_t("maxTaskWorkGroupInvocations", "the maximum total number of task shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode in shader modules or by the object decorated by the {@code WorkgroupSize} decoration, <b>must</b> be less than or equal to this limit.")
    uint32_t("maxTaskWorkGroupSize", "the maximum size of a local task workgroup. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The {@code x}, {@code y}, and {@code z} sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode or by the object decorated by the {@code WorkgroupSize} decoration in shader modules, <b>must</b> be less than or equal to the corresponding limit.")[3]
    uint32_t("maxTaskTotalMemorySize", "the maximum number of bytes that the task shader can use in total for shared and output memory combined.")
    uint32_t("maxTaskOutputCount", "the maximum number of output tasks a single task shader workgroup can emit.")
    uint32_t("maxMeshWorkGroupInvocations", "the maximum total number of mesh shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode in shader modules or by the object decorated by the {@code WorkgroupSize} decoration, <b>must</b> be less than or equal to this limit.")
    uint32_t("maxMeshWorkGroupSize", "the maximum size of a local mesh workgroup. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The {@code x}, {@code y}, and {@code z} sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode or by the object decorated by the {@code WorkgroupSize} decoration in shader modules, <b>must</b> be less than or equal to the corresponding limit.")[3]
    uint32_t("maxMeshTotalMemorySize", "the maximum number of bytes that the mesh shader can use in total for shared and output memory combined.")
    uint32_t("maxMeshOutputVertices", "the maximum number of vertices a mesh shader output can store.")
    uint32_t("maxMeshOutputPrimitives", "the maximum number of primitives a mesh shader output can store.")
    uint32_t("maxMeshMultiviewViewCount", "the maximum number of multiview views a mesh shader can use.")
    uint32_t("meshOutputPerVertexGranularity", "the granularity with which mesh vertex outputs are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to {@code maxMeshTotalMemorySize}.")
    uint32_t("meshOutputPerPrimitiveGranularity", "the granularity with which mesh outputs qualified as per-primitive are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to {@code maxMeshTotalMemorySize}.")
}

val VkDrawMeshTasksIndirectCommandNV = struct(Module.VULKAN, "VkDrawMeshTasksIndirectCommandNV") {
    documentation =
        """
        Structure specifying a mesh tasks draw indirect command.

        <h5>Description</h5>
        The members of ##VkDrawMeshTasksIndirectCommandNV have the same meaning as the similarly named parameters of #CmdDrawMeshTasksNV().

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code taskCount} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesNV{@code ::maxDrawMeshTasksCount}</li>
        </ul>

        <h5>See Also</h5>
        #CmdDrawMeshTasksIndirectNV()
        """

    uint32_t("taskCount", "the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.")
    uint32_t("firstTask", "the X component of the first workgroup ID.")
}

val _VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR")
val VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV", alias = _VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR) {
    documentation = "See ##VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("fragmentShaderBarycentric", "")
}

val VkPhysicalDeviceShaderImageFootprintFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceShaderImageFootprintFeaturesNV") {
    documentation =
        """
        Structure describing shader image footprint features that can be supported by an implementation.

        <h5>Description</h5>
        See <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#textures-footprint">Texel Footprint Evaluation</a> for more information.

        If the ##VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderImageFootprintFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("imageFootprint", "specifies whether the implementation supports the {@code ImageFootprintNV} SPIR-V capability.")
}

val VkPipelineViewportExclusiveScissorStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineViewportExclusiveScissorStateCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters controlling exclusive scissor testing.

        <h5>Description</h5>
        If the #DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV dynamic state is enabled for a pipeline, the {@code pExclusiveScissors} member is ignored.

        When this structure is included in the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo, it defines parameters of the exclusive scissor test. If this structure is not included in the {@code pNext} chain, it is equivalent to specifying this structure with a {@code exclusiveScissorCount} of 0.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-multiViewport">{@code multiViewport}</a> feature is not enabled, {@code exclusiveScissorCount} <b>must</b> be 0 or 1</li>
            <li>{@code exclusiveScissorCount} <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxViewports}</li>
            <li>{@code exclusiveScissorCount} <b>must</b> be 0 or greater than or equal to the {@code viewportCount} member of ##VkPipelineViewportStateCreateInfo</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV</li>
        </ul>

        <h5>See Also</h5>
        ##VkRect2D
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pExclusiveScissors", optional = true)..uint32_t("exclusiveScissorCount", "the number of exclusive scissor rectangles.")
    nullable..VkRect2D.const.p("pExclusiveScissors", "a pointer to an array of ##VkRect2D structures defining exclusive scissor rectangles.")
}

val VkPhysicalDeviceExclusiveScissorFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceExclusiveScissorFeaturesNV") {
    documentation =
        """
        Structure describing exclusive scissor features that can be supported by an implementation.

        <h5>Description</h5>
        See <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#fragops-exclusive-scissor">Exclusive Scissor Test</a> for more information.

        If the ##VkPhysicalDeviceExclusiveScissorFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceExclusiveScissorFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("exclusiveScissor", "indicates that the implementation supports the exclusive scissor test.")
}

val VkQueueFamilyCheckpointPropertiesNV = struct(Module.VULKAN, "VkQueueFamilyCheckpointPropertiesNV", mutable = false) {
    documentation =
        """
        Return structure for queue family checkpoint information query.

        <h5>Description</h5>
        Additional queue family information can be queried by setting ##VkQueueFamilyProperties2{@code ::pNext} to point to a ##VkQueueFamilyCheckpointPropertiesNV structure.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkPipelineStageFlags("checkpointExecutionStageMask", "a mask indicating which pipeline stages the implementation can execute checkpoint markers in.")
}

val VkCheckpointDataNV = struct(Module.VULKAN, "VkCheckpointDataNV", mutable = false) {
    documentation =
        """
        Return structure for command buffer checkpoint data.

        <h5>Description</h5>
        The stages at which a checkpoint marker <b>can</b> be executed are implementation-defined and <b>can</b> be queried by calling #GetPhysicalDeviceQueueFamilyProperties2().

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_CHECKPOINT_DATA_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetQueueCheckpointDataNV()
        """

    Expression("#STRUCTURE_TYPE_CHECKPOINT_DATA_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkPipelineStageFlagBits("stage", "a {@code VkPipelineStageFlagBits} value specifying which pipeline stage the checkpoint marker data refers to.")
    nullable..opaque_p("pCheckpointMarker", "contains the value of the last checkpoint marker executed in the stage that {@code stage} refers to.")
}

val VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR", alias = VkPhysicalDeviceTimelineSemaphoreFeatures) {
    documentation = "See ##VkPhysicalDeviceTimelineSemaphoreFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("timelineSemaphore", "")
}

val VkPhysicalDeviceTimelineSemaphorePropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceTimelineSemaphorePropertiesKHR", mutable = false, alias = VkPhysicalDeviceTimelineSemaphoreProperties) {
    documentation = "See ##VkPhysicalDeviceTimelineSemaphoreProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint64_t("maxTimelineSemaphoreValueDifference", "")
}

val VkSemaphoreTypeCreateInfoKHR = struct(Module.VULKAN, "VkSemaphoreTypeCreateInfoKHR", alias = VkSemaphoreTypeCreateInfo) {
    documentation = "See ##VkSemaphoreTypeCreateInfo."

    Expression("#STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSemaphoreType("semaphoreType", "")
    uint64_t("initialValue", "")
}

val VkTimelineSemaphoreSubmitInfoKHR = struct(Module.VULKAN, "VkTimelineSemaphoreSubmitInfoKHR", alias = VkTimelineSemaphoreSubmitInfo) {
    documentation = "See ##VkTimelineSemaphoreSubmitInfo."

    Expression("#STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pWaitSemaphoreValues", optional = true)..uint32_t("waitSemaphoreValueCount", "")
    nullable..uint64_t.const.p("pWaitSemaphoreValues", "")
    AutoSize("pSignalSemaphoreValues", optional = true)..uint32_t("signalSemaphoreValueCount", "")
    nullable..uint64_t.const.p("pSignalSemaphoreValues", "")
}

val VkSemaphoreWaitInfoKHR = struct(Module.VULKAN, "VkSemaphoreWaitInfoKHR", alias = VkSemaphoreWaitInfo) {
    documentation = "See ##VkSemaphoreWaitInfo."

    Expression("#STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSemaphoreWaitFlags("flags", "")
    AutoSize("pSemaphores", "pValues")..uint32_t("semaphoreCount", "")
    VkSemaphore.const.p("pSemaphores", "")
    uint64_t.const.p("pValues", "")
}

val VkSemaphoreSignalInfoKHR = struct(Module.VULKAN, "VkSemaphoreSignalInfoKHR", alias = VkSemaphoreSignalInfo) {
    documentation = "See ##VkSemaphoreSignalInfo."

    Expression("#STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSemaphore("semaphore", "")
    uint64_t("value", "")
}

val VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = struct(Module.VULKAN, "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL") {
    documentation =
        """
        Structure describing shader integer functions that can be supported by an implementation.

        <h5>Description</h5>
        If the {@code VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELfeatures}. structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. {@code VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTELfeatures}. <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderIntegerFunctions2", "indicates that the implementation supports the {@code IntegerFunctions2INTEL} SPIR-V capability.")
}

val VkPerformanceValueDataINTEL = union(Module.VULKAN, "VkPerformanceValueDataINTEL") {
    documentation =
        """
        Values returned for the parameters.

        <h5>Description</h5>
        The correct member of the union is determined by the associated {@code VkPerformanceValueTypeINTEL} value.

        <h5>See Also</h5>
        ##VkPerformanceValueINTEL
        """

    uint32_t("value32", "represents 32-bit integer data.")
    uint64_t("value64", "represents 64-bit integer data.")
    float("valueFloat", "represents floating-point data.")
    VkBool32("valueBool", "represents {@code VkBool32} data.")
    charUTF8.const.p("valueString", "represents a pointer to a null-terminated UTF-8 string.")
}

val VkPerformanceValueINTEL = struct(Module.VULKAN, "VkPerformanceValueINTEL") {
    documentation =
        """
        Container for value and types of parameters that can be queried.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code type} <b>must</b> be a valid {@code VkPerformanceValueTypeINTEL} value</li>
            <li>If {@code type} is #PERFORMANCE_VALUE_TYPE_STRING_INTEL, the {@code valueString} member of {@code data} <b>must</b> be a null-terminated UTF-8 string</li>
        </ul>

        <h5>See Also</h5>
        ##VkPerformanceValueDataINTEL, #GetPerformanceParameterINTEL()
        """

    VkPerformanceValueTypeINTEL("type", "a {@code VkPerformanceValueTypeINTEL} value specifying the type of the returned data.")
    VkPerformanceValueDataINTEL("data", "a ##VkPerformanceValueDataINTEL union specifying the value of the returned data.")
}

val VkInitializePerformanceApiInfoINTEL = struct(Module.VULKAN, "VkInitializePerformanceApiInfoINTEL") {
    documentation =
        """
        Structure specifying parameters of initialize of the device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #InitializePerformanceApiINTEL()
        """

    Expression("#STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    nullable..opaque_p("pUserData", "a pointer for application data.")
}

val _VkQueryPoolPerformanceQueryCreateInfoINTEL = struct(Module.VULKAN, "VkQueryPoolPerformanceQueryCreateInfoINTEL")
val VkQueryPoolCreateInfoINTEL = struct(Module.VULKAN, "VkQueryPoolCreateInfoINTEL", alias = _VkQueryPoolPerformanceQueryCreateInfoINTEL) {
    documentation = "See ##VkQueryPoolPerformanceQueryCreateInfoINTEL."

    Expression("#STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkQueryPoolSamplingModeINTEL("performanceCountersSampling", "")
}

val VkQueryPoolPerformanceQueryCreateInfoINTEL = struct(Module.VULKAN, "VkQueryPoolPerformanceQueryCreateInfoINTEL") {
    documentation =
        """
        Structure specifying parameters to create a pool of performance queries.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL</li>
            <li>{@code performanceCountersSampling} <b>must</b> be a valid {@code VkQueryPoolSamplingModeINTEL} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkQueryPoolSamplingModeINTEL("performanceCountersSampling", "describe how performance queries should be captured.")
}

val VkPerformanceMarkerInfoINTEL = struct(Module.VULKAN, "VkPerformanceMarkerInfoINTEL") {
    documentation =
        """
        Structure specifying performance markers.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetPerformanceMarkerINTEL()
        """

    Expression("#STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint64_t("marker", "the marker value that will be recorded into the opaque query results.")
}

val VkPerformanceStreamMarkerInfoINTEL = struct(Module.VULKAN, "VkPerformanceStreamMarkerInfoINTEL") {
    documentation =
        """
        Structure specifying stream performance markers.

        <h5>Valid Usage</h5>
        <ul>
            <li>The value written by the application into {@code marker} <b>must</b> only used the valid bits as reported by #GetPerformanceParameterINTEL() with the #PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetPerformanceStreamMarkerINTEL()
        """

    Expression("#STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("marker", "the marker value that will be recorded into the reports consumed by an external application.")
}

val VkPerformanceOverrideInfoINTEL = struct(Module.VULKAN, "VkPerformanceOverrideInfoINTEL") {
    documentation =
        """
        Performance override information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkPerformanceOverrideTypeINTEL} value</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetPerformanceOverrideINTEL()
        """

    Expression("#STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPerformanceOverrideTypeINTEL("type", "the particular {@code VkPerformanceOverrideTypeINTEL} to set.")
    VkBool32("enable", "defines whether the override is enabled.")
    uint64_t("parameter", "a potential required parameter for the override.")
}

val VkPerformanceConfigurationAcquireInfoINTEL = struct(Module.VULKAN, "VkPerformanceConfigurationAcquireInfoINTEL") {
    documentation =
        """
        Acquire a configuration to capture performance data.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkPerformanceConfigurationTypeINTEL} value</li>
        </ul>

        <h5>See Also</h5>
        #AcquirePerformanceConfigurationINTEL()
        """

    Expression("#STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPerformanceConfigurationTypeINTEL("type", "one of the {@code VkPerformanceConfigurationTypeINTEL} type of performance configuration that will be acquired.")
}

val VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR", alias = VkPhysicalDeviceVulkanMemoryModelFeatures) {
    documentation = "See ##VkPhysicalDeviceVulkanMemoryModelFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("vulkanMemoryModel", "")
    VkBool32("vulkanMemoryModelDeviceScope", "")
    VkBool32("vulkanMemoryModelAvailabilityVisibilityChains", "")
}

val VkPhysicalDevicePCIBusInfoPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDevicePCIBusInfoPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure containing PCI bus information of a physical device.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePCIBusInfoPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These are properties of the PCI bus information of a physical device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("pciDomain", "the PCI bus domain.")
    uint32_t("pciBus", "the PCI bus identifier.")
    uint32_t("pciDevice", "the PCI device identifier.")
    uint32_t("pciFunction", "the PCI device function identifier.")
}

val VkDisplayNativeHdrSurfaceCapabilitiesAMD = struct(Module.VULKAN, "VkDisplayNativeHdrSurfaceCapabilitiesAMD", mutable = false) {
    documentation =
        """
        Structure describing display native HDR specific capabilities of a surface.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("localDimmingSupport", "specifies whether the surface supports local dimming. If this is #TRUE, ##VkSwapchainDisplayNativeHdrCreateInfoAMD <b>can</b> be used to explicitly enable or disable local dimming for the surface. Local dimming may also be overridden by #SetLocalDimmingAMD() during the lifetime of the swapchain.")
}

val VkSwapchainDisplayNativeHdrCreateInfoAMD = struct(Module.VULKAN, "VkSwapchainDisplayNativeHdrCreateInfoAMD") {
    documentation =
        """
        Structure specifying display native HDR parameters of a newly created swapchain object.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkSwapchainCreateInfoKHR does not include this structure, the default value for {@code localDimmingEnable} is #TRUE, meaning local dimming is initially enabled for the swapchain.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>It is only valid to set {@code localDimmingEnable} to #TRUE if ##VkDisplayNativeHdrSurfaceCapabilitiesAMD{@code ::localDimmingSupport} is supported</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("localDimmingEnable", "specifies whether local dimming is enabled for the swapchain.")
}

val VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR", alias = VkPhysicalDeviceShaderTerminateInvocationFeatures) {
    documentation = "See ##VkPhysicalDeviceShaderTerminateInvocationFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderTerminateInvocation", "")
}

val VkMetalSurfaceCreateInfoEXT = struct(Module.VULKAN, "VkMetalSurfaceCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created Metal surface object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateMetalSurfaceEXT()
        """

    Expression("#STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMetalSurfaceCreateFlagsEXT("flags", "reserved for future use.")
    nullable..CAMetalLayer.const.p("pLayer", "a reference to a {@code CAMetalLayer} object representing a renderable surface.")
}

val VkPhysicalDeviceFragmentDensityMapFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceFragmentDensityMapFeaturesEXT") {
    documentation =
        """
        Structure describing fragment density map features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFragmentDensityMapFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("fragmentDensityMap", "specifies whether the implementation supports render passes with a fragment density map attachment. If this feature is not enabled and the {@code pNext} chain of ##VkRenderPassCreateInfo includes a ##VkRenderPassFragmentDensityMapCreateInfoEXT structure, {@code fragmentDensityMapAttachment} <b>must</b> be #ATTACHMENT_UNUSED.")
    VkBool32("fragmentDensityMapDynamic", "specifies whether the implementation supports dynamic fragment density map image views. If this feature is not enabled, #IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT <b>must</b> not be included in ##VkImageViewCreateInfo{@code ::flags}.")
    VkBool32("fragmentDensityMapNonSubsampledImages", "specifies whether the implementation supports regular non-subsampled image attachments with fragment density map render passes. If this feature is not enabled, render passes with a <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#renderpass-fragmentdensitymapattachment\">fragment density map attachment</a> <b>must</b> only have <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#samplers-subsamplesampler\">subsampled attachments</a> bound.")
}

val VkPhysicalDeviceFragmentDensityMapPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceFragmentDensityMapPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing fragment density map properties that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkExtent2D("minFragmentDensityTexelSize", "the minimum <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#glossary-fragment-density-texel-size\">fragment density texel size</a>.")
    VkExtent2D("maxFragmentDensityTexelSize", "the maximum fragment density texel size.")
    VkBool32("fragmentDensityInvocations", "specifies whether the implementation <b>may</b> invoke additional fragment shader invocations for each covered sample.")
}

val VkRenderPassFragmentDensityMapCreateInfoEXT = struct(Module.VULKAN, "VkRenderPassFragmentDensityMapCreateInfoEXT") {
    documentation =
        """
        Structure containing fragment density map attachment for render pass.

        <h5>Description</h5>
        The fragment density map is read at an implementation-dependent time with the following constraints determined by the attachment’s image view {@code flags}:

        <ul>
            <li>#IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT specifies that the fragment density map will be read by the device during #PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT</li>
            <li>#IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT specifies that the fragment density map will be read by the host during #EndCommandBuffer() of the primary command buffer that the render pass is recorded into</li>
            <li>Otherwise the fragment density map will be read by the host during #CmdBeginRenderPass()</li>
        </ul>

        The fragment density map <b>may</b> additionally be read by the device during #PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT for any mode.

        If this structure is not present, it is as if {@code fragmentDensityMapAttachment} was given as #ATTACHMENT_UNUSED.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code fragmentDensityMapAttachment} is not #ATTACHMENT_UNUSED, {@code fragmentDensityMapAttachment} <b>must</b> not be an element of ##VkSubpassDescription{@code ::pInputAttachments}, ##VkSubpassDescription{@code ::pColorAttachments}, ##VkSubpassDescription{@code ::pResolveAttachments}, ##VkSubpassDescription{@code ::pDepthStencilAttachment}, or ##VkSubpassDescription{@code ::pPreserveAttachments} for any subpass</li>
            <li>If {@code fragmentDensityMapAttachment} is not #ATTACHMENT_UNUSED, {@code layout} <b>must</b> be equal to #IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT, or #IMAGE_LAYOUT_GENERAL</li>
            <li>If {@code fragmentDensityMapAttachment} is not #ATTACHMENT_UNUSED, {@code fragmentDensityMapAttachment} <b>must</b> reference an attachment with a {@code loadOp} equal to #ATTACHMENT_LOAD_OP_LOAD or #ATTACHMENT_LOAD_OP_DONT_CARE</li>
            <li>If {@code fragmentDensityMapAttachment} is not #ATTACHMENT_UNUSED, {@code fragmentDensityMapAttachment} <b>must</b> reference an attachment with a {@code storeOp} equal to #ATTACHMENT_STORE_OP_DONT_CARE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT</li>
            <li>{@code fragmentDensityMapAttachment} <b>must</b> be a valid ##VkAttachmentReference structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkAttachmentReference
        """

    Expression("#STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAttachmentReference("fragmentDensityMapAttachment", "the fragment density map to use for the render pass.")
}

val VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT", alias = VkPhysicalDeviceScalarBlockLayoutFeatures) {
    documentation = "See ##VkPhysicalDeviceScalarBlockLayoutFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("scalarBlockLayout", "")
}

val VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT", alias = VkPhysicalDeviceSubgroupSizeControlFeatures) {
    documentation = "See ##VkPhysicalDeviceSubgroupSizeControlFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("subgroupSizeControl", "")
    VkBool32("computeFullSubgroups", "")
}

val VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT", mutable = false, alias = VkPhysicalDeviceSubgroupSizeControlProperties) {
    documentation = "See ##VkPhysicalDeviceSubgroupSizeControlProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("minSubgroupSize", "")
    uint32_t("maxSubgroupSize", "")
    uint32_t("maxComputeWorkgroupSubgroups", "")
    VkShaderStageFlags("requiredSubgroupSizeStages", "")
}

val VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = struct(Module.VULKAN, "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT", mutable = false, alias = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo) {
    documentation = "See ##VkPipelineShaderStageRequiredSubgroupSizeCreateInfo."

    Expression("#STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("requiredSubgroupSize", "")
}

val VkFragmentShadingRateAttachmentInfoKHR = struct(Module.VULKAN, "VkFragmentShadingRateAttachmentInfoKHR") {
    documentation =
        """
        Structure specifying a fragment shading rate attachment for a subpass.

        <h5>Description</h5>
        If no shading rate attachment is specified, or if this structure is not specified, the implementation behaves as if a valid shading rate attachment was specified with all texels specifying a single pixel per fragment.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, its {@code layout} member <b>must</b> be equal to #IMAGE_LAYOUT_GENERAL or #IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR</li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, {@code shadingRateAttachmentTexelSize.width} <b>must</b> be a power of two value</li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, {@code shadingRateAttachmentTexelSize.width} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSize">{@code maxFragmentShadingRateAttachmentTexelSize.width}</a></li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, {@code shadingRateAttachmentTexelSize.width} <b>must</b> be greater than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-minFragmentShadingRateAttachmentTexelSize">{@code minFragmentShadingRateAttachmentTexelSize.width}</a></li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, {@code shadingRateAttachmentTexelSize.height} <b>must</b> be a power of two value</li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, {@code shadingRateAttachmentTexelSize.height} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSize">{@code maxFragmentShadingRateAttachmentTexelSize.height}</a></li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, {@code shadingRateAttachmentTexelSize.height} <b>must</b> be greater than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-minFragmentShadingRateAttachmentTexelSize">{@code minFragmentShadingRateAttachmentTexelSize.height}</a></li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, the quotient of {@code shadingRateAttachmentTexelSize.width} and {@code shadingRateAttachmentTexelSize.height} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSizeAspectRatio">{@code maxFragmentShadingRateAttachmentTexelSizeAspectRatio}</a></li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL} and its {@code attachment} member is not #ATTACHMENT_UNUSED, the quotient of {@code shadingRateAttachmentTexelSize.height} and {@code shadingRateAttachmentTexelSize.width} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFragmentShadingRateAttachmentTexelSizeAspectRatio">{@code maxFragmentShadingRateAttachmentTexelSizeAspectRatio}</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR</li>
            <li>If {@code pFragmentShadingRateAttachment} is not {@code NULL}, {@code pFragmentShadingRateAttachment} <b>must</b> be a valid pointer to a valid ##VkAttachmentReference2 structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkAttachmentReference2, ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    nullable..VkAttachmentReference2.const.p("pFragmentShadingRateAttachment", "{@code NULL} or a pointer to a ##VkAttachmentReference2 structure defining the fragment shading rate attachment for this subpass.")
    VkExtent2D("shadingRateAttachmentTexelSize", "specifies the size of the portion of the framebuffer corresponding to each texel in {@code pFragmentShadingRateAttachment}.")
}

val VkPipelineFragmentShadingRateStateCreateInfoKHR = struct(Module.VULKAN, "VkPipelineFragmentShadingRateStateCreateInfoKHR") {
    documentation =
        """
        Structure specifying parameters controlling the fragment shading rate.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo includes a ##VkPipelineFragmentShadingRateStateCreateInfoKHR structure, then that structure includes parameters controlling the pipeline fragment shading rate.

        If this structure is not present, {@code fragmentSize} is considered to be equal to <code>(1,1)</code>, and both elements of {@code combinerOps} are considered to be equal to #FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExtent2D("fragmentSize", "specifies a ##VkExtent2D structure containing the fragment size used to define the pipeline fragment shading rate for drawing commands using this pipeline.")
    VkFragmentShadingRateCombinerOpKHR("combinerOps", "specifies a {@code VkFragmentShadingRateCombinerOpKHR} value determining how the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-pipeline\">pipeline</a>, <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-primitive\">primitive</a>, and <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-attachment\">attachment shading rates</a> are <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-combining\">combined</a> for fragments generated by drawing commands using the created pipeline.")[2]
}

val VkPhysicalDeviceFragmentShadingRateFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShadingRateFeaturesKHR") {
    documentation =
        """
        Structure indicating support for variable rate fragment shading.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentShadingRateFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFragmentShadingRateFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("pipelineFragmentShadingRate", "indicates that the implementation supports the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-pipeline\">pipeline fragment shading rate</a>.")
    VkBool32("primitiveFragmentShadingRate", "indicates that the implementation supports the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-primitive\">primitive fragment shading rate</a>.")
    VkBool32("attachmentFragmentShadingRate", "indicates that the implementation supports the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-attachment\">attachment fragment shading rate</a>.")
}

val VkPhysicalDeviceFragmentShadingRatePropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShadingRatePropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing variable fragment shading rate limits that can be supported by an implementation.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Multiplication of the combiner rates using the fragment width/height in linear space is equivalent to an addition of those values in log2 space. Some implementations inadvertently implemented an addition in linear space due to unclear requirements originating outside of this specification. This resulted in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-fragmentShadingRateStrictMultiplyCombiner">{@code fragmentShadingRateStrictMultiplyCombiner}</a> being added. Fortunately, this only affects situations where a rate of 1 in either dimension is combined with another rate of 1. All other combinations result in the exact same result as if multiplication was performed in linear space due to the clamping logic, and the fact that both the sum and product of 2 and 2 are equal. In many cases, this limit will not affect the correct operation of applications.
        </div>

        If the ##VkPhysicalDeviceFragmentShadingRatePropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These properties are related to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-fragment-shading-rate">fragment shading rates</a>.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkExtent2D("minFragmentShadingRateAttachmentTexelSize", "indicates minimum supported width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. Each value <b>must</b> be less than or equal to the values in {@code maxFragmentShadingRateAttachmentTexelSize}. Each value <b>must</b> be a power-of-two. It <b>must</b> be <code>(0,0)</code> if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-attachmentFragmentShadingRate\">{@code attachmentFragmentShadingRate}</a> feature is not supported.")
    VkExtent2D("maxFragmentShadingRateAttachmentTexelSize", "indicates maximum supported width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. Each value <b>must</b> be greater than or equal to the values in {@code minFragmentShadingRateAttachmentTexelSize}. Each value <b>must</b> be a power-of-two. It <b>must</b> be <code>(0,0)</code> if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-attachmentFragmentShadingRate\">{@code attachmentFragmentShadingRate}</a> feature is not supported.")
    uint32_t("maxFragmentShadingRateAttachmentTexelSizeAspectRatio", "indicates the maximum ratio between the width and height of the portion of the framebuffer corresponding to each texel in a fragment shading rate attachment. {@code maxFragmentShadingRateAttachmentTexelSizeAspectRatio} <b>must</b> be a power-of-two value, and <b>must</b> be less than or equal to <code>max(maxFragmentShadingRateAttachmentTexelSize.width / minFragmentShadingRateAttachmentTexelSize.height, maxFragmentShadingRateAttachmentTexelSize.height / minFragmentShadingRateAttachmentTexelSize.width)</code>. It <b>must</b> be 0 if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-attachmentFragmentShadingRate\">{@code attachmentFragmentShadingRate}</a> feature is not supported.")
    VkBool32("primitiveFragmentShadingRateWithMultipleViewports", "specifies whether the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-primitive\">primitive fragment shading rate</a> <b>can</b> be used when multiple viewports are used. If this value is #FALSE, only a single viewport <b>must</b> be used, and applications <b>must</b> not write to the {@code ViewportMaskNV} or {@code ViewportIndex} built-in when setting {@code PrimitiveShadingRateKHR}. It <b>must</b> be #FALSE if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-shaderOutputViewportIndex\">{@code shaderOutputViewportIndex}</a> feature, the {@link EXTShaderViewportIndexLayer VK_EXT_shader_viewport_index_layer} extension, or the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-geometryShader\">{@code geometryShader}</a> feature is not supported, or if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-primitiveFragmentShadingRate\">{@code primitiveFragmentShadingRate}</a> feature is not supported.")
    VkBool32("layeredShadingRateAttachments", "specifies whether a shading rate attachment image view <b>can</b> be created with multiple layers. If this value is #FALSE, when creating an image view with a {@code usage} that includes #IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, {@code layerCount} <b>must</b> be 1. It <b>must</b> be #FALSE if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-multiview\">{@code multiview}</a> feature, the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-shaderOutputViewportIndex\">{@code shaderOutputViewportIndex}</a> feature, the {@link EXTShaderViewportIndexLayer VK_EXT_shader_viewport_index_layer} extension, or the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-geometryShader\">{@code geometryShader}</a> feature is not supported, or if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-attachmentFragmentShadingRate\">{@code attachmentFragmentShadingRate}</a> feature is not supported.")
    VkBool32("fragmentShadingRateNonTrivialCombinerOps", "specifies whether {@code VkFragmentShadingRateCombinerOpKHR} enums other than #FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or #FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR <b>can</b> be used. It <b>must</b> be #FALSE unless either the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-primitiveFragmentShadingRate\">{@code primitiveFragmentShadingRate}</a> or <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-attachmentFragmentShadingRate\">{@code attachmentFragmentShadingRate}</a> feature is supported.")
    VkExtent2D("maxFragmentSize", "indicates the maximum supported width and height of a fragment. Its {@code width} and {@code height} members <b>must</b> both be power-of-two values. This limit is purely informational, and is not validated.")
    uint32_t("maxFragmentSizeAspectRatio", "indicates the maximum ratio between the width and height of a fragment. {@code maxFragmentSizeAspectRatio} <b>must</b> be a power-of-two value, and <b>must</b> be less than or equal to the maximum of the {@code width} and {@code height} members of {@code maxFragmentSize}. This limit is purely informational, and is not validated.")
    uint32_t("maxFragmentShadingRateCoverageSamples", "specifies the maximum number of coverage samples supported in a single fragment. {@code maxFragmentShadingRateCoverageSamples} <b>must</b> be less than or equal to the product of the {@code width} and {@code height} members of {@code maxFragmentSize}, and the sample count reported by {@code maxFragmentShadingRateRasterizationSamples}. {@code maxFragmentShadingRateCoverageSamples} <b>must</b> be less than or equal to <code>maxSampleMaskWords × 32</code> if {@code fragmentShadingRateWithShaderSampleMask} is supported. This limit is purely informational, and is not validated.")
    VkSampleCountFlagBits("maxFragmentShadingRateRasterizationSamples", "a {@code VkSampleCountFlagBits} value specifying the maximum sample rate supported when a fragment covers multiple pixels. This limit is purely informational, and is not validated.")
    VkBool32("fragmentShadingRateWithShaderDepthStencilWrites", "specifies whether the implementation supports writing {@code FragDepth} or {@code FragStencilRefEXT} from a fragment shader for multi-pixel fragments. If this value is #FALSE, writing to those built-ins will clamp the fragment shading rate to <code>(1,1)</code>.")
    VkBool32("fragmentShadingRateWithSampleMask", "specifies whether the implementation supports setting valid bits of ##VkPipelineMultisampleStateCreateInfo{@code ::pSampleMask} to 0 for multi-pixel fragments. If this value is #FALSE, zeroing valid bits in the sample mask will clamp the fragment shading rate to <code>(1,1)</code>.")
    VkBool32("fragmentShadingRateWithShaderSampleMask", "specifies whether the implementation supports reading or writing {@code SampleMask} for multi-pixel fragments. If this value is #FALSE, using that built-in will clamp the fragment shading rate to <code>(1,1)</code>.")
    VkBool32("fragmentShadingRateWithConservativeRasterization", "specifies whether <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-conservativeraster\">conservative rasterization</a> is supported for multi-pixel fragments. It <b>must</b> be #FALSE if {@link EXTConservativeRasterization VK_EXT_conservative_rasterization} is not supported. If this value is #FALSE, using <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-conservativeraster\">conservative rasterization</a> will clamp the fragment shading rate to <code>(1,1)</code>.")
    VkBool32("fragmentShadingRateWithFragmentShaderInterlock", "specifies whether <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-shader-interlock\">fragment shader interlock</a> is supported for multi-pixel fragments. It <b>must</b> be #FALSE if {@link EXTFragmentShaderInterlock VK_EXT_fragment_shader_interlock} is not supported. If this value is #FALSE, using <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-shader-interlock\">fragment shader interlock</a> will clamp the fragment shading rate to <code>(1,1)</code>.")
    VkBool32("fragmentShadingRateWithCustomSampleLocations", "specifies whether <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-samplelocations\">custom sample locations</a> are supported for multi-pixel fragments. It <b>must</b> be #FALSE if {@link EXTSampleLocations VK_EXT_sample_locations} is not supported. If this value is #FALSE, using <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-samplelocations\">custom sample locations</a> will clamp the fragment shading rate to <code>(1,1)</code>.")
    VkBool32("fragmentShadingRateStrictMultiplyCombiner", "specifies whether #FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR accurately performs a multiplication or not. Implementations where this value is #FALSE will instead combine rates with an addition. If {@code fragmentShadingRateNonTrivialCombinerOps} is #FALSE, implementations <b>must</b> report this as #FALSE. If {@code fragmentShadingRateNonTrivialCombinerOps} is #TRUE, implementations <b>should</b> report this as #TRUE.")
}

val VkPhysicalDeviceFragmentShadingRateKHR = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShadingRateKHR", mutable = false) {
    documentation =
        """
        Structure returning information about sample count specific additional multisampling capabilities.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, #GetPhysicalDeviceFragmentShadingRatesKHR()
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkSampleCountFlags("sampleCounts", "a bitmask of sample counts for which the shading rate described by {@code fragmentSize} is supported.")
    VkExtent2D("fragmentSize", "a ##VkExtent2D describing the width and height of a supported shading rate.")
}

val VkPhysicalDeviceShaderCoreProperties2AMD = struct(Module.VULKAN, "VkPhysicalDeviceShaderCoreProperties2AMD", mutable = false) {
    documentation =
        """
        Structure describing shader core properties that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderCoreProperties2AMD structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkShaderCorePropertiesFlagsAMD("shaderCoreFeatures", "a bitmask of {@code VkShaderCorePropertiesFlagBitsAMD} indicating the set of features supported by the shader core.")
    uint32_t("activeComputeUnitCount", "an unsigned integer value indicating the number of compute units that have been enabled.")
}

val VkPhysicalDeviceCoherentMemoryFeaturesAMD = struct(Module.VULKAN, "VkPhysicalDeviceCoherentMemoryFeaturesAMD") {
    documentation =
        """
        Structure describing whether device coherent memory can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCoherentMemoryFeaturesAMD structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCoherentMemoryFeaturesAMD <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("deviceCoherentMemory", "indicates that the implementation supports device coherent memory ({@code VkMemoryPropertyFlagBits}).")
}

val VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT") {
    documentation =
        """
        Structure describing features supported by VK_EXT_shader_image_atomic_int64.

        <h5>Description</h5>
        If the {@code VkPhysicalDeviceShaderAtomicInt64FeaturesEXT} structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. {@code VkPhysicalDeviceShaderAtomicInt64FeaturesEXT} <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderImageInt64Atomics", "indicates whether shaders <b>can</b> support 64-bit unsigned and signed integer atomic operations on images.")
    VkBool32("sparseImageInt64Atomics", "indicates whether 64-bit integer atomics <b>can</b> be used on sparse images.")
}

val VkPhysicalDeviceMemoryBudgetPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMemoryBudgetPropertiesEXT", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure specifying physical device memory budget and usage.

        <h5>Description</h5>
        The values returned in this structure are not invariant. The {@code heapBudget} and {@code heapUsage} values <b>must</b> be zero for array elements greater than or equal to ##VkPhysicalDeviceMemoryProperties{@code ::memoryHeapCount}. The {@code heapBudget} value <b>must</b> be non-zero for array elements less than ##VkPhysicalDeviceMemoryProperties{@code ::memoryHeapCount}. The {@code heapBudget} value <b>must</b> be less than or equal to ##VkMemoryHeap{@code ::size} for each heap.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDeviceSize("heapBudget", "an array of #MAX_MEMORY_HEAPS {@code VkDeviceSize} values in which memory budgets are returned, with one element for each memory heap. A heap’s budget is a rough estimate of how much memory the process <b>can</b> allocate from that heap before allocations <b>may</b> fail or cause performance degradation. The budget includes any currently allocated device memory.")["VK_MAX_MEMORY_HEAPS"]
    VkDeviceSize("heapUsage", "an array of #MAX_MEMORY_HEAPS {@code VkDeviceSize} values in which memory usages are returned, with one element for each memory heap. A heap’s usage is an estimate of how much memory the process is currently using in that heap.")["VK_MAX_MEMORY_HEAPS"]
}

val VkPhysicalDeviceMemoryPriorityFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMemoryPriorityFeaturesEXT") {
    documentation =
        """
        Structure describing memory priority features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMemoryPriorityFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("memoryPriority", "indicates that the implementation supports memory priorities specified at memory allocation time via ##VkMemoryPriorityAllocateInfoEXT.")
}

val VkMemoryPriorityAllocateInfoEXT = struct(Module.VULKAN, "VkMemoryPriorityAllocateInfoEXT") {
    documentation =
        """
        Specify a memory allocation priority.

        <h5>Description</h5>
        Memory allocations with higher priority <b>may</b> be more likely to stay in device-local memory when the system is under memory pressure.

        If this structure is not included, it is as if the {@code priority} value were {@code 0.5}.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code priority} <b>must</b> be between 0 and 1, inclusive</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    float("priority", "a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger values are higher priority. The granularity of the priorities is implementation-dependent.")
}

val VkSurfaceProtectedCapabilitiesKHR = struct(Module.VULKAN, "VkSurfaceProtectedCapabilitiesKHR") {
    documentation =
        """
        Structure describing capability of a surface to be protected.

        <h5>Description</h5>
        If the {@link GOOGLESurfacelessQuery VK_GOOGLE_surfaceless_query} extension is enabled, the value returned in {@code supportsProtected} will be identical for every valid surface created on this physical device, and so in the #GetPhysicalDeviceSurfaceCapabilities2KHR() call, ##VkPhysicalDeviceSurfaceInfo2KHR{@code ::surface} <b>can</b> be #NULL_HANDLE. In that case, the contents of ##VkSurfaceCapabilities2KHR{@code ::surfaceCapabilities} as well as any other struct chained to it will be undefined.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("supportsProtected", "specifies whether a protected swapchain created from ##VkPhysicalDeviceSurfaceInfo2KHR{@code ::surface} for a particular windowing system <b>can</b> be displayed on screen or not. If {@code supportsProtected} is #TRUE, then creation of swapchains with the #SWAPCHAIN_CREATE_PROTECTED_BIT_KHR flag set <b>must</b> be supported for {@code surface}.")
}

val VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV") {
    documentation =
        """
        Structure describing dedicated allocation image aliasing features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("dedicatedAllocationImageAliasing", "indicates that the implementation supports aliasing of compatible image objects on a dedicated allocation.")
}

val VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR", alias = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) {
    documentation = "See ##VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("separateDepthStencilLayouts", "")
}

val VkAttachmentReferenceStencilLayoutKHR = struct(Module.VULKAN, "VkAttachmentReferenceStencilLayoutKHR", alias = VkAttachmentReferenceStencilLayout) {
    documentation = "See ##VkAttachmentReferenceStencilLayout."

    Expression("#STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkImageLayout("stencilLayout", "")
}

val VkAttachmentDescriptionStencilLayoutKHR = struct(Module.VULKAN, "VkAttachmentDescriptionStencilLayoutKHR", alias = VkAttachmentDescriptionStencilLayout) {
    documentation = "See ##VkAttachmentDescriptionStencilLayout."

    Expression("#STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkImageLayout("stencilInitialLayout", "")
    VkImageLayout("stencilFinalLayout", "")
}

val _VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT")
val VkPhysicalDeviceBufferAddressFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceBufferAddressFeaturesEXT", alias = _VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) {
    documentation = "See ##VkPhysicalDeviceBufferDeviceAddressFeaturesEXT."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("bufferDeviceAddress", "")
    VkBool32("bufferDeviceAddressCaptureReplay", "")
    VkBool32("bufferDeviceAddressMultiDevice", "")
}

val VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT") {
    documentation =
        """
        Structure describing buffer address features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceBufferDeviceAddressFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The ##VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure has the same members as the ##VkPhysicalDeviceBufferDeviceAddressFeatures structure, but the functionality indicated by the members is expressed differently. The features indicated by the ##VkPhysicalDeviceBufferDeviceAddressFeatures structure requires additional flags to be passed at memory allocation time, and the capture and replay mechanism is built around opaque capture addresses for buffer and memory objects.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("bufferDeviceAddress", "indicates that the implementation supports accessing buffer memory in shaders as storage buffers via an address queried from #GetBufferDeviceAddressEXT().")
    VkBool32("bufferDeviceAddressCaptureReplay", "indicates that the implementation supports saving and reusing buffer addresses, e.g. for trace capture and replay.")
    VkBool32("bufferDeviceAddressMultiDevice", "indicates that the implementation supports the {@code bufferDeviceAddress} feature for logical devices created with multiple physical devices. If this feature is not supported, buffer addresses <b>must</b> not be queried on a logical device created with more than one physical device.")
}

val VkBufferDeviceAddressInfoEXT = struct(Module.VULKAN, "VkBufferDeviceAddressInfoEXT", alias = VkBufferDeviceAddressInfo) {
    documentation = "See ##VkBufferDeviceAddressInfo."

    Expression("#STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBuffer("buffer", "")
}

val VkBufferDeviceAddressCreateInfoEXT = struct(Module.VULKAN, "VkBufferDeviceAddressCreateInfoEXT") {
    documentation =
        """
        Request a specific address for a buffer.

        <h5>Description</h5>
        If {@code deviceAddress} is zero, no specific address is requested.

        If {@code deviceAddress} is not zero, then it <b>must</b> be an address retrieved from an identically created buffer on the same implementation. The buffer <b>must</b> also be bound to an identically created {@code VkDeviceMemory} object.

        If this structure is not present, it is as if {@code deviceAddress} is zero.

        Apps <b>should</b> avoid creating buffers with app-provided addresses and implementation-provided addresses in the same process, to reduce the likelihood of #ERROR_INVALID_DEVICE_ADDRESS_EXT errors.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceAddress("deviceAddress", "the device address requested for the buffer.")
}

val VkPhysicalDeviceToolPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceToolPropertiesEXT", mutable = false, alias = VkPhysicalDeviceToolProperties) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation = "See ##VkPhysicalDeviceToolProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    charUTF8("name", "")["VK_MAX_EXTENSION_NAME_SIZE"]
    charUTF8("version", "")["VK_MAX_EXTENSION_NAME_SIZE"]
    VkToolPurposeFlags("purposes", "")
    charUTF8("description", "")["VK_MAX_DESCRIPTION_SIZE"]
    charUTF8("layer", "")["VK_MAX_EXTENSION_NAME_SIZE"]
}

val VkImageStencilUsageCreateInfoEXT = struct(Module.VULKAN, "VkImageStencilUsageCreateInfoEXT", alias = VkImageStencilUsageCreateInfo) {
    documentation = "See ##VkImageStencilUsageCreateInfo."

    Expression("#STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageUsageFlags("stencilUsage", "")
}

val VkValidationFeaturesEXT = struct(Module.VULKAN, "VkValidationFeaturesEXT") {
    documentation =
        """
        Specify validation features to enable or disable for a Vulkan instance.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the {@code pEnabledValidationFeatures} array contains #VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT, then it <b>must</b> also contain #VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT</li>
            <li>If the {@code pEnabledValidationFeatures} array contains #VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT, then it <b>must</b> not contain #VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VALIDATION_FEATURES_EXT</li>
            <li>If {@code enabledValidationFeatureCount} is not 0, {@code pEnabledValidationFeatures} <b>must</b> be a valid pointer to an array of {@code enabledValidationFeatureCount} valid {@code VkValidationFeatureEnableEXT} values</li>
            <li>If {@code disabledValidationFeatureCount} is not 0, {@code pDisabledValidationFeatures} <b>must</b> be a valid pointer to an array of {@code disabledValidationFeatureCount} valid {@code VkValidationFeatureDisableEXT} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VALIDATION_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pEnabledValidationFeatures", optional = true)..uint32_t("enabledValidationFeatureCount", "the number of features to enable.")
    VkValidationFeatureEnableEXT.const.p("pEnabledValidationFeatures", "a pointer to an array of {@code VkValidationFeatureEnableEXT} values specifying the validation features to be enabled.")
    AutoSize("pDisabledValidationFeatures", optional = true)..uint32_t("disabledValidationFeatureCount", "the number of features to disable.")
    VkValidationFeatureDisableEXT.const.p("pDisabledValidationFeatures", "a pointer to an array of {@code VkValidationFeatureDisableEXT} values specifying the validation features to be disabled.")
}

val VkPhysicalDevicePresentWaitFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDevicePresentWaitFeaturesKHR") {
    documentation =
        """
        Structure indicating support for present wait.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePresentWaitFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePresentWaitFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("presentWait", "indicates that the implementation supports {@code vkWaitForPresentKHR}.")
}

val VkCooperativeMatrixPropertiesNV = struct(Module.VULKAN, "VkCooperativeMatrixPropertiesNV") {
    documentation =
        """
        Structure specifying cooperative matrix properties.

        <h5>Description</h5>
        If some types are preferred over other types (e.g. for performance), they <b>should</b> appear earlier in the list enumerated by #GetPhysicalDeviceCooperativeMatrixPropertiesNV().

        At least one entry in the list <b>must</b> have power of two values for all of {@code MSize}, {@code KSize}, and {@code NSize}.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code AType} <b>must</b> be a valid {@code VkComponentTypeNV} value</li>
            <li>{@code BType} <b>must</b> be a valid {@code VkComponentTypeNV} value</li>
            <li>{@code CType} <b>must</b> be a valid {@code VkComponentTypeNV} value</li>
            <li>{@code DType} <b>must</b> be a valid {@code VkComponentTypeNV} value</li>
            <li>{@code scope} <b>must</b> be a valid {@code VkScopeNV} value</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceCooperativeMatrixPropertiesNV()
        """

    Expression("#STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("MSize", "the number of rows in matrices A, C, and D.")
    uint32_t("NSize", "the number of columns in matrices B, C, D.")
    uint32_t("KSize", "the number of columns in matrix A and rows in matrix B.")
    VkComponentTypeNV("AType", "the component type of matrix A, of type {@code VkComponentTypeNV}.")
    VkComponentTypeNV("BType", "the component type of matrix B, of type {@code VkComponentTypeNV}.")
    VkComponentTypeNV("CType", "the component type of matrix C, of type {@code VkComponentTypeNV}.")
    VkComponentTypeNV("DType", "the component type of matrix D, of type {@code VkComponentTypeNV}.")
    VkScopeNV("scope", "the scope of all the matrix types, of type {@code VkScopeNV}.")
}

val VkPhysicalDeviceCooperativeMatrixFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceCooperativeMatrixFeaturesNV") {
    documentation =
        """
        Structure describing cooperative matrix features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCooperativeMatrixFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("cooperativeMatrix", "indicates that the implementation supports the {@code CooperativeMatrixNV} SPIR-V capability.")
    VkBool32("cooperativeMatrixRobustBufferAccess", "indicates that the implementation supports robust buffer access for SPIR-V {@code OpCooperativeMatrixLoadNV} and {@code OpCooperativeMatrixStoreNV} instructions.")
}

val VkPhysicalDeviceCooperativeMatrixPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceCooperativeMatrixPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing cooperative matrix properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCooperativeMatrixPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkShaderStageFlags("cooperativeMatrixSupportedStages", "a bitfield of {@code VkShaderStageFlagBits} describing the shader stages that cooperative matrix instructions are supported in. {@code cooperativeMatrixSupportedStages} will have the #SHADER_STAGE_COMPUTE_BIT bit set if any of the physical device’s queues support #QUEUE_COMPUTE_BIT.")
}

val VkPhysicalDeviceCoverageReductionModeFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceCoverageReductionModeFeaturesNV") {
    documentation =
        """
        Structure describing the coverage reduction mode features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCoverageReductionModeFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCoverageReductionModeFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("coverageReductionMode", "indicates whether the implementation supports coverage reduction modes. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-coverage-reduction\">Coverage Reduction</a>.")
}

val VkPipelineCoverageReductionStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineCoverageReductionStateCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters controlling coverage reduction.

        <h5>Description</h5>
        If this structure is not included in the {@code pNext} chain, or if the extension is not enabled, the default coverage reduction mode is inferred as follows:

        <ul>
            <li>If the {@link NVFramebufferMixedSamples VK_NV_framebuffer_mixed_samples} extension is enabled, then it is as if the {@code coverageReductionMode} is #COVERAGE_REDUCTION_MODE_MERGE_NV.</li>
            <li>If the {@link AMDMixedAttachmentSamples VK_AMD_mixed_attachment_samples} extension is enabled, then it is as if the {@code coverageReductionMode} is #COVERAGE_REDUCTION_MODE_TRUNCATE_NV.</li>
            <li>If both {@link NVFramebufferMixedSamples VK_NV_framebuffer_mixed_samples} and {@link AMDMixedAttachmentSamples VK_AMD_mixed_attachment_samples} are enabled, then the default coverage reduction mode is implementation-dependent.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code coverageReductionMode} <b>must</b> be a valid {@code VkCoverageReductionModeNV} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCoverageReductionStateCreateFlagsNV("flags", "reserved for future use.")
    VkCoverageReductionModeNV("coverageReductionMode", "a {@code VkCoverageReductionModeNV} value controlling how color sample coverage is generated from pixel coverage.")
}

val VkFramebufferMixedSamplesCombinationNV = struct(Module.VULKAN, "VkFramebufferMixedSamplesCombinationNV", mutable = false) {
    documentation =
        """
        Structure specifying a supported sample count combination.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV()
        """

    Expression("#STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkCoverageReductionModeNV("coverageReductionMode", "a {@code VkCoverageReductionModeNV} value specifying the coverage reduction mode.")
    VkSampleCountFlagBits("rasterizationSamples", "a {@code VkSampleCountFlagBits} specifying the number of rasterization samples in the supported combination.")
    VkSampleCountFlags("depthStencilSamples", "specifies the number of samples in the depth stencil attachment in the supported combination. A value of 0 indicates the combination does not have a depth stencil attachment.")
    VkSampleCountFlags("colorSamples", "specifies the number of color samples in a color attachment in the supported combination. A value of 0 indicates the combination does not have a color attachment.")
}

val VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT") {
    documentation =
        """
        Structure describing fragment shader interlock features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("fragmentShaderSampleInterlock", "indicates that the implementation supports the {@code FragmentShaderSampleInterlockEXT} SPIR-V capability.")
    VkBool32("fragmentShaderPixelInterlock", "indicates that the implementation supports the {@code FragmentShaderPixelInterlockEXT} SPIR-V capability.")
    VkBool32("fragmentShaderShadingRateInterlock", "indicates that the implementation supports the {@code FragmentShaderShadingRateInterlockEXT} SPIR-V capability.")
}

val VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT") {
    documentation =
        """
        Structure describing extended Y′C<sub>B</sub>C<sub>R</sub> image creation features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceYcbcrImageArraysFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("ycbcrImageArrays", "indicates that the implementation supports creating images with a format that requires <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#formats-requiring-sampler-ycbcr-conversion\">Y′C<sub>B</sub>C<sub>R</sub> conversion</a> and has multiple array layers.")
}

val VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR", alias = VkPhysicalDeviceUniformBufferStandardLayoutFeatures) {
    documentation = "See ##VkPhysicalDeviceUniformBufferStandardLayoutFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("uniformBufferStandardLayout", "")
}

val VkPhysicalDeviceProvokingVertexFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceProvokingVertexFeaturesEXT") {
    documentation =
        """
        Structure describing the provoking vertex features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceProvokingVertexFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceProvokingVertexFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        When ##VkPhysicalDeviceProvokingVertexFeaturesEXT is in the {@code pNext} chain of ##VkDeviceCreateInfo but the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-transformFeedback">{@code transformFeedback}</a> feature is not enabled, the value of {@code transformFeedbackPreservesProvokingVertex} is ignored.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("provokingVertexLast", "indicates whether the implementation supports the #PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT provoking vertex mode ({@code VkProvokingVertexModeEXT}) for flat shading.")
    VkBool32("transformFeedbackPreservesProvokingVertex", "indicates that the order of vertices within each primitive written by transform feedback will preserve the provoking vertex. This does not apply to triangle fan primitives when <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#limits-transformFeedbackPreservesTriangleFanProvokingVertex\">{@code transformFeedbackPreservesTriangleFanProvokingVertex}</a> is #FALSE. {@code transformFeedbackPreservesProvokingVertex} <b>must</b> be #FALSE when the {@link EXTTransformFeedback VK_EXT_transform_feedback} extension is not supported.")
}

val VkPhysicalDeviceProvokingVertexPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceProvokingVertexPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing provoking vertex properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceProvokingVertexPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("provokingVertexModePerPipeline", "indicates whether the implementation supports graphics pipelines with different provoking vertex modes within the same render pass instance.")
    VkBool32("transformFeedbackPreservesTriangleFanProvokingVertex", "indicates whether the implementation can preserve the provoking vertex order when writing triangle fan vertices to transform feedback.")
}

val VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying provoking vertex mode used by a graphics pipeline.

        <h5>Description</h5>
        If this struct is not provided when creating the pipeline, the pipeline will use the #PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT mode.

        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-provokingVertexModePerPipeline">{@code provokingVertexModePerPipeline}</a> limit is #FALSE, then all pipelines bound within a render pass instance <b>must</b> have the same {@code provokingVertexMode}.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code provokingVertexMode} is #PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-provokingVertexLast">{@code provokingVertexLast}</a> feature <b>must</b> be enabled</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT</li>
            <li>{@code provokingVertexMode} <b>must</b> be a valid {@code VkProvokingVertexModeEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkProvokingVertexModeEXT("provokingVertexMode", "a {@code VkProvokingVertexModeEXT} value selecting the provoking vertex mode.")
}

val VkSurfaceFullScreenExclusiveInfoEXT = struct(Module.VULKAN, "VkSurfaceFullScreenExclusiveInfoEXT") {
    documentation =
        """
        Structure specifying the preferred full-screen transition behavior.

        <h5>Description</h5>
        If this structure is not present, {@code fullScreenExclusive} is considered to be #FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT</li>
            <li>{@code fullScreenExclusive} <b>must</b> be a valid {@code VkFullScreenExclusiveEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFullScreenExclusiveEXT("fullScreenExclusive", "a {@code VkFullScreenExclusiveEXT} value specifying the preferred full-screen transition behavior.")
}

val VkSurfaceCapabilitiesFullScreenExclusiveEXT = struct(Module.VULKAN, "VkSurfaceCapabilitiesFullScreenExclusiveEXT") {
    documentation =
        """
        Structure describing full screen exclusive capabilities of a surface.

        <h5>Description</h5>
        This structure <b>can</b> be included in the {@code pNext} chain of ##VkSurfaceCapabilities2KHR to determine support for exclusive full-screen access. If {@code fullScreenExclusiveSupported} is #FALSE, it indicates that exclusive full-screen access is not obtainable for this surface.

        Applications <b>must</b> not attempt to create swapchains with #FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT set if {@code fullScreenExclusiveSupported} is #FALSE.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("fullScreenExclusiveSupported", "")
}

val VkSurfaceFullScreenExclusiveWin32InfoEXT = struct(Module.VULKAN, "VkSurfaceFullScreenExclusiveWin32InfoEXT") {
    javaImport("org.lwjgl.system.windows.*")
    documentation =
        """
        Structure specifying additional creation parameters specific to Win32 fullscreen exclusive mode.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        If {@code hmonitor} is invalidated (e.g. the monitor is unplugged) during the lifetime of a swapchain created with this structure, operations on that swapchain will return #ERROR_OUT_OF_DATE_KHR.
        </div>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        It is the responsibility of the application to change the display settings of the targeted Win32 display using the appropriate platform APIs. Such changes <b>may</b> alter the surface capabilities reported for the created surface.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code hmonitor} <b>must</b> be a valid {@code HMONITOR}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    HMONITOR("hmonitor", "the Win32 {@code HMONITOR} handle identifying the display to create the surface with.")
}

val VkHeadlessSurfaceCreateInfoEXT = struct(Module.VULKAN, "VkHeadlessSurfaceCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created headless surface object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateHeadlessSurfaceEXT()
        """

    Expression("#STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkHeadlessSurfaceCreateFlagsEXT("flags", "reserved for future use.")
}

val VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceBufferDeviceAddressFeaturesKHR", alias = VkPhysicalDeviceBufferDeviceAddressFeatures) {
    documentation = "See ##VkPhysicalDeviceBufferDeviceAddressFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("bufferDeviceAddress", "")
    VkBool32("bufferDeviceAddressCaptureReplay", "")
    VkBool32("bufferDeviceAddressMultiDevice", "")
}

val VkBufferDeviceAddressInfoKHR = struct(Module.VULKAN, "VkBufferDeviceAddressInfoKHR", alias = VkBufferDeviceAddressInfo) {
    documentation = "See ##VkBufferDeviceAddressInfo."

    Expression("#STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBuffer("buffer", "")
}

val VkBufferOpaqueCaptureAddressCreateInfoKHR = struct(Module.VULKAN, "VkBufferOpaqueCaptureAddressCreateInfoKHR", alias = VkBufferOpaqueCaptureAddressCreateInfo) {
    documentation = "See ##VkBufferOpaqueCaptureAddressCreateInfo."

    Expression("#STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint64_t("opaqueCaptureAddress", "")
}

val VkMemoryOpaqueCaptureAddressAllocateInfoKHR = struct(Module.VULKAN, "VkMemoryOpaqueCaptureAddressAllocateInfoKHR", alias = VkMemoryOpaqueCaptureAddressAllocateInfo) {
    documentation = "See ##VkMemoryOpaqueCaptureAddressAllocateInfo."

    Expression("#STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint64_t("opaqueCaptureAddress", "")
}

val VkDeviceMemoryOpaqueCaptureAddressInfoKHR = struct(Module.VULKAN, "VkDeviceMemoryOpaqueCaptureAddressInfoKHR", alias = VkDeviceMemoryOpaqueCaptureAddressInfo) {
    documentation = "See ##VkDeviceMemoryOpaqueCaptureAddressInfo."

    Expression("#STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkDeviceMemory("memory", "")
}

val VkPhysicalDeviceLineRasterizationFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceLineRasterizationFeaturesEXT") {
    documentation =
        """
        Structure describing the line rasterization features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceLineRasterizationFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceLineRasterizationFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rectangularLines", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines\">rectangular line rasterization</a>.")
    VkBool32("bresenhamLines", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines-bresenham\">Bresenham-style line rasterization</a>.")
    VkBool32("smoothLines", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines-smooth\">smooth line rasterization</a>.")
    VkBool32("stippledRectangularLines", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines-stipple\">stippled line rasterization</a> with #LINE_RASTERIZATION_MODE_RECTANGULAR_EXT lines.")
    VkBool32("stippledBresenhamLines", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines-stipple\">stippled line rasterization</a> with #LINE_RASTERIZATION_MODE_BRESENHAM_EXT lines.")
    VkBool32("stippledSmoothLines", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines-stipple\">stippled line rasterization</a> with #LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT lines.")
}

val VkPhysicalDeviceLineRasterizationPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceLineRasterizationPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing line rasterization properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceLineRasterizationPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("lineSubPixelPrecisionBits", "the number of bits of subpixel precision in framebuffer coordinates <code>x<sub>f</sub></code> and <code>y<sub>f</sub></code> when rasterizing <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines\">line segments</a>.")
}

val VkPipelineRasterizationLineStateCreateInfoEXT = struct(Module.VULKAN, "VkPipelineRasterizationLineStateCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created pipeline line rasterization state.

        <h5>Description</h5>
        If {@code stippledLineEnable} is #FALSE, the values of {@code lineStippleFactor} and {@code lineStipplePattern} are ignored.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code lineRasterizationMode} is #LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-rectangularLines">{@code rectangularLines}</a> feature <b>must</b> be enabled</li>
            <li>If {@code lineRasterizationMode} is #LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-bresenhamLines">{@code bresenhamLines}</a> feature <b>must</b> be enabled</li>
            <li>If {@code lineRasterizationMode} is #LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-smoothLines">{@code smoothLines}</a> feature <b>must</b> be enabled</li>
            <li>If {@code stippledLineEnable} is #TRUE and {@code lineRasterizationMode} is #LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-stippledRectangularLines">{@code stippledRectangularLines}</a> feature <b>must</b> be enabled</li>
            <li>If {@code stippledLineEnable} is #TRUE and {@code lineRasterizationMode} is #LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-stippledBresenhamLines">{@code stippledBresenhamLines}</a> feature <b>must</b> be enabled</li>
            <li>If {@code stippledLineEnable} is #TRUE and {@code lineRasterizationMode} is #LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-stippledSmoothLines">{@code stippledSmoothLines}</a> feature <b>must</b> be enabled</li>
            <li>If {@code stippledLineEnable} is #TRUE and {@code lineRasterizationMode} is #LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-stippledRectangularLines">{@code stippledRectangularLines}</a> feature <b>must</b> be enabled and ##VkPhysicalDeviceLimits{@code ::strictLines} <b>must</b> be #TRUE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT</li>
            <li>{@code lineRasterizationMode} <b>must</b> be a valid {@code VkLineRasterizationModeEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkLineRasterizationModeEXT("lineRasterizationMode", "a {@code VkLineRasterizationModeEXT} value selecting the style of line rasterization.")
    VkBool32("stippledLineEnable", "enables <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-lines-stipple\">stippled line rasterization</a>.")
    uint32_t("lineStippleFactor", "the repeat factor used in stippled line rasterization.")
    uint16_t("lineStipplePattern", "the bit pattern used in stippled line rasterization.")
}

val VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT") {
    documentation =
        """
        Structure describing features supported by VK_EXT_shader_atomic_float.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderAtomicFloatFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderBufferFloat32Atomics", "indicates whether shaders <b>can</b> perform 32-bit floating-point load, store and exchange atomic operations on storage buffers.")
    VkBool32("shaderBufferFloat32AtomicAdd", "indicates whether shaders <b>can</b> perform 32-bit floating-point add atomic operations on storage buffers.")
    VkBool32("shaderBufferFloat64Atomics", "indicates whether shaders <b>can</b> perform 64-bit floating-point load, store and exchange atomic operations on storage buffers.")
    VkBool32("shaderBufferFloat64AtomicAdd", "indicates whether shaders <b>can</b> perform 64-bit floating-point add atomic operations on storage buffers.")
    VkBool32("shaderSharedFloat32Atomics", "indicates whether shaders <b>can</b> perform 32-bit floating-point load, store and exchange atomic operations on shared and payload memory.")
    VkBool32("shaderSharedFloat32AtomicAdd", "indicates whether shaders <b>can</b> perform 32-bit floating-point add atomic operations on shared and payload memory.")
    VkBool32("shaderSharedFloat64Atomics", "indicates whether shaders <b>can</b> perform 64-bit floating-point load, store and exchange atomic operations on shared and payload memory.")
    VkBool32("shaderSharedFloat64AtomicAdd", "indicates whether shaders <b>can</b> perform 64-bit floating-point add atomic operations on shared and payload memory.")
    VkBool32("shaderImageFloat32Atomics", "indicates whether shaders <b>can</b> perform 32-bit floating-point load, store and exchange atomic image operations.")
    VkBool32("shaderImageFloat32AtomicAdd", "indicates whether shaders <b>can</b> perform 32-bit floating-point add atomic image operations.")
    VkBool32("sparseImageFloat32Atomics", "indicates whether 32-bit floating-point load, store and exchange atomic operations <b>can</b> be used on sparse images.")
    VkBool32("sparseImageFloat32AtomicAdd", "indicates whether 32-bit floating-point add atomic operations <b>can</b> be used on sparse images.")
}

val VkPhysicalDeviceHostQueryResetFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceHostQueryResetFeaturesEXT", alias = VkPhysicalDeviceHostQueryResetFeatures) {
    documentation = "See ##VkPhysicalDeviceHostQueryResetFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("hostQueryReset", "")
}

val VkPhysicalDeviceIndexTypeUint8FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceIndexTypeUint8FeaturesEXT") {
    documentation =
        """
        Structure describing whether uint8 index type can be used.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceIndexTypeUint8FeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceIndexTypeUint8FeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("indexTypeUint8", "indicates that #INDEX_TYPE_UINT8_EXT can be used with #CmdBindIndexBuffer2KHR() and #CmdBindIndexBuffer().")
}

val VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT") {
    documentation =
        """
        Structure describing what extended dynamic state can be used.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceExtendedDynamicStateFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceExtendedDynamicStateFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("extendedDynamicState", """indicates that the implementation supports the following dynamic states:

        <ul>
            <li>#DYNAMIC_STATE_CULL_MODE</li>
            <li>#DYNAMIC_STATE_FRONT_FACE</li>
            <li>#DYNAMIC_STATE_PRIMITIVE_TOPOLOGY</li>
            <li>#DYNAMIC_STATE_VIEWPORT_WITH_COUNT</li>
            <li>#DYNAMIC_STATE_SCISSOR_WITH_COUNT</li>
            <li>#DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE</li>
            <li>#DYNAMIC_STATE_DEPTH_TEST_ENABLE</li>
            <li>#DYNAMIC_STATE_DEPTH_WRITE_ENABLE</li>
            <li>#DYNAMIC_STATE_DEPTH_COMPARE_OP</li>
            <li>#DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE</li>
            <li>#DYNAMIC_STATE_STENCIL_TEST_ENABLE</li>
            <li>#DYNAMIC_STATE_STENCIL_OP</li>
        </ul>""")
}

val VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR") {
    documentation =
        """
        Structure describing whether pipeline executable properties are available.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("pipelineExecutableInfo", "indicates that the implementation supports reporting properties and statistics about the pipeline executables associated with a compiled pipeline.")
}

val VkPipelineInfoKHR = struct(Module.VULKAN, "VkPipelineInfoKHR") {
    documentation =
        """
        Structure describing a pipeline.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pipeline} <b>must</b> be a valid {@code VkPipeline} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetPipelineExecutablePropertiesKHR(), #GetPipelinePropertiesEXT()
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipeline("pipeline", "a {@code VkPipeline} handle.")
}

val VkPipelineExecutablePropertiesKHR = struct(Module.VULKAN, "VkPipelineExecutablePropertiesKHR", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure describing a pipeline executable.

        <h5>Description</h5>
        Not all implementations have a 1:1 mapping between shader stages and pipeline executables and some implementations <b>may</b> reduce a given shader stage to fixed function hardware programming such that no pipeline executable is available. No guarantees are provided about the mapping between shader stages and pipeline executables and {@code stages} <b>should</b> be considered a best effort hint. Because the application <b>cannot</b> rely on the {@code stages} field to provide an exact description, {@code name} and {@code description} provide a human readable name and description which more accurately describes the given pipeline executable.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetPipelineExecutablePropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkShaderStageFlags("stages", "a bitmask of zero or more {@code VkShaderStageFlagBits} indicating which shader stages (if any) were principally used as inputs to compile this pipeline executable.")
    charUTF8("name", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a short human readable name for this pipeline executable.")["VK_MAX_DESCRIPTION_SIZE"]
    charUTF8("description", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a human readable description for this pipeline executable.")["VK_MAX_DESCRIPTION_SIZE"]
    uint32_t("subgroupSize", "the subgroup size with which this pipeline executable is dispatched.")
}

val VkPipelineExecutableInfoKHR = struct(Module.VULKAN, "VkPipelineExecutableInfoKHR") {
    documentation =
        """
        Structure describing a pipeline executable to query for associated statistics or internal representations.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code executableIndex} <b>must</b> be less than the number of pipeline executables associated with {@code pipeline} as returned in the {@code pExecutableCount} parameter of {@code vkGetPipelineExecutablePropertiesKHR}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pipeline} <b>must</b> be a valid {@code VkPipeline} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetPipelineExecutableInternalRepresentationsKHR(), #GetPipelineExecutableStatisticsKHR()
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipeline("pipeline", "the pipeline to query.")
    uint32_t("executableIndex", "the index of the pipeline executable to query in the array of executable properties returned by #GetPipelineExecutablePropertiesKHR().")
}

val VkPipelineExecutableStatisticValueKHR = union(Module.VULKAN, "VkPipelineExecutableStatisticValueKHR", mutable = false) {
    documentation =
        """
        A union describing a pipeline executable statistic.

        <h5>See Also</h5>
        ##VkPipelineExecutableStatisticKHR
        """

    VkBool32("b32", "the 32-bit boolean value if the {@code VkPipelineExecutableStatisticFormatKHR} is #PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR.")
    int64_t("i64", "the signed 64-bit integer value if the {@code VkPipelineExecutableStatisticFormatKHR} is #PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR.")
    uint64_t("u64", "the unsigned 64-bit integer value if the {@code VkPipelineExecutableStatisticFormatKHR} is #PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR.")
    double("f64", "the 64-bit floating-point value if the {@code VkPipelineExecutableStatisticFormatKHR} is #PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR.")
}

val VkPipelineExecutableStatisticKHR = struct(Module.VULKAN, "VkPipelineExecutableStatisticKHR", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure describing a compile time pipeline executable statistic.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkPipelineExecutableStatisticValueKHR, #GetPipelineExecutableStatisticsKHR()
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    charUTF8("name", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a short human readable name for this statistic.")["VK_MAX_DESCRIPTION_SIZE"]
    charUTF8("description", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a human readable description for this statistic.")["VK_MAX_DESCRIPTION_SIZE"]
    VkPipelineExecutableStatisticFormatKHR("format", "a {@code VkPipelineExecutableStatisticFormatKHR} value specifying the format of the data found in {@code value}.")
    VkPipelineExecutableStatisticValueKHR("value", "the value of this statistic.")
}

val VkPipelineExecutableInternalRepresentationKHR = struct(Module.VULKAN, "VkPipelineExecutableInternalRepresentationKHR", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure describing the textual form of a pipeline executable internal representation.

        <h5>Description</h5>
        If {@code pData} is {@code NULL}, then the size, in bytes, of the internal representation data is returned in {@code dataSize}. Otherwise, {@code dataSize} must be the size of the buffer, in bytes, pointed to by {@code pData} and on return {@code dataSize} is overwritten with the number of bytes of data actually written to {@code pData} including any trailing null character. If {@code dataSize} is less than the size, in bytes, of the internal representation’s data, at most {@code dataSize} bytes of data will be written to {@code pData}, and #INCOMPLETE will be returned instead of #SUCCESS, to indicate that not all the available representation was returned.

        If {@code isText} is #TRUE and {@code pData} is not {@code NULL} and {@code dataSize} is not zero, the last byte written to {@code pData} will be a null character.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetPipelineExecutableInternalRepresentationsKHR()
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    charUTF8("name", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a short human readable name for this internal representation.")["VK_MAX_DESCRIPTION_SIZE"]
    charUTF8("description", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a human readable description for this internal representation.")["VK_MAX_DESCRIPTION_SIZE"]
    VkBool32("isText", "specifies whether the returned data is text or opaque data. If {@code isText} is #TRUE then the data returned in {@code pData} is text and is guaranteed to be a null-terminated UTF-8 string.")
    AutoSize("pData", optional = true)..size_t("dataSize", "an integer related to the size, in bytes, of the internal representation’s data, as described below.")
    nullable..void.p("pData", "either {@code NULL} or a pointer to a block of data into which the implementation will write the internal representation.")
}

val VkPhysicalDeviceHostImageCopyFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceHostImageCopyFeaturesEXT") {
    documentation =
        """
        Structure indicating support for copies to or from images from host memory.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceHostImageCopyFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceHostImageCopyFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("hostImageCopy", "indicates that the implementation supports copying from host memory to images using the #CopyMemoryToImageEXT() command, copying from images to host memory using the #CopyImageToMemoryEXT() command, and copying between images using the #CopyImageToImageEXT() command.")
}

val VkPhysicalDeviceHostImageCopyPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceHostImageCopyPropertiesEXT") {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure enumerating image layouts supported by an implementation for host memory copies.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceHostImageCopyPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        If {@code pCopyDstLayouts} is {@code NULL}, then the number of image layouts that are supported in ##VkCopyMemoryToImageInfoEXT{@code ::dstImageLayout} and ##VkCopyImageToImageInfoEXT{@code ::dstImageLayout} is returned in {@code copyDstLayoutCount}. Otherwise, {@code copyDstLayoutCount} <b>must</b> be set by the user to the number of elements in the {@code pCopyDstLayouts} array, and on return the variable is overwritten with the number of values actually written to {@code pCopyDstLayouts}. If the value of {@code copyDstLayoutCount} is less than the number of image layouts that are supported, at most {@code copyDstLayoutCount} values will be written to {@code pCopyDstLayouts}. The implementation <b>must</b> include the #IMAGE_LAYOUT_GENERAL image layout in {@code pCopyDstLayouts}.

        If {@code pCopySrcLayouts} is {@code NULL}, then the number of image layouts that are supported in ##VkCopyImageToMemoryInfoEXT{@code ::srcImageLayout} and ##VkCopyImageToImageInfoEXT{@code ::srcImageLayout} is returned in {@code copySrcLayoutCount}. Otherwise, {@code copySrcLayoutCount} <b>must</b> be set by the user to the number of elements in the {@code pCopySrcLayouts} array, and on return the variable is overwritten with the number of values actually written to {@code pCopySrcLayouts}. If the value of {@code copySrcLayoutCount} is less than the number of image layouts that are supported, at most {@code copySrcLayoutCount} values will be written to {@code pCopySrcLayouts}. The implementation <b>must</b> include the #IMAGE_LAYOUT_GENERAL image layout in {@code pCopySrcLayouts}.

        The {@code optimalTilingLayoutUUID} value can be used to ensure compatible data layouts when using the #HOST_IMAGE_COPY_MEMCPY_EXT flag in #CopyMemoryToImageEXT() and #CopyImageToMemoryEXT().

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT</li>
            <li>If {@code copySrcLayoutCount} is not 0, and {@code pCopySrcLayouts} is not {@code NULL}, {@code pCopySrcLayouts} <b>must</b> be a valid pointer to an array of {@code copySrcLayoutCount} {@code VkImageLayout} values</li>
            <li>If {@code copyDstLayoutCount} is not 0, and {@code pCopyDstLayouts} is not {@code NULL}, {@code pCopyDstLayouts} <b>must</b> be a valid pointer to an array of {@code copyDstLayoutCount} {@code VkImageLayout} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pCopySrcLayouts", optional = true)..uint32_t("copySrcLayoutCount", "an integer related to the number of image layouts for host copies from images available or queried, as described below.")
    nullable..VkImageLayout.p("pCopySrcLayouts", "a pointer to an array of {@code VkImageLayout} in which supported image layouts for use with host copy operations from images are returned.")
    AutoSize("pCopyDstLayouts", optional = true)..uint32_t("copyDstLayoutCount", "an integer related to the number of image layouts for host copies to images available or queried, as described below.")
    nullable..VkImageLayout.p("pCopyDstLayouts", "a pointer to an array of {@code VkImageLayout} in which supported image layouts for use with host copy operations to images are returned.")
    uint8_t("optimalTilingLayoutUUID", "an array of #UUID_SIZE {@code uint8_t} values representing a universally unique identifier for the implementation’s swizzling layout of images created with #IMAGE_TILING_OPTIMAL.")["VK_UUID_SIZE"]
    VkBool32("identicalMemoryTypeRequirements", "indicates that specifying the #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT flag in ##VkImageCreateInfo{@code ::usage} does not affect the memory type requirements of the image.")
}

val VkMemoryToImageCopyEXT = struct(Module.VULKAN, "VkMemoryToImageCopyEXT") {
    documentation =
        """
        Structure specifying a host memory to image copy operation.

        <h5>Description</h5>
        This structure is functionally similar to ##VkBufferImageCopy2, except it defines host memory as the source of copy instead of a buffer. In particular, the same data packing rules and restrictions as that structure apply here as well.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code pHostPointer} <b>must</b> point to memory that is large enough to contain all memory locations that are accessed according to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#copies-buffers-images-addressing">Buffer and Image Addressing</a>, for each element of {@code pRegions}</li>
            <li>The union of all source regions, and the union of all destination regions, specified by the elements of {@code pRegions}, <b>must</b> not overlap in memory</li>
        </ul>

        <ul>
            <li>{@code bufferRowLength} <b>must</b> be 0, or greater than or equal to the {@code width} member of {@code imageExtent}</li>
            <li>{@code bufferImageHeight} <b>must</b> be 0, or greater than or equal to the {@code height} member of {@code imageExtent}</li>
            <li>The {@code aspectMask} member of {@code imageSubresource} <b>must</b> only have a single bit set</li>
            <li>{@code imageExtent.width} <b>must</b> not be 0</li>
            <li>{@code imageExtent.height} <b>must</b> not be 0</li>
            <li>{@code imageExtent.depth} <b>must</b> not be 0</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pHostPointer} <b>must</b> be a pointer value</li>
            <li>{@code imageSubresource} <b>must</b> be a valid ##VkImageSubresourceLayers structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkCopyMemoryToImageInfoEXT, ##VkExtent3D, ##VkImageSubresourceLayers, ##VkOffset3D
        """

    Expression("#STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    opaque_const_p("pHostPointer", "the host memory address which is the source of the copy.")
    uint32_t("memoryRowLength", "{@code memoryRowLength} and {@code memoryImageHeight} specify in texels a subregion of a larger two- or three-dimensional image in host memory, and control the addressing calculations. If either of these values is zero, that aspect of the host memory is considered to be tightly packed according to the {@code imageExtent}.")
    uint32_t("memoryImageHeight", "see {@code memoryRowLength}")
    VkImageSubresourceLayers("imageSubresource", "a ##VkImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.")
    VkOffset3D("imageOffset", "selects the initial {@code x}, {@code y}, {@code z} offsets in texels of the sub-region of the destination image data.")
    VkExtent3D("imageExtent", "the size in texels of the image to copy in {@code width}, {@code height} and {@code depth}.")
}

val VkImageToMemoryCopyEXT = struct(Module.VULKAN, "VkImageToMemoryCopyEXT") {
    documentation =
        """
        Structure specifying an image to host memory copy operation.

        <h5>Description</h5>
        This structure is functionally similar to ##VkBufferImageCopy2, except it defines host memory as the target of copy instead of a buffer. In particular, the same data packing rules and restrictions as that structure apply here as well.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code pHostPointer} <b>must</b> point to memory that is large enough to contain all memory locations that are accessed according to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#copies-buffers-images-addressing">Buffer and Image Addressing</a>, for each element of {@code pRegions}</li>
            <li>The union of all source regions, and the union of all destination regions, specified by the elements of {@code pRegions}, <b>must</b> not overlap in memory</li>
        </ul>

        <ul>
            <li>{@code bufferRowLength} <b>must</b> be 0, or greater than or equal to the {@code width} member of {@code imageExtent}</li>
            <li>{@code bufferImageHeight} <b>must</b> be 0, or greater than or equal to the {@code height} member of {@code imageExtent}</li>
            <li>The {@code aspectMask} member of {@code imageSubresource} <b>must</b> only have a single bit set</li>
            <li>{@code imageExtent.width} <b>must</b> not be 0</li>
            <li>{@code imageExtent.height} <b>must</b> not be 0</li>
            <li>{@code imageExtent.depth} <b>must</b> not be 0</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pHostPointer} <b>must</b> be a pointer value</li>
            <li>{@code imageSubresource} <b>must</b> be a valid ##VkImageSubresourceLayers structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkCopyImageToMemoryInfoEXT, ##VkExtent3D, ##VkImageSubresourceLayers, ##VkOffset3D
        """

    Expression("#STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    opaque_p("pHostPointer", "the host memory address which is the destination of the copy.")
    uint32_t("memoryRowLength", "{@code memoryRowLength} and {@code memoryImageHeight} specify in texels a subregion of a larger two- or three-dimensional image in host memory, and control the addressing calculations. If either of these values is zero, that aspect of the host memory is considered to be tightly packed according to the {@code imageExtent}.")
    uint32_t("memoryImageHeight", "see {@code memoryRowLength}")
    VkImageSubresourceLayers("imageSubresource", "a ##VkImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.")
    VkOffset3D("imageOffset", "selects the initial {@code x}, {@code y}, {@code z} offsets in texels of the sub-region of the source image data.")
    VkExtent3D("imageExtent", "the size in texels of the image to copy in {@code width}, {@code height} and {@code depth}.")
}

val VkCopyMemoryToImageInfoEXT = struct(Module.VULKAN, "VkCopyMemoryToImageInfoEXT") {
    documentation =
        """
        Structure specifying parameters of host memory to image copy command.

        <h5>Description</h5>
        {@code vkCopyMemoryToImageEXT} does not check whether the device memory associated with {@code dstImage} is currently in use before performing the copy. The application <b>must</b> guarantee that any previously submitted command that reads from or writes to the copy regions has completed before the host performs the copy.

        Copy regions for the image <b>must</b> be aligned to a multiple of the texel block extent in each dimension, except at the edges of the image, where region extents <b>must</b> match the edge of the image.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code dstImage} is sparse then all memory ranges accessed by the copy command <b>must</b> be bound as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#sparsememory-resource-binding">Binding Resource Memory</a></li>
            <li>If the stencil aspect of {@code dstImage} is accessed, and {@code dstImage} was not created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If the stencil aspect of {@code dstImage} is accessed, and {@code dstImage} was created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageStencilUsageCreateInfo{@code ::stencilUsage}</li>
            <li>If non-stencil aspects of {@code dstImage} are accessed, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code x}, {@code y}, and {@code z} members of the {@code dstOffset} member of each element of {@code pRegions} <b>must</b> be 0</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code extent} member of each element of {@code pRegions} <b>must</b> equal the extents of {@code dstImage} identified by {@code dstSubresource}</li>
        </ul>

        <ul>
            <li>If {@code dstImage} is non-sparse then the image or the specified <em>disjoint</em> plane <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The {@code dstSubresource.mipLevel} member of each element of {@code pRegions} <b>must</b> be less than the {@code mipLevels} specified in ##VkImageCreateInfo when {@code dstImage} was created</li>
            <li>The <code>{@code dstSubresource.baseArrayLayer} + {@code dstSubresource.layerCount}</code> of each element of {@code pRegions} , if {@code dstSubresource.layerCount} is not #REMAINING_ARRAY_LAYERS and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-maintenance5">{@code maintenance5}</a> is not enabled, <b>must</b> be less than or equal to the {@code arrayLayers} specified in ##VkImageCreateInfo when {@code dstImage} was created</li>
            <li>{@code dstImage} <b>must</b> not have been created with {@code flags} containing #IMAGE_CREATE_SUBSAMPLED_BIT_EXT</li>
        </ul>

        <ul>
            <li>The image region specified by each element of {@code pRegions} <b>must</b> be contained within the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.x} and <code>({@code extent.width} + {@code dstOffset.x})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the width of the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.y} and <code>({@code extent.height} + {@code dstOffset.y})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the height of the specified {@code dstSubresource} of {@code dstImage}</li>
        </ul>

        <ul>
            <li>{@code dstImage} <b>must</b> have a sample count equal to #SAMPLE_COUNT_1_BIT</li>
        </ul>

        <ul>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_1D, then for each element of {@code pRegions}, {@code dstOffset.y} <b>must</b> be 0 and {@code extent.height} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.z} and <code>({@code extent.depth} + {@code dstOffset.z})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the depth of the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_1D or #IMAGE_TYPE_2D, then for each element of {@code pRegions}, {@code dstOffset.z} <b>must</b> be 0 and {@code extent.depth} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.x} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.y} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.z} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.x} and {@code extent.width} does not equal the width of the subresource specified by {@code srcSubresource}, {@code extent.width} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.y} and {@code extent.height} does not equal the height of the subresource specified by {@code srcSubresource}, {@code extent.height} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.z} and {@code extent.depth} does not equal the depth of the subresource specified by {@code srcSubresource}, {@code extent.depth} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstSubresource.aspectMask} <b>must</b> specify aspects present in {@code dstImage}</li>
            <li>If {@code dstImage} has a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-requiring-sampler-ycbcr-conversion">multi-planar image format</a>, then for each element of {@code pRegions}, {@code dstSubresource.aspectMask} <b>must</b> be a single valid <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-planes-image-aspect">multi-planar aspect mask</a> bit</li>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_3D, for each element of {@code pRegions}, {@code dstSubresource.baseArrayLayer} <b>must</b> be 0 and {@code dstSubresource.layerCount} <b>must</b> be 1</li>
        </ul>

        <ul>
            <li>For each element of {@code pRegions}, {@code bufferRowLength} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code bufferImageHeight} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code bufferRowLength} divided by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> and then multiplied by the texel block size of {@code dstImage} <b>must</b> be less than or equal to <code>2<sup>31</sup>-1</code></li>
            <li>{@code dstImageLayout} <b>must</b> specify the current layout of the image subresources of {@code dstImage} specified in {@code pRegions}</li>
            <li>{@code dstImageLayout} <b>must</b> be one of the image layouts returned in ##VkPhysicalDeviceHostImageCopyPropertiesEXT{@code ::pCopyDstLayouts}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkHostImageCopyFlagBitsEXT} values</li>
            <li>{@code dstImage} <b>must</b> be a valid {@code VkImage} handle</li>
            <li>{@code dstImageLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
            <li>{@code pRegions} <b>must</b> be a valid pointer to an array of {@code regionCount} valid ##VkMemoryToImageCopyEXT structures</li>
            <li>{@code regionCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkMemoryToImageCopyEXT, #CopyMemoryToImageEXT()
        """

    Expression("#STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkHostImageCopyFlagsEXT("flags", "a bitmask of {@code VkHostImageCopyFlagBitsEXT} values describing additional copy parameters.")
    VkImage("dstImage", "the destination image.")
    VkImageLayout("dstImageLayout", "the layout of the destination image subresources for the copy.")
    AutoSize("pRegions")..uint32_t("regionCount", "the number of regions to copy.")
    VkMemoryToImageCopyEXT.const.p("pRegions", "a pointer to an array of ##VkMemoryToImageCopyEXT structures specifying the regions to copy.")
}

val VkCopyImageToMemoryInfoEXT = struct(Module.VULKAN, "VkCopyImageToMemoryInfoEXT") {
    documentation =
        """
        Structure specifying parameters of an image to host memory copy command.

        <h5>Description</h5>
        {@code vkCopyImageToMemoryEXT} does not check whether the device memory associated with {@code srcImage} is currently in use before performing the copy. The application <b>must</b> guarantee that any previously submitted command that writes to the copy regions has completed before the host performs the copy.

        Copy regions for the image <b>must</b> be aligned to a multiple of the texel block extent in each dimension, except at the edges of the image, where region extents <b>must</b> match the edge of the image.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code dstImage} is sparse then all memory ranges accessed by the copy command <b>must</b> be bound as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#sparsememory-resource-binding">Binding Resource Memory</a></li>
            <li>If the stencil aspect of {@code dstImage} is accessed, and {@code dstImage} was not created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If the stencil aspect of {@code dstImage} is accessed, and {@code dstImage} was created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageStencilUsageCreateInfo{@code ::stencilUsage}</li>
            <li>If non-stencil aspects of {@code dstImage} are accessed, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code x}, {@code y}, and {@code z} members of the {@code dstOffset} member of each element of {@code pRegions} <b>must</b> be 0</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code extent} member of each element of {@code pRegions} <b>must</b> equal the extents of {@code dstImage} identified by {@code dstSubresource}</li>
        </ul>

        <ul>
            <li>If {@code dstImage} is non-sparse then the image or the specified <em>disjoint</em> plane <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The {@code dstSubresource.mipLevel} member of each element of {@code pRegions} <b>must</b> be less than the {@code mipLevels} specified in ##VkImageCreateInfo when {@code dstImage} was created</li>
            <li>The <code>{@code dstSubresource.baseArrayLayer} + {@code dstSubresource.layerCount}</code> of each element of {@code pRegions} , if {@code dstSubresource.layerCount} is not #REMAINING_ARRAY_LAYERS and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-maintenance5">{@code maintenance5}</a> is not enabled, <b>must</b> be less than or equal to the {@code arrayLayers} specified in ##VkImageCreateInfo when {@code dstImage} was created</li>
            <li>{@code dstImage} <b>must</b> not have been created with {@code flags} containing #IMAGE_CREATE_SUBSAMPLED_BIT_EXT</li>
        </ul>

        <ul>
            <li>The image region specified by each element of {@code pRegions} <b>must</b> be contained within the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.x} and <code>({@code extent.width} + {@code dstOffset.x})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the width of the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.y} and <code>({@code extent.height} + {@code dstOffset.y})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the height of the specified {@code dstSubresource} of {@code dstImage}</li>
        </ul>

        <ul>
            <li>{@code dstImage} <b>must</b> have a sample count equal to #SAMPLE_COUNT_1_BIT</li>
        </ul>

        <ul>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_1D, then for each element of {@code pRegions}, {@code dstOffset.y} <b>must</b> be 0 and {@code extent.height} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.z} and <code>({@code extent.depth} + {@code dstOffset.z})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the depth of the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_1D or #IMAGE_TYPE_2D, then for each element of {@code pRegions}, {@code dstOffset.z} <b>must</b> be 0 and {@code extent.depth} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.x} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.y} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.z} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.x} and {@code extent.width} does not equal the width of the subresource specified by {@code srcSubresource}, {@code extent.width} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.y} and {@code extent.height} does not equal the height of the subresource specified by {@code srcSubresource}, {@code extent.height} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.z} and {@code extent.depth} does not equal the depth of the subresource specified by {@code srcSubresource}, {@code extent.depth} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstSubresource.aspectMask} <b>must</b> specify aspects present in {@code dstImage}</li>
            <li>If {@code dstImage} has a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-requiring-sampler-ycbcr-conversion">multi-planar image format</a>, then for each element of {@code pRegions}, {@code dstSubresource.aspectMask} <b>must</b> be a single valid <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-planes-image-aspect">multi-planar aspect mask</a> bit</li>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_3D, for each element of {@code pRegions}, {@code dstSubresource.baseArrayLayer} <b>must</b> be 0 and {@code dstSubresource.layerCount} <b>must</b> be 1</li>
        </ul>

        <ul>
            <li>For each element of {@code pRegions}, {@code bufferRowLength} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code bufferImageHeight} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code bufferRowLength} divided by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> and then multiplied by the texel block size of {@code dstImage} <b>must</b> be less than or equal to <code>2<sup>31</sup>-1</code></li>
            <li>{@code srcImageLayout} <b>must</b> specify the current layout of the image subresources of {@code srcImage} specified in {@code pRegions}</li>
            <li>{@code srcImageLayout} <b>must</b> be one of the image layouts returned in ##VkPhysicalDeviceHostImageCopyPropertiesEXT{@code ::pCopySrcLayouts}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkHostImageCopyFlagBitsEXT} values</li>
            <li>{@code srcImage} <b>must</b> be a valid {@code VkImage} handle</li>
            <li>{@code srcImageLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
            <li>{@code pRegions} <b>must</b> be a valid pointer to an array of {@code regionCount} valid ##VkImageToMemoryCopyEXT structures</li>
            <li>{@code regionCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkImageToMemoryCopyEXT, #CopyImageToMemoryEXT()
        """

    Expression("#STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkHostImageCopyFlagsEXT("flags", "a bitmask of {@code VkHostImageCopyFlagBitsEXT} values describing additional copy parameters.")
    VkImage("srcImage", "the source image.")
    VkImageLayout("srcImageLayout", "the layout of the source image subresources for the copy.")
    AutoSize("pRegions")..uint32_t("regionCount", "the number of regions to copy.")
    VkImageToMemoryCopyEXT.const.p("pRegions", "a pointer to an array of ##VkImageToMemoryCopyEXT structures specifying the regions to copy.")
}

val VkCopyImageToImageInfoEXT = struct(Module.VULKAN, "VkCopyImageToImageInfoEXT") {
    documentation =
        """
        Structure specifying parameters of an image to image host copy command.

        <h5>Description</h5>
        {@code vkCopyImageToImageEXT} does not check whether the device memory associated with {@code srcImage} or {@code dstImage} is currently in use before performing the copy. The application <b>must</b> guarantee that any previously submitted command that writes to the copy regions has completed before the host performs the copy.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code srcImage} and {@code dstImage} <b>must</b> have been created with identical image creation parameters</li>
        </ul>

        <ul>
            <li>If {@code srcImage} is sparse then all memory ranges accessed by the copy command <b>must</b> be bound as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#sparsememory-resource-binding">Binding Resource Memory</a></li>
            <li>If the stencil aspect of {@code srcImage} is accessed, and {@code srcImage} was not created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If the stencil aspect of {@code srcImage} is accessed, and {@code srcImage} was created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageStencilUsageCreateInfo{@code ::stencilUsage}</li>
            <li>If non-stencil aspects of {@code srcImage} are accessed, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code x}, {@code y}, and {@code z} members of the {@code srcOffset} member of each element of {@code pRegions} <b>must</b> be 0</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code extent} member of each element of {@code pRegions} <b>must</b> equal the extents of {@code srcImage} identified by {@code srcSubresource}</li>
        </ul>

        <ul>
            <li>If {@code srcImage} is non-sparse then the image or the specified <em>disjoint</em> plane <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The {@code srcSubresource.mipLevel} member of each element of {@code pRegions} <b>must</b> be less than the {@code mipLevels} specified in ##VkImageCreateInfo when {@code srcImage} was created</li>
            <li>The <code>{@code srcSubresource.baseArrayLayer} + {@code srcSubresource.layerCount}</code> of each element of {@code pRegions} , if {@code srcSubresource.layerCount} is not #REMAINING_ARRAY_LAYERS and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-maintenance5">{@code maintenance5}</a> is not enabled, <b>must</b> be less than or equal to the {@code arrayLayers} specified in ##VkImageCreateInfo when {@code srcImage} was created</li>
            <li>{@code srcImage} <b>must</b> not have been created with {@code flags} containing #IMAGE_CREATE_SUBSAMPLED_BIT_EXT</li>
        </ul>

        <ul>
            <li>The image region specified by each element of {@code pRegions} <b>must</b> be contained within the specified {@code srcSubresource} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, {@code srcOffset.x} and <code>({@code extent.width} + {@code srcOffset.x})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the width of the specified {@code srcSubresource} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, {@code srcOffset.y} and <code>({@code extent.height} + {@code srcOffset.y})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the height of the specified {@code srcSubresource} of {@code srcImage}</li>
        </ul>

        <ul>
            <li>If {@code srcImage} is of type #IMAGE_TYPE_1D, then for each element of {@code pRegions}, {@code srcOffset.y} <b>must</b> be 0 and {@code extent.height} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code srcOffset.z} and <code>({@code extent.depth} + {@code srcOffset.z})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the depth of the specified {@code srcSubresource} of {@code srcImage}</li>
            <li>If {@code srcImage} is of type #IMAGE_TYPE_1D or #IMAGE_TYPE_2D, then for each element of {@code pRegions}, {@code srcOffset.z} <b>must</b> be 0 and {@code extent.depth} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code srcOffset.x} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, {@code srcOffset.y} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, {@code srcOffset.z} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code srcOffset.x} and {@code extent.width} does not equal the width of the subresource specified by {@code srcSubresource}, {@code extent.width} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code srcOffset.y} and {@code extent.height} does not equal the height of the subresource specified by {@code srcSubresource}, {@code extent.height} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code srcOffset.z} and {@code extent.depth} does not equal the depth of the subresource specified by {@code srcSubresource}, {@code extent.depth} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code srcImage}</li>
            <li>For each element of {@code pRegions}, {@code srcSubresource.aspectMask} <b>must</b> specify aspects present in {@code srcImage}</li>
            <li>If {@code srcImage} has a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-requiring-sampler-ycbcr-conversion">multi-planar image format</a>, then for each element of {@code pRegions}, {@code srcSubresource.aspectMask} <b>must</b> be a single valid <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-planes-image-aspect">multi-planar aspect mask</a> bit</li>
            <li>If {@code srcImage} is of type #IMAGE_TYPE_3D, for each element of {@code pRegions}, {@code srcSubresource.baseArrayLayer} <b>must</b> be 0 and {@code srcSubresource.layerCount} <b>must</b> be 1</li>
        </ul>

        <ul>
            <li>If {@code dstImage} is sparse then all memory ranges accessed by the copy command <b>must</b> be bound as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#sparsememory-resource-binding">Binding Resource Memory</a></li>
            <li>If the stencil aspect of {@code dstImage} is accessed, and {@code dstImage} was not created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If the stencil aspect of {@code dstImage} is accessed, and {@code dstImage} was created with <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#VkImageStencilUsageCreateInfo">separate stencil usage</a>, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageStencilUsageCreateInfo{@code ::stencilUsage}</li>
            <li>If non-stencil aspects of {@code dstImage} are accessed, the image <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in ##VkImageCreateInfo{@code ::usage}</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code x}, {@code y}, and {@code z} members of the {@code dstOffset} member of each element of {@code pRegions} <b>must</b> be 0</li>
            <li>If {@code flags} contains #HOST_IMAGE_COPY_MEMCPY_EXT, the {@code extent} member of each element of {@code pRegions} <b>must</b> equal the extents of {@code dstImage} identified by {@code dstSubresource}</li>
        </ul>

        <ul>
            <li>If {@code dstImage} is non-sparse then the image or the specified <em>disjoint</em> plane <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The {@code dstSubresource.mipLevel} member of each element of {@code pRegions} <b>must</b> be less than the {@code mipLevels} specified in ##VkImageCreateInfo when {@code dstImage} was created</li>
            <li>The <code>{@code dstSubresource.baseArrayLayer} + {@code dstSubresource.layerCount}</code> of each element of {@code pRegions} , if {@code dstSubresource.layerCount} is not #REMAINING_ARRAY_LAYERS and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-maintenance5">{@code maintenance5}</a> is not enabled, <b>must</b> be less than or equal to the {@code arrayLayers} specified in ##VkImageCreateInfo when {@code dstImage} was created</li>
            <li>{@code dstImage} <b>must</b> not have been created with {@code flags} containing #IMAGE_CREATE_SUBSAMPLED_BIT_EXT</li>
        </ul>

        <ul>
            <li>The image region specified by each element of {@code pRegions} <b>must</b> be contained within the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.x} and <code>({@code extent.width} + {@code dstOffset.x})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the width of the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.y} and <code>({@code extent.height} + {@code dstOffset.y})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the height of the specified {@code dstSubresource} of {@code dstImage}</li>
        </ul>

        <ul>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_1D, then for each element of {@code pRegions}, {@code dstOffset.y} <b>must</b> be 0 and {@code extent.height} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.z} and <code>({@code extent.depth} + {@code dstOffset.z})</code> <b>must</b> both be greater than or equal to 0 and less than or equal to the depth of the specified {@code dstSubresource} of {@code dstImage}</li>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_1D or #IMAGE_TYPE_2D, then for each element of {@code pRegions}, {@code dstOffset.z} <b>must</b> be 0 and {@code extent.depth} <b>must</b> be 1</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.x} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.y} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstOffset.z} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.x} and {@code extent.width} does not equal the width of the subresource specified by {@code srcSubresource}, {@code extent.width} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent width</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.y} and {@code extent.height} does not equal the height of the subresource specified by {@code srcSubresource}, {@code extent.height} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent height</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, if the sum of {@code dstOffset.z} and {@code extent.depth} does not equal the depth of the subresource specified by {@code srcSubresource}, {@code extent.depth} <b>must</b> be a multiple of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent depth</a> of the {@code VkFormat} of {@code dstImage}</li>
            <li>For each element of {@code pRegions}, {@code dstSubresource.aspectMask} <b>must</b> specify aspects present in {@code dstImage}</li>
            <li>If {@code dstImage} has a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-requiring-sampler-ycbcr-conversion">multi-planar image format</a>, then for each element of {@code pRegions}, {@code dstSubresource.aspectMask} <b>must</b> be a single valid <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-planes-image-aspect">multi-planar aspect mask</a> bit</li>
            <li>If {@code dstImage} is of type #IMAGE_TYPE_3D, for each element of {@code pRegions}, {@code dstSubresource.baseArrayLayer} <b>must</b> be 0 and {@code dstSubresource.layerCount} <b>must</b> be 1</li>
            <li>{@code srcImageLayout} <b>must</b> specify the current layout of the image subresources of {@code srcImage} specified in {@code pRegions}</li>
            <li>{@code dstImageLayout} <b>must</b> specify the current layout of the image subresources of {@code dstImage} specified in {@code pRegions}</li>
            <li>{@code srcImageLayout} <b>must</b> be one of the image layouts returned in ##VkPhysicalDeviceHostImageCopyPropertiesEXT{@code ::pCopySrcLayouts}</li>
            <li>{@code dstImageLayout} <b>must</b> be one of the image layouts returned in ##VkPhysicalDeviceHostImageCopyPropertiesEXT{@code ::pCopyDstLayouts}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkHostImageCopyFlagBitsEXT} values</li>
            <li>{@code srcImage} <b>must</b> be a valid {@code VkImage} handle</li>
            <li>{@code srcImageLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
            <li>{@code dstImage} <b>must</b> be a valid {@code VkImage} handle</li>
            <li>{@code dstImageLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
            <li>{@code pRegions} <b>must</b> be a valid pointer to an array of {@code regionCount} valid ##VkImageCopy2 structures</li>
            <li>{@code regionCount} <b>must</b> be greater than 0</li>
            <li>Both of {@code dstImage}, and {@code srcImage} <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkImageCopy2, #CopyImageToImageEXT()
        """

    Expression("#STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkHostImageCopyFlagsEXT("flags", "a bitmask of {@code VkHostImageCopyFlagBitsEXT} values describing additional copy parameters.")
    VkImage("srcImage", "the source image.")
    VkImageLayout("srcImageLayout", "the layout of the source image subresources for the copy.")
    VkImage("dstImage", "the destination image.")
    VkImageLayout("dstImageLayout", "the layout of the destination image subresources for the copy.")
    AutoSize("pRegions")..uint32_t("regionCount", "the number of regions to copy.")
    VkImageCopy2.const.p("pRegions", "a pointer to an array of ##VkImageCopy2 structures specifying the regions to copy.")
}

val VkHostImageLayoutTransitionInfoEXT = struct(Module.VULKAN, "VkHostImageLayoutTransitionInfoEXT") {
    documentation =
        """
        Structure specifying the parameters of a host-side image layout transition.

        <h5>Description</h5>
        {@code vkTransitionImageLayoutEXT} does not check whether the device memory associated with an image is currently in use before performing the layout transition. The application <b>must</b> guarantee that any previously submitted command that reads from or writes to this subresource has completed before the host performs the layout transition.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Image layout transitions performed on the host do not require queue family ownership transfers as the physical layout of the image will not vary between queue families for the layouts supported by this function.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code image} <b>must</b> have been created with #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT</li>
        </ul>

        <ul>
            <li>{@code subresourceRange.baseMipLevel} <b>must</b> be less than the {@code mipLevels} specified in ##VkImageCreateInfo when {@code image} was created</li>
            <li>If {@code subresourceRange.levelCount} is not #REMAINING_MIP_LEVELS, <code>subresourceRange.baseMipLevel + subresourceRange.levelCount</code> <b>must</b> be less than or equal to the {@code mipLevels} specified in ##VkImageCreateInfo when {@code image} was created</li>
            <li>{@code subresourceRange.baseArrayLayer} <b>must</b> be less than the {@code arrayLayers} specified in ##VkImageCreateInfo when {@code image} was created</li>
            <li>If {@code subresourceRange.layerCount} is not #REMAINING_ARRAY_LAYERS, <code>subresourceRange.baseArrayLayer + subresourceRange.layerCount</code> <b>must</b> be less than or equal to the {@code arrayLayers} specified in ##VkImageCreateInfo when {@code image} was created</li>
            <li>If {@code image} is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>If {@code image} has a color format that is single-plane, then the {@code aspectMask} member of {@code subresourceRange} <b>must</b> be #IMAGE_ASPECT_COLOR_BIT</li>
            <li>If {@code image} has a color format and is not <em>disjoint</em>, then the {@code aspectMask} member of {@code subresourceRange} <b>must</b> be #IMAGE_ASPECT_COLOR_BIT</li>
            <li>If {@code image} has a multi-planar format and the image is <em>disjoint</em>, then the {@code aspectMask} member of {@code subresourceRange} <b>must</b> include at least one <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-planes-image-aspect">multi-planar aspect mask</a> bit or #IMAGE_ASPECT_COLOR_BIT</li>
            <li>If {@code image} has a depth/stencil format with both depth and stencil and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-separateDepthStencilLayouts">{@code separateDepthStencilLayouts}</a> feature is enabled, then the {@code aspectMask} member of {@code subresourceRange} <b>must</b> include either or both #IMAGE_ASPECT_DEPTH_BIT and #IMAGE_ASPECT_STENCIL_BIT</li>
            <li>If {@code image} has a depth/stencil format with both depth and stencil and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-separateDepthStencilLayouts">{@code separateDepthStencilLayouts}</a> feature is not enabled, then the {@code aspectMask} member of {@code subresourceRange} <b>must</b> include both #IMAGE_ASPECT_DEPTH_BIT and #IMAGE_ASPECT_STENCIL_BIT</li>
            <li>If the {@code aspectMask} member of {@code subresourceRange} includes #IMAGE_ASPECT_DEPTH_BIT, {@code oldLayout} and {@code newLayout} <b>must</b> not be one of #IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or #IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL</li>
            <li>If the {@code aspectMask} member of {@code subresourceRange} includes #IMAGE_ASPECT_STENCIL_BIT, {@code oldLayout} and {@code newLayout} <b>must</b> not be one of #IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or #IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL</li>
            <li>{@code oldLayout} <b>must</b> be either #IMAGE_LAYOUT_UNDEFINED or the current layout of the image subresources as specified in {@code subresourceRange}</li>
            <li>If {@code oldLayout} is not #IMAGE_LAYOUT_UNDEFINED or #IMAGE_LAYOUT_PREINITIALIZED, it <b>must</b> be one of the layouts in ##VkPhysicalDeviceHostImageCopyPropertiesEXT{@code ::pCopySrcLayouts}</li>
            <li>{@code newLayout} <b>must</b> be one of the layouts in ##VkPhysicalDeviceHostImageCopyPropertiesEXT{@code ::pCopyDstLayouts}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code image} <b>must</b> be a valid {@code VkImage} handle</li>
            <li>{@code oldLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
            <li>{@code newLayout} <b>must</b> be a valid {@code VkImageLayout} value</li>
            <li>{@code subresourceRange} <b>must</b> be a valid ##VkImageSubresourceRange structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkImageSubresourceRange, #TransitionImageLayoutEXT()
        """

    Expression("#STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImage("image", "a handle to the image affected by this layout transition.")
    VkImageLayout("oldLayout", "the old layout in an <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#synchronization-image-layout-transitions\">image layout transition</a>.")
    VkImageLayout("newLayout", "the new layout in an <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#synchronization-image-layout-transitions\">image layout transition</a>.")
    VkImageSubresourceRange("subresourceRange", "describes the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#resources-image-views\">image subresource range</a> within {@code image} that is affected by this layout transition.")
}

val VkSubresourceHostMemcpySizeEXT = struct(Module.VULKAN, "VkSubresourceHostMemcpySizeEXT", mutable = false) {
    documentation =
        """
        Memory size needed to copy to or from an image on the host with VK_HOST_IMAGE_COPY_MEMCPY_EXT.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDeviceSize("size", "the size in bytes of the image subresource.")
}

val VkHostImageCopyDevicePerformanceQueryEXT = struct(Module.VULKAN, "VkHostImageCopyDevicePerformanceQueryEXT", mutable = false) {
    documentation =
        """
        Struct containing information about optimality of device access.

        <h5>Description</h5>
        The implementation <b>may</b> return #FALSE in {@code optimalDeviceAccess} if {@code identicalMemoryLayout} is #FALSE. If {@code identicalMemoryLayout} is #TRUE, {@code optimalDeviceAccess} <b>must</b> be #TRUE.

        The implementation <b>may</b> return #TRUE in {@code optimalDeviceAccess} while {@code identicalMemoryLayout} is #FALSE. In this situation, any device performance impact <b>should</b> not be measurable.

        If ##VkPhysicalDeviceImageFormatInfo2{@code ::format} is a block-compressed format and #GetPhysicalDeviceImageFormatProperties2() returns #SUCCESS, the implementation <b>must</b> return #TRUE in {@code optimalDeviceAccess}.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Applications can make use of {@code optimalDeviceAccess} to determine their resource copying strategy. If a resource is expected to be accessed more on device than on the host, and the implementation considers the resource sub-optimally accessed, it is likely better to use device copies instead.
        </div>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Layout not being identical yet still considered optimal for device access could happen if the implementation has different memory layout patterns, some of which are easier to access on the host.
        </div>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The most practical reason for {@code optimalDeviceAccess} to be #FALSE is that host image access may disable framebuffer compression where it would otherwise have been enabled. This represents far more efficient host image access since no compression algorithm is required to read or write to the image, but it would impact device access performance. Some implementations may only set {@code optimalDeviceAccess} to #FALSE if certain conditions are met, such as specific image usage flags or creation flags.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("optimalDeviceAccess", "returns #TRUE if use of host image copy has no adverse effect on device access performance, compared to an image that is created with exact same creation parameters, and bound to the same {@code VkDeviceMemory}, except that #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT is replaced with #IMAGE_USAGE_TRANSFER_SRC_BIT and #IMAGE_USAGE_TRANSFER_DST_BIT.")
    VkBool32("identicalMemoryLayout", "returns #TRUE if use of host image copy has no impact on memory layout compared to an image that is created with exact same creation parameters, and bound to the same {@code VkDeviceMemory}, except that #IMAGE_USAGE_HOST_TRANSFER_BIT_EXT is replaced with #IMAGE_USAGE_TRANSFER_SRC_BIT and #IMAGE_USAGE_TRANSFER_DST_BIT.")
}

val _VkSubresourceLayout2KHR = struct(Module.VULKAN, "VkSubresourceLayout2KHR")
val VkSubresourceLayout2EXT = struct(Module.VULKAN, "VkSubresourceLayout2EXT", mutable = false, alias = _VkSubresourceLayout2KHR) {
    documentation = "See ##VkSubresourceLayout2KHR."

    Expression("#STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkSubresourceLayout("subresourceLayout", "")
}

val _VkImageSubresource2KHR = struct(Module.VULKAN, "VkImageSubresource2KHR")
val VkImageSubresource2EXT = struct(Module.VULKAN, "VkImageSubresource2EXT", alias = _VkImageSubresource2KHR) {
    documentation = "See ##VkImageSubresource2KHR."

    Expression("#STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkImageSubresource("imageSubresource", "")
}

val VkImageSubresource2KHR = struct(Module.VULKAN, "VkImageSubresource2KHR") {
    documentation =
        """
        Structure specifying an image subresource.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code imageSubresource} <b>must</b> be a valid ##VkImageSubresource structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceImageSubresourceInfoKHR, ##VkImageSubresource, #GetImageSubresourceLayout2EXT(), #GetImageSubresourceLayout2KHR()
        """

    Expression("#STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageSubresource("imageSubresource", "a ##VkImageSubresource structure.")
}

val VkSubresourceLayout2KHR = struct(Module.VULKAN, "VkSubresourceLayout2KHR", mutable = false) {
    documentation =
        """
        Structure specifying subresource layout.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkImageCompressionPropertiesEXT or ##VkSubresourceHostMemcpySizeEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        ##VkSubresourceLayout, #GetDeviceImageSubresourceLayoutKHR(), #GetImageSubresourceLayout2EXT(), #GetImageSubresourceLayout2KHR()
        """

    Expression("#STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    PointerSetter(
        "VkImageCompressionPropertiesEXT", "VkSubresourceHostMemcpySizeEXT",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkSubresourceLayout("subresourceLayout", "a ##VkSubresourceLayout structure.")
}

val VkMemoryMapInfoKHR = struct(Module.VULKAN, "VkMemoryMapInfoKHR") {
    documentation =
        """
        Structure containing parameters of a memory map operation.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code memory} <b>must</b> not be currently host mapped</li>
            <li>{@code offset} <b>must</b> be less than the size of {@code memory}</li>
            <li>If {@code size} is not equal to #WHOLE_SIZE, {@code size} <b>must</b> be greater than 0</li>
            <li>If {@code size} is not equal to #WHOLE_SIZE, {@code size} <b>must</b> be less than or equal to the size of the {@code memory} minus {@code offset}</li>
            <li>{@code memory} <b>must</b> have been created with a memory type that reports #MEMORY_PROPERTY_HOST_VISIBLE_BIT</li>
            <li>{@code memory} <b>must</b> not have been allocated with multiple instances</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code memory} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #MapMemory2KHR()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMemoryMapFlags("flags", "reserved for future use.")
    VkDeviceMemory("memory", "the {@code VkDeviceMemory} object to be mapped.")
    VkDeviceSize("offset", "a zero-based byte offset from the beginning of the memory object.")
    VkDeviceSize("size", "the size of the memory range to map, or #WHOLE_SIZE to map from {@code offset} to the end of the allocation.")
}

val VkMemoryUnmapInfoKHR = struct(Module.VULKAN, "VkMemoryUnmapInfoKHR") {
    documentation =
        """
        Structure containing parameters of a memory unmap operation.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code memory} <b>must</b> be currently host mapped</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code memory} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #UnmapMemory2KHR()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMemoryUnmapFlagsKHR("flags", "reserved for future use.")
    VkDeviceMemory("memory", "the {@code VkDeviceMemory} object to be unmapped.")
}

val VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT") {
    documentation =
        """
        Structure describing features supported by VK_EXT_shader_atomic_float2.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderBufferFloat16Atomics", "indicates whether shaders <b>can</b> perform 16-bit floating-point load, store, and exchange atomic operations on storage buffers.")
    VkBool32("shaderBufferFloat16AtomicAdd", "indicates whether shaders <b>can</b> perform 16-bit floating-point add atomic operations on storage buffers.")
    VkBool32("shaderBufferFloat16AtomicMinMax", "indicates whether shaders <b>can</b> perform 16-bit floating-point min and max atomic operations on storage buffers.")
    VkBool32("shaderBufferFloat32AtomicMinMax", "indicates whether shaders <b>can</b> perform 32-bit floating-point min and max atomic operations on storage buffers.")
    VkBool32("shaderBufferFloat64AtomicMinMax", "indicates whether shaders <b>can</b> perform 64-bit floating-point min and max atomic operations on storage buffers.")
    VkBool32("shaderSharedFloat16Atomics", "indicates whether shaders <b>can</b> perform 16-bit floating-point load, store and exchange atomic operations on shared and payload memory.")
    VkBool32("shaderSharedFloat16AtomicAdd", "indicates whether shaders <b>can</b> perform 16-bit floating-point add atomic operations on shared and payload memory.")
    VkBool32("shaderSharedFloat16AtomicMinMax", "indicates whether shaders <b>can</b> perform 16-bit floating-point min and max atomic operations on shared and payload memory.")
    VkBool32("shaderSharedFloat32AtomicMinMax", "indicates whether shaders <b>can</b> perform 32-bit floating-point min and max atomic operations on shared and payload memory.")
    VkBool32("shaderSharedFloat64AtomicMinMax", "indicates whether shaders <b>can</b> perform 64-bit floating-point min and max atomic operations on shared and payload memory.")
    VkBool32("shaderImageFloat32AtomicMinMax", "indicates whether shaders <b>can</b> perform 32-bit floating-point min and max atomic image operations.")
    VkBool32("sparseImageFloat32AtomicMinMax", "indicates whether 32-bit floating-point min and max atomic operations <b>can</b> be used on sparse images.")
}

val VkSurfacePresentModeEXT = struct(Module.VULKAN, "VkSurfacePresentModeEXT") {
    documentation =
        """
        Structure describing present mode of a surface.

        <h5>Description</h5>
        If the ##VkSurfacePresentModeEXT structure is included in the {@code pNext} chain of ##VkPhysicalDeviceSurfaceInfo2KHR, the values returned in ##VkSurfaceCapabilitiesKHR{@code ::minImageCount}, ##VkSurfaceCapabilitiesKHR{@code ::maxImageCount}, ##VkSurfacePresentScalingCapabilitiesEXT{@code ::minScaledImageExtent}, and ##VkSurfacePresentScalingCapabilitiesEXT{@code ::maxScaledImageExtent} are valid only for the specified {@code presentMode}. If {@code presentMode} is #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, the per-present mode image counts <b>must</b> both be one. The per-present mode image counts <b>may</b> be less-than or greater-than the image counts returned when ##VkSurfacePresentModeEXT is not provided.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        If ##VkSwapchainPresentModesCreateInfoEXT is provided to swapchain creation, the requirements for forward progress may be less strict. For example, a FIFO swapchain might only require 2 images to guarantee forward progress, but a MAILBOX one might require 4. Without the per-present image counts, such an implementation would have to return 4 in ##VkSurfaceCapabilitiesKHR{@code ::minImageCount}, which pessimizes FIFO. Conversely, an implementation may return a low number for minImageCount, but internally bump the image count when application queries #GetSwapchainImagesKHR(), which can surprise applications, and is not discoverable until swapchain creation. Using ##VkSurfacePresentModeEXT and ##VkSwapchainPresentModesCreateInfoEXT together effectively removes this problem.

        ##VkSwapchainPresentModesCreateInfoEXT is required for the specification to be backwards compatible with applications that do not know about, or make use of this feature.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code presentMode} <b>must</b> be a value reported by #GetPhysicalDeviceSurfacePresentModesKHR() for the specified surface.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT</li>
            <li>{@code presentMode} <b>must</b> be a valid {@code VkPresentModeKHR} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPresentModeKHR("presentMode", "the presentation mode the swapchain will use.")
}

val VkSurfacePresentScalingCapabilitiesEXT = struct(Module.VULKAN, "VkSurfacePresentScalingCapabilitiesEXT") {
    documentation =
        """
        Structure describing the presentation scaling capabilities of the surface.

        <h5>Description</h5>
        Before creating a swapchain whose scaling mode <b>can</b> be specified through the use of ##VkSwapchainPresentScalingCreateInfoEXT, obtain the set of supported scaling modes by including a ##VkSurfacePresentModeEXT structure in the {@code pNext} chain of ##VkPhysicalDeviceSurfaceInfo2KHR when calling #GetPhysicalDeviceSurfaceCapabilities2KHR(). The implementation <b>must</b> return the same values in ##VkSurfacePresentScalingCapabilitiesEXT for any of the compatible present modes as obtained through ##VkSurfacePresentModeCompatibilityEXT.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT</li>
            <li>{@code supportedPresentScaling} <b>must</b> be a valid combination of {@code VkPresentScalingFlagBitsEXT} values</li>
            <li>{@code supportedPresentGravityX} <b>must</b> be a valid combination of {@code VkPresentGravityFlagBitsEXT} values</li>
            <li>{@code supportedPresentGravityY} <b>must</b> be a valid combination of {@code VkPresentGravityFlagBitsEXT} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPresentScalingFlagsEXT("supportedPresentScaling", "a bitmask of {@code VkPresentScalingFlagBitsEXT} representing the scaling methods supported by the surface, or 0 if application-defined scaling is not supported.")
    VkPresentGravityFlagsEXT("supportedPresentGravityX", "a bitmask of {@code VkPresentGravityFlagBitsEXT} representing the X-axis pixel gravity supported by the surface, or 0 if Vulkan-defined pixel gravity is not supported for the X axis.")
    VkPresentGravityFlagsEXT("supportedPresentGravityY", "a bitmask of {@code VkPresentGravityFlagBitsEXT} representing the Y-axis pixel gravity supported by the surface, or 0 if Vulkan-defined pixel gravity is not supported for the Y axis.")
    VkExtent2D("minScaledImageExtent", "contains the smallest valid swapchain extent for the surface on the specified device when one of the scaling methods specified in {@code supportedPresentScaling} is used, or the special value <code>(0xFFFFFFFF, 0xFFFFFFFF)</code> indicating that the surface size will be determined by the extent of a swapchain targeting the surface. The {@code width} and {@code height} of the extent will each be smaller than or equal to the corresponding {@code width} and {@code height} of ##VkSurfaceCapabilitiesKHR{@code ::minImageExtent}.")
    VkExtent2D("maxScaledImageExtent", "contains the largest valid swapchain extent for the surface on the specified device when one of the scaling methods specified in {@code supportedPresentScaling} is used, or the special value described above for {@code minScaledImageExtent}. The {@code width} and {@code height} of the extent will each be greater than or equal to the corresponding {@code width} and {@code height} of ##VkSurfaceCapabilitiesKHR{@code ::maxImageExtent}.")
}

val VkSurfacePresentModeCompatibilityEXT = struct(Module.VULKAN, "VkSurfacePresentModeCompatibilityEXT") {
    documentation =
        """
        Structure describing the subset of compatible presentation modes for the purposes of switching without swapchain recreation.

        <h5>Description</h5>
        If {@code pPresentModes} is {@code NULL}, then the number of present modes that are compatible with the one specified in ##VkSurfacePresentModeEXT is returned in {@code presentModeCount}. Otherwise, {@code presentModeCount} must be set by the user to the number of elements in the {@code pPresentModes} array, and on return the variable is overwritten with the number of values actually written to {@code pPresentModes}. If the value of {@code presentModeCount} is less than the number of compatible present modes that are supported, at most {@code presentModeCount} values will be written to {@code pPresentModes}. The implementation <b>must</b> include the present mode passed to ##VkSurfacePresentModeEXT in {@code pPresentModes}, unless {@code presentModeCount} is zero.

        Before creating a swapchain whose present modes <b>can</b> be modified through the use of ##VkSwapchainPresentModesCreateInfoEXT, obtain the set of present modes compatible with a given initial present mode by including a ##VkSurfacePresentModeEXT structure in the {@code pNext} chain of ##VkPhysicalDeviceSurfaceInfo2KHR when calling #GetPhysicalDeviceSurfaceCapabilities2KHR().

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT</li>
            <li>If {@code presentModeCount} is not 0, and {@code pPresentModes} is not {@code NULL}, {@code pPresentModes} <b>must</b> be a valid pointer to an array of {@code presentModeCount} {@code VkPresentModeKHR} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pPresentModes", optional = true)..uint32_t("presentModeCount", "an integer related to the number of present modes available or queried, as described below.")
    nullable..VkPresentModeKHR.p("pPresentModes", "a pointer to an array of {@code VkPresentModeKHR} in which present modes compatible with a given present mode are returned.")
}

val VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT") {
    documentation =
        """
        Structure describing whether implementation supports swapchain maintenance1 functionality.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("swapchainMaintenance1", """indicates that the implementation supports the following:

        <ul>
            <li>##VkSwapchainPresentFenceInfoEXT, specifying a fence that is signaled when the resources associated with a present operation <b>can</b> be safely destroyed.</li>
            <li>##VkSwapchainPresentModesCreateInfoEXT and ##VkSwapchainPresentModeInfoEXT, allowing the swapchain to switch present modes without a need for recreation.</li>
            <li>##VkSwapchainPresentScalingCreateInfoEXT, specifying the scaling behavior of the swapchain in presence of window resizing.</li>
            <li>The #SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT flag, allowing the implementation to defer the allocation of swapchain image memory until first acquisition.</li>
            <li>#ReleaseSwapchainImagesEXT(), allowing acquired swapchain images to be released without presenting them.</li>
        </ul>""")
}

val VkSwapchainPresentFenceInfoEXT = struct(Module.VULKAN, "VkSwapchainPresentFenceInfoEXT") {
    documentation =
        """
        Fences associated with a vkQueuePresentKHR operation.

        <h5>Description</h5>
        The set of <em>queue operations</em> defined by queuing an image for presentation, as well as operations performed by the presentation engine access the payloads of objects associated with the presentation operation. The associated objects include:

        <ul>
            <li>The swapchain image, its implicitly bound memory, and any other resources bound to that memory.</li>
            <li>The wait semaphores specified when queuing the image for presentation.</li>
        </ul>

        The application <b>can</b> provide a fence that the implementation will signal when all such queue operations have completed and the presentation engine has taken a reference to the payload of any objects it accesses as part of the present operation. For all binary wait semaphores imported by the presentation engine using the equivalent of reference transference, as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-semaphores-importing">Importing Semaphore Payloads</a>, this fence <b>must</b> not signal until all such semaphore payloads have been reset by the presentation engine.

        The application <b>can</b> destroy the wait semaphores associated with a given presentation operation when at least one of the associated fences is signaled, and <b>can</b> destroy the swapchain when the fences associated with all past presentation requests referring to that swapchain have signaled.

        Fences associated with presentations to the same swapchain on the same {@code VkQueue} <b>must</b> be signaled in the same order as the present operations.

        To specify a fence for each swapchain in a present operation, include the ##VkSwapchainPresentFenceInfoEXT structure in the {@code pNext} chain of the ##VkPresentInfoKHR structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code swapchainCount} <b>must</b> be equal to ##VkPresentInfoKHR{@code ::swapchainCount}</li>
            <li>Each element of {@code pFences} <b>must</b> be unsignaled</li>
            <li>Each element of {@code pFences} <b>must</b> not be associated with any other queue command that has not yet completed execution on that queue</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT</li>
            <li>{@code pFences} <b>must</b> be a valid pointer to an array of {@code swapchainCount} valid {@code VkFence} handles</li>
            <li>{@code swapchainCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pFences")..uint32_t("swapchainCount", "the number of swapchains being presented to by this command.")
    VkFence.const.p("pFences", "a list of fences with {@code swapchainCount} entries. Each entry <b>must</b> be #NULL_HANDLE or the handle of a fence to signal when the relevant operations on the associated swapchain have completed.")
}

val VkSwapchainPresentModesCreateInfoEXT = struct(Module.VULKAN, "VkSwapchainPresentModesCreateInfoEXT") {
    documentation =
        """
        All presentation modes usable by the swapchain.

        <h5>Valid Usage</h5>
        <ul>
            <li>Each entry in pPresentModes <b>must</b> be one of the {@code VkPresentModeKHR} values returned by {@code vkGetPhysicalDeviceSurfacePresentModesKHR} for the surface</li>
            <li>The entries in pPresentModes <b>must</b> be a subset of the present modes returned in ##VkSurfacePresentModeCompatibilityEXT{@code ::pPresentModes}, given ##VkSwapchainCreateInfoKHR{@code ::presentMode} in ##VkSurfacePresentModeEXT</li>
            <li>##VkSwapchainCreateInfoKHR{@code ::presentMode} <b>must</b> be included in {@code pPresentModes}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT</li>
            <li>{@code pPresentModes} <b>must</b> be a valid pointer to an array of {@code presentModeCount} valid {@code VkPresentModeKHR} values</li>
            <li>{@code presentModeCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pPresentModes")..uint32_t("presentModeCount", "the number of presentation modes provided.")
    VkPresentModeKHR.const.p("pPresentModes", "a list of presentation modes with {@code presentModeCount} entries")
}

val VkSwapchainPresentModeInfoEXT = struct(Module.VULKAN, "VkSwapchainPresentModeInfoEXT") {
    documentation =
        """
        Presentation modes for a vkQueuePresentKHR operation.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkPresentInfoKHR includes a ##VkSwapchainPresentModeInfoEXT structure, then that structure defines the presentation modes used for the current and subsequent presentation operations.

        When the application changes present modes with ##VkSwapchainPresentModeInfoEXT, images that have already been queued for presentation will continue to be presented according to the previous present mode. The current image being queued for presentation and subsequent images will be presented according to the new present mode. The behavior during the transition between the two modes is defined as follows.

        <ul>
            <li>Transition from #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR to #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR: the presentation engine updates the shared presentable image according to the behavior of #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR.</li>
            <li>Transition from #PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR to #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR: the presentation engine <b>may</b> update the shared presentable image or defer that to its regular refresh cycle, according to the behavior of #PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR.</li>
            <li>Transition between #PRESENT_MODE_FIFO_KHR and #PRESENT_MODE_FIFO_RELAXED_KHR: Images continue to be appended to the same FIFO queue, and the behavior with respect to waiting for vertical blanking period will follow the new mode for current and subsequent images.</li>
            <li>Transition from #PRESENT_MODE_IMMEDIATE_KHR to #PRESENT_MODE_FIFO_KHR or #PRESENT_MODE_FIFO_RELAXED_KHR: As all prior present requests in the #PRESENT_MODE_IMMEDIATE_KHR mode are applied immediately, there are no outstanding present operations in this mode, and current and subsequent images are appended to the FIFO queue and presented according to the new mode.</li>
            <li>Transition from #PRESENT_MODE_MAILBOX_KHR to #PRESENT_MODE_FIFO_KHR or #PRESENT_MODE_FIFO_RELAXED_KHR: Presentation in both modes require waiting for the next vertical blanking period, with #PRESENT_MODE_MAILBOX_KHR allowing the pending present operation to be replaced by a new one. In this case, the current present operation will replace the pending present operation and is applied according to the new mode.</li>
            <li>Transition from #PRESENT_MODE_FIFO_KHR or #PRESENT_MODE_FIFO_RELAXED_KHR to #PRESENT_MODE_IMMEDIATE_KHR or #PRESENT_MODE_MAILBOX_KHR: If the FIFO queue is empty, presentation is done according to the behavior of the new mode. If there are present operations in the FIFO queue, once the last present operation is performed based on the respective vertical blanking period, the current and subsequent updates are applied according to the new mode.</li>
            <li>The behavior during transition between any other present modes, if possible, is implementation defined.</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code swapchainCount} <b>must</b> be equal to ##VkPresentInfoKHR{@code ::swapchainCount}</li>
            <li>Each entry in {@code pPresentModes} must be a presentation mode specified in ##VkSwapchainPresentModesCreateInfoEXT{@code ::pPresentModes} when creating the entry’s corresponding swapchain</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT</li>
            <li>{@code pPresentModes} <b>must</b> be a valid pointer to an array of {@code swapchainCount} valid {@code VkPresentModeKHR} values</li>
            <li>{@code swapchainCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pPresentModes")..uint32_t("swapchainCount", "the number of swapchains being presented to by this command.")
    VkPresentModeKHR.const.p("pPresentModes", "a list of presentation modes with {@code swapchainCount} entries.")
}

val VkSwapchainPresentScalingCreateInfoEXT = struct(Module.VULKAN, "VkSwapchainPresentScalingCreateInfoEXT") {
    documentation =
        """
        Scaling behavior when presenting to the surface.

        <h5>Description</h5>
        If {@code scalingBehavior} is 0, the result of presenting a swapchain image with dimensions that do not match the surface dimensions is implementation and platform-dependent. If {@code presentGravityX} or {@code presentGravityY} are 0, the presentation gravity <b>must</b> match that defined by the native platform surface on platforms which define surface gravity.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code presentGravityX} is 0, {@code presentGravityY} <b>must</b> be 0</li>
            <li>If {@code presentGravityX} is not 0, {@code presentGravityY} <b>must</b> not be 0</li>
            <li>{@code scalingBehavior} <b>must</b> not have more than one bit set</li>
            <li>{@code presentGravityX} <b>must</b> not have more than one bit set</li>
            <li>{@code presentGravityY} <b>must</b> not have more than one bit set</li>
            <li>{@code scalingBehavior} <b>must</b> be a valid scaling method for the surface as returned in ##VkSurfacePresentScalingCapabilitiesEXT{@code ::supportedPresentScaling}, given ##VkSwapchainCreateInfoKHR{@code ::presentMode} in ##VkSurfacePresentModeEXT</li>
            <li>If the swapchain is created with ##VkSwapchainPresentModesCreateInfoEXT, {@code scalingBehavior} <b>must</b> be a valid scaling method for the surface as returned in ##VkSurfacePresentScalingCapabilitiesEXT{@code ::supportedPresentScaling}, given each present mode in ##VkSwapchainPresentModesCreateInfoEXT{@code ::pPresentModes} in ##VkSurfacePresentModeEXT</li>
            <li>{@code presentGravityX} <b>must</b> be a valid x-axis present gravity for the surface as returned in ##VkSurfacePresentScalingCapabilitiesEXT{@code ::supportedPresentGravityX}, given ##VkSwapchainCreateInfoKHR{@code ::presentMode} in ##VkSurfacePresentModeEXT</li>
            <li>If the swapchain is created with ##VkSwapchainPresentModesCreateInfoEXT, {@code presentGravityX} <b>must</b> be a valid x-axis present gravity for the surface as returned in ##VkSurfacePresentScalingCapabilitiesEXT{@code ::supportedPresentGravityX}, given each present mode in ##VkSwapchainPresentModesCreateInfoEXT{@code ::pPresentModes} in ##VkSurfacePresentModeEXT</li>
            <li>{@code presentGravityY} <b>must</b> be a valid y-axis present gravity for the surface as returned in ##VkSurfacePresentScalingCapabilitiesEXT{@code ::supportedPresentGravityY}, given ##VkSwapchainCreateInfoKHR{@code ::presentMode} in ##VkSurfacePresentModeEXT</li>
            <li>If the swapchain is created with ##VkSwapchainPresentModesCreateInfoEXT, {@code presentGravityY} <b>must</b> be a valid y-axis present gravity for the surface as returned in ##VkSurfacePresentScalingCapabilitiesEXT{@code ::supportedPresentGravityY}, given each present mode in ##VkSwapchainPresentModesCreateInfoEXT{@code ::pPresentModes} in ##VkSurfacePresentModeEXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT</li>
            <li>{@code scalingBehavior} <b>must</b> be a valid combination of {@code VkPresentScalingFlagBitsEXT} values</li>
            <li>{@code presentGravityX} <b>must</b> be a valid combination of {@code VkPresentGravityFlagBitsEXT} values</li>
            <li>{@code presentGravityY} <b>must</b> be a valid combination of {@code VkPresentGravityFlagBitsEXT} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPresentScalingFlagsEXT("scalingBehavior", "0 or the scaling method to use when the dimensions of the surface and swapchain images differ.")
    VkPresentGravityFlagsEXT("presentGravityX", "0 or the x-axis direction in which swapchain image pixels gravitate relative to the surface when {@code scalingBehavior} does not result in a one-to-one pixel mapping between the scaled swapchain image and the surface.")
    VkPresentGravityFlagsEXT("presentGravityY", "0 or the y-axis direction in which swapchain image pixels gravitate relative to the surface when {@code scalingBehavior} does not result in a one-to-one pixel mapping between the scaled swapchain image and the surface.")
}

val VkReleaseSwapchainImagesInfoEXT = struct(Module.VULKAN, "VkReleaseSwapchainImagesInfoEXT") {
    documentation =
        """
        Structure describing a list of swapchain image indices to be released.

        <h5>Valid Usage</h5>
        <ul>
            <li>Each element of {@code pImageIndices} <b>must</b> be the index of a presentable image acquired from the swapchain specified by {@code swapchain}</li>
            <li>All uses of presentable images identified by elements of {@code pImageIndices} <b>must</b> have completed execution</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code swapchain} <b>must</b> be a valid {@code VkSwapchainKHR} handle</li>
            <li>{@code pImageIndices} <b>must</b> be a valid pointer to an array of {@code imageIndexCount} {@code uint32_t} values</li>
            <li>{@code imageIndexCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>Host Synchronization</h5>
        <ul>
            <li>Host access to {@code swapchain} <b>must</b> be externally synchronized</li>
        </ul>

        <h5>See Also</h5>
        #ReleaseSwapchainImagesEXT()
        """

    Expression("#STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSwapchainKHR("swapchain", "a swapchain to which images are being released.")
    AutoSize("pImageIndices")..uint32_t("imageIndexCount", "the number of image indices to be released.")
    uint32_t.const.p("pImageIndices", "a pointer to an array of indices into the array of {@code swapchain}’s presentable images, with {@code imageIndexCount} entries.")
}

val VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT", alias = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures) {
    documentation = "See ##VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderDemoteToHelperInvocation", "")
}

val VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing push descriptor limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxGraphicsShaderGroupCount", "the maximum number of shader groups in ##VkGraphicsPipelineShaderGroupsCreateInfoNV.")
    uint32_t("maxIndirectSequenceCount", "the maximum number of sequences in ##VkGeneratedCommandsInfoNV and in ##VkGeneratedCommandsMemoryRequirementsInfoNV.")
    uint32_t("maxIndirectCommandsTokenCount", "the maximum number of tokens in ##VkIndirectCommandsLayoutCreateInfoNV.")
    uint32_t("maxIndirectCommandsStreamCount", "the maximum number of streams in ##VkIndirectCommandsLayoutCreateInfoNV.")
    uint32_t("maxIndirectCommandsTokenOffset", "the maximum offset in ##VkIndirectCommandsLayoutTokenNV.")
    uint32_t("maxIndirectCommandsStreamStride", "the maximum stream stride in ##VkIndirectCommandsLayoutCreateInfoNV.")
    uint32_t("minSequencesCountBufferOffsetAlignment", "the minimum alignment for memory addresses which <b>can</b> be used in ##VkGeneratedCommandsInfoNV.")
    uint32_t("minSequencesIndexBufferOffsetAlignment", "the minimum alignment for memory addresses which <b>can</b> be used in ##VkGeneratedCommandsInfoNV.")
    uint32_t("minIndirectCommandsBufferOffsetAlignment", "the minimum alignment for memory addresses used in ##VkIndirectCommandsStreamNV, and as preprocess buffer in ##VkGeneratedCommandsInfoNV.")
}

val VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV") {
    documentation =
        """
        Structure describing the device-generated commands features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("deviceGeneratedCommands", "indicates whether the implementation supports functionality to generate commands on the device. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#device-generated-commands\">Device-Generated Commands</a>.")
}

val VkGraphicsShaderGroupCreateInfoNV = struct(Module.VULKAN, "VkGraphicsShaderGroupCreateInfoNV") {
    documentation =
        """
        Structure specifying override parameters for each shader group.

        <h5>Valid Usage</h5>
        <ul>
            <li>For {@code stageCount}, the same restrictions as in ##VkGraphicsPipelineCreateInfo{@code ::stageCount} apply</li>
            <li>For {@code pStages}, the same restrictions as in ##VkGraphicsPipelineCreateInfo{@code ::pStages} apply</li>
            <li>For {@code pVertexInputState}, the same restrictions as in ##VkGraphicsPipelineCreateInfo{@code ::pVertexInputState} apply</li>
            <li>For {@code pTessellationState}, the same restrictions as in ##VkGraphicsPipelineCreateInfo{@code ::pTessellationState} apply</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pStages} <b>must</b> be a valid pointer to an array of {@code stageCount} valid ##VkPipelineShaderStageCreateInfo structures</li>
            <li>{@code stageCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkGraphicsPipelineShaderGroupsCreateInfoNV, ##VkPipelineShaderStageCreateInfo, ##VkPipelineTessellationStateCreateInfo, ##VkPipelineVertexInputStateCreateInfo
        """

    Expression("#STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pStages")..uint32_t("stageCount", "the number of entries in the {@code pStages} array.")
    VkPipelineShaderStageCreateInfo.const.p("pStages", "a pointer to an array ##VkPipelineShaderStageCreateInfo structures specifying the set of the shader stages to be included in this shader group.")
    nullable..VkPipelineVertexInputStateCreateInfo.const.p("pVertexInputState", "a pointer to a ##VkPipelineVertexInputStateCreateInfo structure.")
    nullable..VkPipelineTessellationStateCreateInfo.const.p("pTessellationState", "a pointer to a ##VkPipelineTessellationStateCreateInfo structure, and is ignored if the shader group does not include a tessellation control shader stage and tessellation evaluation shader stage.")
}

val VkGraphicsPipelineShaderGroupsCreateInfoNV = struct(Module.VULKAN, "VkGraphicsPipelineShaderGroupsCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters of a newly created multi shader group pipeline.

        <h5>Description</h5>
        When referencing shader groups by index, groups defined in the referenced pipelines are treated as if they were defined as additional entries in {@code pGroups}. They are appended in the order they appear in the {@code pPipelines} array and in the {@code pGroups} array when those pipelines were defined.

        The application <b>must</b> maintain the lifetime of all such referenced pipelines based on the pipelines that make use of them.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code groupCount} <b>must</b> be at least 1 and as maximum ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxGraphicsShaderGroupCount}</li>
            <li>The sum of {@code groupCount} including those groups added from referenced {@code pPipelines} <b>must</b> also be as maximum ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxGraphicsShaderGroupCount}</li>
            <li>The state of the first element of {@code pGroups} <b>must</b> match its equivalent within the parent’s ##VkGraphicsPipelineCreateInfo</li>
            <li>Each element of {@code pGroups} <b>must</b> in combination with the rest of the pipeline state yield a valid state configuration</li>
            <li>All elements of {@code pGroups} <b>must</b> use the same shader stage combinations unless any mesh shader stage is used, then either combination of task and mesh or just mesh shader is valid</li>
            <li>Mesh and regular primitive shading stages cannot be mixed across {@code pGroups}</li>
            <li>Each element of {@code pPipelines} <b>must</b> have been created with identical state to the pipeline currently created except the state that can be overridden by ##VkGraphicsShaderGroupCreateInfoNV</li>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-deviceGeneratedCommands">{@code deviceGeneratedCommands}</a> feature <b>must</b> be enabled</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV</li>
            <li>If {@code groupCount} is not 0, {@code pGroups} <b>must</b> be a valid pointer to an array of {@code groupCount} valid ##VkGraphicsShaderGroupCreateInfoNV structures</li>
            <li>If {@code pipelineCount} is not 0, {@code pPipelines} <b>must</b> be a valid pointer to an array of {@code pipelineCount} valid {@code VkPipeline} handles</li>
        </ul>

        <h5>See Also</h5>
        ##VkGraphicsShaderGroupCreateInfoNV
        """

    Expression("#STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pGroups", optional = true)..uint32_t("groupCount", "the number of elements in the {@code pGroups} array.")
    VkGraphicsShaderGroupCreateInfoNV.const.p("pGroups", "a pointer to an array of ##VkGraphicsShaderGroupCreateInfoNV structures specifying which state of the original ##VkGraphicsPipelineCreateInfo each shader group overrides.")
    AutoSize("pPipelines", optional = true)..uint32_t("pipelineCount", "the number of elements in the {@code pPipelines} array.")
    VkPipeline.const.p("pPipelines", "a pointer to an array of graphics {@code VkPipeline} structures which are referenced within the created pipeline, including all their shader groups.")
}

val VkBindShaderGroupIndirectCommandNV = struct(Module.VULKAN, "VkBindShaderGroupIndirectCommandNV") {
    documentation =
        """
        Structure specifying input data for a single shader group command token.

        <h5>Valid Usage</h5>
        <ul>
            <li>The current bound graphics pipeline, as well as the pipelines it may reference, <b>must</b> have been created with #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV</li>
            <li>The {@code index} <b>must</b> be within range of the accessible shader groups of the current bound graphics pipeline. See #CmdBindPipelineShaderGroupNV() for further details</li>
        </ul>
        """

    uint32_t("groupIndex", "specifies which shader group of the current bound graphics pipeline is used.")
}

val VkBindIndexBufferIndirectCommandNV = struct(Module.VULKAN, "VkBindIndexBufferIndirectCommandNV") {
    documentation =
        """
        Structure specifying input data for a single index buffer command token.

        <h5>Valid Usage</h5>
        <ul>
            <li>The buffer’s usage flag from which the address was acquired <b>must</b> have the #BUFFER_USAGE_INDEX_BUFFER_BIT bit set</li>
            <li>The {@code bufferAddress} <b>must</b> be aligned to the {@code indexType} used</li>
            <li>Each element of the buffer from which the address was acquired and that is non-sparse <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code indexType} <b>must</b> be a valid {@code VkIndexType} value</li>
        </ul>
        """

    VkDeviceAddress("bufferAddress", "specifies a physical address of the {@code VkBuffer} used as index buffer.")
    uint32_t("size", "the byte size range which is available for this operation from the provided address.")
    VkIndexType("indexType", "a {@code VkIndexType} value specifying how indices are treated. Instead of the Vulkan enum values, a custom {@code uint32_t} value <b>can</b> be mapped to an {@code VkIndexType} by specifying the ##VkIndirectCommandsLayoutTokenNV{@code ::pIndexTypes} and ##VkIndirectCommandsLayoutTokenNV{@code ::pIndexTypeValues} arrays.")
}

val VkBindVertexBufferIndirectCommandNV = struct(Module.VULKAN, "VkBindVertexBufferIndirectCommandNV") {
    documentation =
        """
        Structure specifying input data for a single vertex buffer command token.

        <h5>Valid Usage</h5>
        <ul>
            <li>The buffer’s usage flag from which the address was acquired <b>must</b> have the #BUFFER_USAGE_VERTEX_BUFFER_BIT bit set</li>
            <li>Each element of the buffer from which the address was acquired and that is non-sparse <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
        </ul>
        """

    VkDeviceAddress("bufferAddress", "specifies a physical address of the {@code VkBuffer} used as vertex input binding.")
    uint32_t("size", "the byte size range which is available for this operation from the provided address.")
    uint32_t("stride", "the byte size stride for this vertex input binding as in ##VkVertexInputBindingDescription{@code ::stride}. It is only used if ##VkIndirectCommandsLayoutTokenNV{@code ::vertexDynamicStride} was set, otherwise the stride is inherited from the current bound graphics pipeline.")
}

val VkSetStateFlagsIndirectCommandNV = struct(Module.VULKAN, "VkSetStateFlagsIndirectCommandNV") {
    documentation =
        """
        Structure specifying input data for a single state flag command token.
        """

    uint32_t("data", """encodes packed state that this command alters.

        <ul>
            <li>Bit 0: If set represents #FRONT_FACE_CLOCKWISE, otherwise #FRONT_FACE_COUNTER_CLOCKWISE</li>
        </ul>""")
}

val VkIndirectCommandsStreamNV = struct(Module.VULKAN, "VkIndirectCommandsStreamNV") {
    documentation =
        """
        Structure specifying input streams for generated command tokens.

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code buffer}’s usage flag <b>must</b> have the #BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</li>
            <li>The {@code offset} <b>must</b> be aligned to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::minIndirectCommandsBufferOffsetAlignment}</li>
            <li>If {@code buffer} is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code buffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
        </ul>

        <h5>See Also</h5>
        ##VkGeneratedCommandsInfoNV
        """

    VkBuffer("buffer", "specifies the {@code VkBuffer} storing the functional arguments for each sequence. These arguments <b>can</b> be written by the device.")
    VkDeviceSize("offset", "specified an offset into {@code buffer} where the arguments start.")
}

val VkIndirectCommandsLayoutTokenNV = struct(Module.VULKAN, "VkIndirectCommandsLayoutTokenNV") {
    documentation =
        """
        Struct specifying the details of an indirect command layout token.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code stream} <b>must</b> be smaller than ##VkIndirectCommandsLayoutCreateInfoNV{@code ::streamCount}</li>
            <li>{@code offset} <b>must</b> be less than or equal to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxIndirectCommandsTokenOffset}</li>
            <li>{@code offset} <b>must</b> be aligned to the scalar alignment of {@code tokenType} or {@code minIndirectCommandsBufferOffsetAlignment}, whichever is lower</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV, {@code vertexBindingUnit} <b>must</b> stay within device supported limits for the appropriate commands</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, {@code pushconstantPipelineLayout} <b>must</b> be valid</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, {@code pushconstantOffset} <b>must</b> be a multiple of 4</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, {@code pushconstantSize} <b>must</b> be a multiple of 4</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, {@code pushconstantOffset} <b>must</b> be less than ##VkPhysicalDeviceLimits{@code ::maxPushConstantsSize}</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, {@code pushconstantSize} <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxPushConstantsSize} minus {@code pushconstantOffset}</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, for each byte in the range specified by {@code pushconstantOffset} and {@code pushconstantSize} and for each shader stage in {@code pushconstantShaderStageFlags}, there <b>must</b> be a push constant range in {@code pushconstantPipelineLayout} that includes that byte and that stage</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, for each byte in the range specified by {@code pushconstantOffset} and {@code pushconstantSize} and for each push constant range that overlaps that byte, {@code pushconstantShaderStageFlags} <b>must</b> include all stages in that push constant range’s ##VkPushConstantRange{@code ::stageFlags}</li>
            <li>If {@code tokenType} is #INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV, {@code indirectStateFlags} <b>must</b> not be 0</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code tokenType} <b>must</b> be a valid {@code VkIndirectCommandsTokenTypeNV} value</li>
            <li>If {@code pushconstantPipelineLayout} is not #NULL_HANDLE, {@code pushconstantPipelineLayout} <b>must</b> be a valid {@code VkPipelineLayout} handle</li>
            <li>{@code pushconstantShaderStageFlags} <b>must</b> be a valid combination of {@code VkShaderStageFlagBits} values</li>
            <li>{@code indirectStateFlags} <b>must</b> be a valid combination of {@code VkIndirectStateFlagBitsNV} values</li>
            <li>If {@code indexTypeCount} is not 0, {@code pIndexTypes} <b>must</b> be a valid pointer to an array of {@code indexTypeCount} valid {@code VkIndexType} values</li>
            <li>If {@code indexTypeCount} is not 0, {@code pIndexTypeValues} <b>must</b> be a valid pointer to an array of {@code indexTypeCount} {@code uint32_t} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkIndirectCommandsLayoutCreateInfoNV
        """

    Expression("#STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkIndirectCommandsTokenTypeNV("tokenType", "specifies the token command type.")
    uint32_t("stream", "the index of the input stream containing the token argument data.")
    uint32_t("offset", "a relative starting offset within the input stream memory for the token argument data.")
    uint32_t("vertexBindingUnit", "used for the vertex buffer binding command.")
    VkBool32("vertexDynamicStride", "sets if the vertex buffer stride is provided by the binding command rather than the current bound graphics pipeline state.")
    VkPipelineLayout("pushconstantPipelineLayout", "the {@code VkPipelineLayout} used for the push constant command.")
    VkShaderStageFlags("pushconstantShaderStageFlags", "are the shader stage flags used for the push constant command.")
    uint32_t("pushconstantOffset", "the offset used for the push constant command.")
    uint32_t("pushconstantSize", "the size used for the push constant command.")
    VkIndirectStateFlagsNV("indirectStateFlags", "are the active states for the state flag command.")
    AutoSize("pIndexTypes", "pIndexTypeValues", optional = true)..uint32_t("indexTypeCount", "the optional size of the {@code pIndexTypes} and {@code pIndexTypeValues} array pairings. If not zero, it allows to register a custom {@code uint32_t} value to be treated as specific {@code VkIndexType}.")
    VkIndexType.const.p("pIndexTypes", "the used {@code VkIndexType} for the corresponding {@code uint32_t} value entry in {@code pIndexTypeValues}.")
    uint32_t.const.p("pIndexTypeValues", "")
}

val VkIndirectCommandsLayoutCreateInfoNV = struct(Module.VULKAN, "VkIndirectCommandsLayoutCreateInfoNV") {
    documentation =
        """
        Structure specifying the parameters of a newly created indirect commands layout object.

        <h5>Description</h5>
        The following code illustrates some of the flags:

        <pre><code>
￿void cmdProcessAllSequences(cmd, pipeline, indirectCommandsLayout, pIndirectCommandsTokens, sequencesCount, indexbuffer, indexbufferOffset)
￿{
￿  for (s = 0; s &lt; sequencesCount; s++)
￿  {
￿    sUsed = s;
￿
￿    if (indirectCommandsLayout.flags &amp; VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV) {
￿      sUsed = indexbuffer.load_uint32( sUsed * sizeof(uint32_t) + indexbufferOffset);
￿    }
￿
￿    if (indirectCommandsLayout.flags &amp; VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV) {
￿      sUsed = incoherent_implementation_dependent_permutation[ sUsed ];
￿    }
￿
￿    cmdProcessSequence( cmd, pipeline, indirectCommandsLayout, pIndirectCommandsTokens, sUsed );
￿  }
￿}</code></pre>

        When tokens are consumed, an offset is computed based on token offset and stream stride. The resulting offset is required to be aligned. The alignment for a specific token is equal to the scalar alignment of the data type as defined in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#interfaces-alignment-requirements">Alignment Requirements</a>, or ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::minIndirectCommandsBufferOffsetAlignment}, whichever is lower.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        A {@code minIndirectCommandsBufferOffsetAlignment} of 4 allows {@code VkDeviceAddress} to be packed as {@code uvec2} with scalar layout instead of {@code uint64_t} with 8 byte alignment. This enables direct compatibility with D3D12 command signature layouts.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code pipelineBindPoint} <b>must</b> be #PIPELINE_BIND_POINT_GRAPHICS or #PIPELINE_BIND_POINT_COMPUTE</li>
            <li>{@code tokenCount} <b>must</b> be greater than 0 and less than or equal to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxIndirectCommandsTokenCount}</li>
            <li>If {@code pTokens} contains an entry of #INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV it <b>must</b> be the first element of the array and there <b>must</b> be only a single element of such token type</li>
            <li>If {@code pTokens} contains an entry of #INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV there <b>must</b> be only a single element of such token type</li>
            <li>All state tokens in {@code pTokens} <b>must</b> occur before any work provoking tokens (#INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV, #INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV, #INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV, #INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV , #INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV )</li>
            <li>The content of {@code pTokens} <b>must</b> include one single work provoking token that is compatible with the {@code pipelineBindPoint}</li>
            <li>{@code streamCount} <b>must</b> be greater than 0 and less or equal to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxIndirectCommandsStreamCount}</li>
            <li>each element of {@code pStreamStrides} <b>must</b> be greater than 0 and less than or equal to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxIndirectCommandsStreamStride}. Furthermore the alignment of each token input <b>must</b> be ensured</li>
            <li>If {@code pipelineBindPoint} is #PIPELINE_BIND_POINT_COMPUTE then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-deviceGeneratedCompute">##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV{@code ::deviceGeneratedCompute}</a> feature <b>must</b> be enabled</li>
            <li>If {@code pipelineBindPoint} is #PIPELINE_BIND_POINT_COMPUTE then the state tokens in {@code pTokens} <b>must</b> only include #INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV, #INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV, or #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV</li>
            <li>If {@code pipelineBindPoint} is #PIPELINE_BIND_POINT_COMPUTE and {@code pTokens} includes #INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV, then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-deviceGeneratedComputePipelines">##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV{@code ::deviceGeneratedComputePipelines}</a> feature <b>must</b> be enabled</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkIndirectCommandsLayoutUsageFlagBitsNV} values</li>
            <li>{@code pipelineBindPoint} <b>must</b> be a valid {@code VkPipelineBindPoint} value</li>
            <li>{@code pTokens} <b>must</b> be a valid pointer to an array of {@code tokenCount} valid ##VkIndirectCommandsLayoutTokenNV structures</li>
            <li>{@code pStreamStrides} <b>must</b> be a valid pointer to an array of {@code streamCount} {@code uint32_t} values</li>
            <li>{@code tokenCount} <b>must</b> be greater than 0</li>
            <li>{@code streamCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkIndirectCommandsLayoutTokenNV, #CreateIndirectCommandsLayoutNV()
        """

    Expression("#STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkIndirectCommandsLayoutUsageFlagsNV("flags", "a bitmask of {@code VkIndirectCommandsLayoutUsageFlagBitsNV} specifying usage hints of this layout.")
    VkPipelineBindPoint("pipelineBindPoint", "the {@code VkPipelineBindPoint} that this layout targets.")
    AutoSize("pTokens")..uint32_t("tokenCount", "the length of the individual command sequence.")
    VkIndirectCommandsLayoutTokenNV.const.p("pTokens", "an array describing each command token in detail. See {@code VkIndirectCommandsTokenTypeNV} and ##VkIndirectCommandsLayoutTokenNV below for details.")
    AutoSize("pStreamStrides")..uint32_t("streamCount", "the number of streams used to provide the token inputs.")
    uint32_t.const.p("pStreamStrides", "an array defining the byte stride for each input stream.")
}

val VkGeneratedCommandsInfoNV = struct(Module.VULKAN, "VkGeneratedCommandsInfoNV") {
    documentation =
        """
        Structure specifying parameters for the generation of commands.

        <h5>Valid Usage</h5>
        <ul>
            <li>The provided {@code pipeline} <b>must</b> match the pipeline bound at execution time</li>
            <li>If the {@code indirectCommandsLayout} uses a token of #INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the {@code pipeline} <b>must</b> have been created with multiple shader groups</li>
            <li>If the {@code indirectCommandsLayout} uses a token of #INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the {@code pipeline} <b>must</b> have been created with #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV set in ##VkGraphicsPipelineCreateInfo{@code ::flags}</li>
            <li>If the {@code indirectCommandsLayout} uses a token of #INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, then the {@code pipeline}`s {@code VkPipelineLayout} <b>must</b> match the ##VkIndirectCommandsLayoutTokenNV{@code ::pushconstantPipelineLayout}</li>
            <li>{@code streamCount} <b>must</b> match the {@code indirectCommandsLayout}’s {@code streamCount}</li>
            <li>If {@code pipelineBindPoint} is of type #PIPELINE_BIND_POINT_COMPUTE, then the {@code pipeline} <b>must</b> have been created with the flag #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV</li>
            <li>If {@code pipelineBindPoint} is of type #PIPELINE_BIND_POINT_COMPUTE, then the {@code pipeline} <b>must</b> have been created with a ##VkComputePipelineIndirectBufferInfoNV structure specifying a valid address where its metadata will be saved</li>
            <li>If {@code pipelineBindPoint} is of type #PIPELINE_BIND_POINT_COMPUTE, then #CmdUpdatePipelineIndirectBufferNV() <b>must</b> have been called on that pipeline to save its metadata to a device address</li>
            <li>If {@code pipelineBindPoint} is of type #PIPELINE_BIND_POINT_COMPUTE, and if #INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV is used, then {@code pipeline} <b>must</b> be #NULL_HANDLE</li>
            <li>{@code sequencesCount} <b>must</b> be less or equal to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxIndirectSequenceCount} and ##VkGeneratedCommandsMemoryRequirementsInfoNV{@code ::maxSequencesCount} that was used to determine the {@code preprocessSize}</li>
            <li>{@code preprocessBuffer} <b>must</b> have the #BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set in its usage flag</li>
            <li>{@code preprocessOffset} <b>must</b> be aligned to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::minIndirectCommandsBufferOffsetAlignment}</li>
            <li>If {@code preprocessBuffer} is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>{@code preprocessSize} <b>must</b> be at least equal to the memory requirement`s size returned by #GetGeneratedCommandsMemoryRequirementsNV() using the matching inputs ({@code indirectCommandsLayout}, …​) as within this structure</li>
            <li>{@code sequencesCountBuffer} <b>can</b> be set if the actual used count of sequences is sourced from the provided buffer. In that case the {@code sequencesCount} serves as upper bound</li>
            <li>If {@code sequencesCountBuffer} is not #NULL_HANDLE, its usage flag <b>must</b> have the #BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</li>
            <li>If {@code sequencesCountBuffer} is not #NULL_HANDLE, {@code sequencesCountOffset} <b>must</b> be aligned to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::minSequencesCountBufferOffsetAlignment}</li>
            <li>If {@code sequencesCountBuffer} is not #NULL_HANDLE and is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>If {@code indirectCommandsLayout}’s #INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV is set, {@code sequencesIndexBuffer} <b>must</b> be set otherwise it <b>must</b> be #NULL_HANDLE</li>
            <li>If {@code sequencesIndexBuffer} is not #NULL_HANDLE, its usage flag <b>must</b> have the #BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</li>
            <li>If {@code sequencesIndexBuffer} is not #NULL_HANDLE, {@code sequencesIndexOffset} <b>must</b> be aligned to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::minSequencesIndexBufferOffsetAlignment}</li>
            <li>If {@code sequencesIndexBuffer} is not #NULL_HANDLE and is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>If the {@code indirectCommandsLayout} uses a token of #INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV, then the {@code pipeline} <b>must</b> contain a shader stage using the {@code MeshNV} {@code Execution} {@code Model}</li>
            <li>If the {@code indirectCommandsLayout} uses a token of #INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV, then the {@code pipeline} <b>must</b> contain a shader stage using the {@code MeshEXT} {@code Execution} {@code Model}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pipelineBindPoint} <b>must</b> be a valid {@code VkPipelineBindPoint} value</li>
            <li>{@code pipeline} <b>must</b> be a valid {@code VkPipeline} handle</li>
            <li>{@code indirectCommandsLayout} <b>must</b> be a valid {@code VkIndirectCommandsLayoutNV} handle</li>
            <li>{@code pStreams} <b>must</b> be a valid pointer to an array of {@code streamCount} valid ##VkIndirectCommandsStreamNV structures</li>
            <li>{@code preprocessBuffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>If {@code sequencesCountBuffer} is not #NULL_HANDLE, {@code sequencesCountBuffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>If {@code sequencesIndexBuffer} is not #NULL_HANDLE, {@code sequencesIndexBuffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code streamCount} <b>must</b> be greater than 0</li>
            <li>Each of {@code indirectCommandsLayout}, {@code pipeline}, {@code preprocessBuffer}, {@code sequencesCountBuffer}, and {@code sequencesIndexBuffer} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        ##VkIndirectCommandsStreamNV, #CmdExecuteGeneratedCommandsNV(), #CmdPreprocessGeneratedCommandsNV()
        """

    Expression("#STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineBindPoint("pipelineBindPoint", "the {@code VkPipelineBindPoint} used for the {@code pipeline}.")
    VkPipeline("pipeline", "the {@code VkPipeline} used in the generation and execution process.")
    VkIndirectCommandsLayoutNV("indirectCommandsLayout", "the {@code VkIndirectCommandsLayoutNV} that provides the command sequence to generate.")
    AutoSize("pStreams")..uint32_t("streamCount", "defines the number of input streams")
    VkIndirectCommandsStreamNV.const.p("pStreams", "a pointer to an array of {@code streamCount} ##VkIndirectCommandsStreamNV structures providing the input data for the tokens used in {@code indirectCommandsLayout}.")
    uint32_t("sequencesCount", "the maximum number of sequences to reserve. If {@code sequencesCountBuffer} is #NULL_HANDLE, this is also the actual number of sequences generated.")
    VkBuffer("preprocessBuffer", "the {@code VkBuffer} that is used for preprocessing the input data for execution. If this structure is used with #CmdExecuteGeneratedCommandsNV() with its {@code isPreprocessed} set to #TRUE, then the preprocessing step is skipped and data is only read from this buffer. The contents and the layout of this buffer is opaque to applications and <b>must</b> not be modified or copied to another buffer for reuse.")
    VkDeviceSize("preprocessOffset", "the byte offset into {@code preprocessBuffer} where the preprocessed data is stored.")
    VkDeviceSize("preprocessSize", "the maximum byte size within the {@code preprocessBuffer} after the {@code preprocessOffset} that is available for preprocessing.")
    VkBuffer("sequencesCountBuffer", "a {@code VkBuffer} in which the actual number of sequences is provided as single {@code uint32_t} value.")
    VkDeviceSize("sequencesCountOffset", "the byte offset into {@code sequencesCountBuffer} where the count value is stored.")
    VkBuffer("sequencesIndexBuffer", "a {@code VkBuffer} that encodes the used sequence indices as {@code uint32_t} array.")
    VkDeviceSize("sequencesIndexOffset", "the byte offset into {@code sequencesIndexBuffer} where the index values start.")
}

val VkGeneratedCommandsMemoryRequirementsInfoNV = struct(Module.VULKAN, "VkGeneratedCommandsMemoryRequirementsInfoNV") {
    documentation =
        """
        Structure specifying parameters for the reservation of preprocess buffer space.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code maxSequencesCount} <b>must</b> be less or equal to ##VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV{@code ::maxIndirectSequenceCount}</li>
            <li>If {@code pipelineBindPoint} is of type #PIPELINE_BIND_POINT_GRAPHICS, then {@code pipeline} <b>must</b> be a valid {@code VkPipeline} handle</li>
            <li>If {@code pipelineBindPoint} is of type #PIPELINE_BIND_POINT_COMPUTE, and the {@code indirectCommandsLayout} was not created with a #INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV token, then the {@code pipeline} <b>must</b> be a valid {@code VkPipeline} handle</li>
            <li>If {@code pipelineBindPoint} is of type #PIPELINE_BIND_POINT_COMPUTE, and the {@code indirectCommandsLayout} contains a #INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV token, then the {@code pipeline} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pipelineBindPoint} <b>must</b> be a valid {@code VkPipelineBindPoint} value</li>
            <li>If {@code pipeline} is not #NULL_HANDLE, {@code pipeline} <b>must</b> be a valid {@code VkPipeline} handle</li>
            <li>{@code indirectCommandsLayout} <b>must</b> be a valid {@code VkIndirectCommandsLayoutNV} handle</li>
            <li>Both of {@code indirectCommandsLayout}, and {@code pipeline} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #GetGeneratedCommandsMemoryRequirementsNV()
        """

    Expression("#STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineBindPoint("pipelineBindPoint", "the {@code VkPipelineBindPoint} of the {@code pipeline} that this buffer memory is intended to be used with during the execution.")
    VkPipeline("pipeline", "the {@code VkPipeline} that this buffer memory is intended to be used with during the execution.")
    VkIndirectCommandsLayoutNV("indirectCommandsLayout", "the {@code VkIndirectCommandsLayoutNV} that this buffer memory is intended to be used with.")
    uint32_t("maxSequencesCount", "the maximum number of sequences that this buffer memory in combination with the other state provided <b>can</b> be used with.")
}

val VkPhysicalDeviceInheritedViewportScissorFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceInheritedViewportScissorFeaturesNV") {
    documentation =
        """
        Structure describing the viewport scissor inheritance behavior for an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceInheritedViewportScissorFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceInheritedViewportScissorFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("inheritedViewportScissor2D", "indicates whether secondary command buffers can inherit most of the dynamic state affected by #DYNAMIC_STATE_VIEWPORT_WITH_COUNT, #DYNAMIC_STATE_SCISSOR_WITH_COUNT, #DYNAMIC_STATE_DISCARD_RECTANGLE_EXT, #DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT, #DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT, #DYNAMIC_STATE_VIEWPORT or #DYNAMIC_STATE_SCISSOR, from a primary command buffer.")
}

val VkCommandBufferInheritanceViewportScissorInfoNV = struct(Module.VULKAN, "VkCommandBufferInheritanceViewportScissorInfoNV") {
    documentation =
        """
        Structure specifying command buffer inheritance information.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkCommandBufferInheritanceInfo includes a ##VkCommandBufferInheritanceViewportScissorInfoNV structure, then that structure controls whether a command buffer <b>can</b> inherit the following state from other command buffers:

        <ul>
            <li>#DYNAMIC_STATE_SCISSOR</li>
            <li>#DYNAMIC_STATE_SCISSOR_WITH_COUNT</li>
            <li>#DYNAMIC_STATE_DISCARD_RECTANGLE_EXT</li>
            <li>#DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT</li>
            <li>#DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT</li>
        </ul>

        as well as the following state, with restrictions on inherited depth values and viewport count:

        <ul>
            <li>#DYNAMIC_STATE_VIEWPORT</li>
            <li>#DYNAMIC_STATE_VIEWPORT_WITH_COUNT</li>
        </ul>

        If {@code viewportScissor2D} is #FALSE, then the command buffer does not inherit the listed dynamic state, and <b>should</b> set this state itself. If this structure is not present, the behavior is as if {@code viewportScissor2D} is #FALSE.

        If {@code viewportScissor2D} is #TRUE, then the listed dynamic state is inherited, and the command buffer <b>must</b> not set this state, except that the viewport and scissor count <b>may</b> be set by binding a graphics pipeline that does not specify this state as dynamic.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Due to this restriction, applications <b>should</b> ensure either all or none of the graphics pipelines bound in this secondary command buffer use dynamic viewport/scissor counts.
        </div>

        When the command buffer is executed as part of a the execution of a #CmdExecuteCommands() command, the inherited state (if enabled) is determined by the following procedure, performed separately for each dynamic state, and separately for each value for dynamic state that consists of multiple values (e.g. multiple viewports).

        <ul>
            <li>With <code>i</code> being the index of the executed command buffer in the {@code pCommandBuffers} array of #CmdExecuteCommands(), if <code>i &gt; 0</code> and any secondary command buffer from index <code>0</code> to <code>i-1</code> modifies the state, the inherited state is provisionally set to the final value set by the last such secondary command buffer. Binding a graphics pipeline defining the state statically is equivalent to setting the state to an undefined value.</li>
            <li>Otherwise, the tentatative inherited state is that of the primary command buffer at the point the #CmdExecuteCommands() command was recorded; if the state is undefined, then so is the provisional inherited state.</li>
            <li>If the provisional inherited state is an undefined value, then the state is not inherited.</li>
            <li>If the provisional inherited state is a viewport, with <code>n</code> being its viewport index, then if <code>n ≥ viewportDepthCount</code>, or if either ##VkViewport{@code ::minDepth} or ##VkViewport{@code ::maxDepth} are not equal to the respective values of the <code>n<sup>th</sup></code> element of {@code pViewportDepths}, then the state is not inherited.</li>
            <li>If the provisional inherited state passes both checks, then it becomes the actual inherited state.</li>
        </ul>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        There is no support for inheriting dynamic state from a secondary command buffer executed as part of a different {@code vkCmdExecuteCommands} command.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-inheritedViewportScissor2D">{@code inheritedViewportScissor2D}</a> feature is not enabled, {@code viewportScissor2D} <b>must</b> be #FALSE</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-multiViewport">{@code multiViewport}</a> feature is not enabled and {@code viewportScissor2D} is #TRUE, then {@code viewportDepthCount} <b>must</b> be 1</li>
            <li>If {@code viewportScissor2D} is #TRUE, then {@code viewportDepthCount} <b>must</b> be greater than 0</li>
            <li>If {@code viewportScissor2D} is #TRUE, then {@code pViewportDepths} <b>must</b> be a valid pointer to an array of {@code viewportDepthCount} valid ##VkViewport structures, except any requirements on {@code x}, {@code y}, {@code width}, and {@code height} do not apply</li>
            <li>If {@code viewportScissor2D} is #TRUE, then the command buffer <b>must</b> be recorded with the #COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV</li>
        </ul>

        <h5>See Also</h5>
        ##VkViewport
        """

    Expression("#STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("viewportScissor2D", "specifies whether the listed dynamic state is inherited.")
    uint32_t("viewportDepthCount", "specifies the maximum number of viewports to inherit. When {@code viewportScissor2D} is #FALSE, the behavior is as if this value is zero.")
    nullable..VkViewport.const.p("pViewportDepths", "a pointer to a ##VkViewport structure specifying the expected depth range for each inherited viewport.")
}

val VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR", alias = VkPhysicalDeviceShaderIntegerDotProductFeatures) {
    documentation = "See ##VkPhysicalDeviceShaderIntegerDotProductFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderIntegerDotProduct", "")
}

val VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR", mutable = false, alias = VkPhysicalDeviceShaderIntegerDotProductProperties) {
    documentation = "See ##VkPhysicalDeviceShaderIntegerDotProductProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkBool32("integerDotProduct8BitUnsignedAccelerated", "")
    VkBool32("integerDotProduct8BitSignedAccelerated", "")
    VkBool32("integerDotProduct8BitMixedSignednessAccelerated", "")
    VkBool32("integerDotProduct4x8BitPackedUnsignedAccelerated", "")
    VkBool32("integerDotProduct4x8BitPackedSignedAccelerated", "")
    VkBool32("integerDotProduct4x8BitPackedMixedSignednessAccelerated", "")
    VkBool32("integerDotProduct16BitUnsignedAccelerated", "")
    VkBool32("integerDotProduct16BitSignedAccelerated", "")
    VkBool32("integerDotProduct16BitMixedSignednessAccelerated", "")
    VkBool32("integerDotProduct32BitUnsignedAccelerated", "")
    VkBool32("integerDotProduct32BitSignedAccelerated", "")
    VkBool32("integerDotProduct32BitMixedSignednessAccelerated", "")
    VkBool32("integerDotProduct64BitUnsignedAccelerated", "")
    VkBool32("integerDotProduct64BitSignedAccelerated", "")
    VkBool32("integerDotProduct64BitMixedSignednessAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating8BitUnsignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating8BitSignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating16BitUnsignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating16BitSignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating32BitUnsignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating32BitSignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating64BitUnsignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating64BitSignedAccelerated", "")
    VkBool32("integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated", "")
}

val VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT") {
    documentation =
        """
        Structure describing the texel buffer alignment features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("texelBufferAlignment", "indicates whether the implementation uses more specific alignment requirements advertised in ##VkPhysicalDeviceTexelBufferAlignmentProperties rather than ##VkPhysicalDeviceLimits{@code ::minTexelBufferOffsetAlignment}.")
}

val VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT", mutable = false, alias = VkPhysicalDeviceTexelBufferAlignmentProperties) {
    documentation = "See ##VkPhysicalDeviceTexelBufferAlignmentProperties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkDeviceSize("storageTexelBufferOffsetAlignmentBytes", "")
    VkBool32("storageTexelBufferOffsetSingleTexelAlignment", "")
    VkDeviceSize("uniformTexelBufferOffsetAlignmentBytes", "")
    VkBool32("uniformTexelBufferOffsetSingleTexelAlignment", "")
}

val VkRenderPassTransformBeginInfoQCOM = struct(Module.VULKAN, "VkRenderPassTransformBeginInfoQCOM") {
    documentation =
        """
        Structure describing transform parameters of a render pass instance.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code transform} <b>must</b> be #SURFACE_TRANSFORM_IDENTITY_BIT_KHR, #SURFACE_TRANSFORM_ROTATE_90_BIT_KHR, #SURFACE_TRANSFORM_ROTATE_180_BIT_KHR, or #SURFACE_TRANSFORM_ROTATE_270_BIT_KHR</li>
            <li>The {@code renderpass} <b>must</b> have been created with ##VkRenderPassCreateInfo{@code ::flags} containing #RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSurfaceTransformFlagBitsKHR("transform", "a {@code VkSurfaceTransformFlagBitsKHR} value describing the transform to be applied to rasterization.")
}

val VkCommandBufferInheritanceRenderPassTransformInfoQCOM = struct(Module.VULKAN, "VkCommandBufferInheritanceRenderPassTransformInfoQCOM") {
    documentation =
        """
        Structure describing transformed render pass parameters command buffer.

        <h5>Description</h5>
        When the secondary is recorded to execute within a render pass instance using #CmdExecuteCommands(), the render pass transform parameters of the secondary command buffer <b>must</b> be consistent with the render pass transform parameters specified for the render pass instance. In particular, the {@code transform} and {@code renderArea} for command buffer <b>must</b> be identical to the {@code transform} and {@code renderArea} of the render pass instance.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code transform} <b>must</b> be #SURFACE_TRANSFORM_IDENTITY_BIT_KHR, #SURFACE_TRANSFORM_ROTATE_90_BIT_KHR, #SURFACE_TRANSFORM_ROTATE_180_BIT_KHR, or #SURFACE_TRANSFORM_ROTATE_270_BIT_KHR</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM</li>
        </ul>

        <h5>See Also</h5>
        ##VkRect2D
        """

    Expression("#STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSurfaceTransformFlagBitsKHR("transform", "a {@code VkSurfaceTransformFlagBitsKHR} value describing the transform to be applied to the render pass.")
    VkRect2D("renderArea", "the render area that is affected by the command buffer.")
}

val VkPhysicalDeviceDepthBiasControlFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDepthBiasControlFeaturesEXT") {
    documentation =
        """
        Structure indicating support for depth bias scaling and representation control.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("depthBiasControl", "indicates whether the implementation supports the {@code vkCmdSetDepthBias2EXT} command and the ##VkDepthBiasRepresentationInfoEXT structure.")
    VkBool32("leastRepresentableValueForceUnormRepresentation", "indicates whether the implementation supports using the #DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT depth bias representation.")
    VkBool32("floatRepresentation", "indicates whether the implementation supports using the #DEPTH_BIAS_REPRESENTATION_FLOAT_EXT depth bias representation.")
    VkBool32("depthBiasExact", "indicates whether the implementation supports forcing depth bias to not be scaled to ensure a minimum resolvable difference using ##VkDepthBiasRepresentationInfoEXT{@code ::depthBiasExact}.")
}

val VkDepthBiasInfoEXT = struct(Module.VULKAN, "VkDepthBiasInfoEXT") {
    documentation =
        """
        Structure specifying depth bias parameters.

        <h5>Description</h5>
        If {@code pNext} does not contain a ##VkDepthBiasRepresentationInfoEXT structure, then this command is equivalent to including a ##VkDepthBiasRepresentationInfoEXT with {@code depthBiasExact} set to #FALSE and {@code depthBiasRepresentation} set to #DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-depthBiasClamp">{@code depthBiasClamp}</a> feature is not enabled, {@code depthBiasClamp} <b>must</b> be {@code 0.0}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL} or a pointer to a valid instance of ##VkDepthBiasRepresentationInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetDepthBias2EXT()
        """

    Expression("#STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkDepthBiasRepresentationInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    float("depthBiasConstantFactor", "a scalar factor controlling the constant depth value added to each fragment.")
    float("depthBiasClamp", "the maximum (or minimum) depth bias of a fragment.")
    float("depthBiasSlopeFactor", "a scalar factor applied to a fragment’s slope in depth bias calculations.")
}

val VkDepthBiasRepresentationInfoEXT = struct(Module.VULKAN, "VkDepthBiasRepresentationInfoEXT") {
    documentation =
        """
        Structure specifying depth bias parameters.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-leastRepresentableValueForceUnormRepresentation">{@code leastRepresentableValueForceUnormRepresentation}</a> feature is not enabled, {@code depthBiasRepresentation} <b>must</b> not be {@code VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT}</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-floatRepresentation">{@code floatRepresentation}</a> feature is not enabled, {@code depthBiasRepresentation} <b>must</b> not be {@code VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT}</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-depthBiasExact">{@code depthBiasExact}</a> feature is not enabled, {@code depthBiasExact} <b>must</b> be {@code VK_FALSE}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT</li>
            <li>{@code depthBiasRepresentation} <b>must</b> be a valid {@code VkDepthBiasRepresentationEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDepthBiasRepresentationEXT("depthBiasRepresentation", "a {@code VkDepthBiasRepresentationEXT} value specifying the depth bias representation.")
    VkBool32("depthBiasExact", "specifies that the implementation is not allowed to scale the depth bias value to ensure a minimum resolvable distance.")
}

val VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT") {
    documentation =
        """
        Structure describing whether device memory report callback can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDeviceMemoryReportFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDeviceMemoryReportFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("deviceMemoryReport", "indicates whether the implementation supports the ability to register device memory report callbacks.")
}

val VkDeviceMemoryReportCallbackDataEXT = struct(Module.VULKAN, "VkDeviceMemoryReportCallbackDataEXT", mutable = false) {
    documentation =
        """
        Structure specifying parameters returned to the callback.

        <h5>Description</h5>
        {@code memoryObjectId} is used to avoid double-counting on the same memory object.

        If an internally-allocated device memory object or a {@code VkDeviceMemory} <b>cannot</b> be exported, {@code memoryObjectId} <b>must</b> be unique in the {@code VkDevice}.

        If an internally-allocated device memory object or a {@code VkDeviceMemory} supports being exported, {@code memoryObjectId} <b>must</b> be unique system wide.

        If an internal device memory object or a {@code VkDeviceMemory} is backed by an imported external memory object, {@code memoryObjectId} <b>must</b> be unique system wide.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        This structure should only be considered valid during the lifetime of the triggered callback.

        For #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT and #DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT events, {@code objectHandle} usually will not yet exist when the application or tool receives the callback. {@code objectHandle} will only exist when the create or allocate call that triggered the event returns, and if the allocation or import ends up failing {@code objectHandle} will not ever exist.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDeviceMemoryReportFlagsEXT("flags", "0 and reserved for future use.")
    VkDeviceMemoryReportEventTypeEXT("type", "a {@code VkDeviceMemoryReportEventTypeEXT} type specifying the type of event reported in this ##VkDeviceMemoryReportCallbackDataEXT structure.")
    uint64_t("memoryObjectId", "the unique id for the underlying memory object as described below.")
    VkDeviceSize("size", "the size of the memory object in bytes. If {@code type} is #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT, #DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT or #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT, {@code size} is a valid {@code VkDeviceSize} value. Otherwise, {@code size} is undefined.")
    VkObjectType("objectType", "a {@code VkObjectType} value specifying the type of the object associated with this device memory report event. If {@code type} is #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT, #DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT, #DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT, #DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT or #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT, {@code objectType} is a valid {@code VkObjectType} enum. Otherwise, {@code objectType} is undefined.")
    uint64_t("objectHandle", "the object this device memory report event is attributed to. If {@code type} is #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT, #DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT, #DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT or #DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT, {@code objectHandle} is a valid Vulkan handle of the type associated with {@code objectType} as defined in the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#debugging-object-types\">{@code VkObjectType} and Vulkan Handle Relationship</a> table. Otherwise, {@code objectHandle} is undefined.")
    uint32_t("heapIndex", "describes which memory heap this device memory allocation is made from. If {@code type} is #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT or #DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT, {@code heapIndex} corresponds to one of the valid heaps from the ##VkPhysicalDeviceMemoryProperties structure. Otherwise, {@code heapIndex} is undefined.")
}

val VkDeviceDeviceMemoryReportCreateInfoEXT = struct(Module.VULKAN, "VkDeviceDeviceMemoryReportCreateInfoEXT") {
    documentation =
        """
        Register device memory report callbacks for a Vulkan device.

        <h5>Description</h5>
        The callback <b>may</b> be called from multiple threads simultaneously.

        The callback <b>must</b> be called only once by the implementation when a {@code VkDeviceMemoryReportEventTypeEXT} event occurs.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The callback could be called from a background thread other than the thread calling the Vulkan commands.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code pfnUserCallback} <b>must</b> be a valid ##VkDeviceMemoryReportCallbackEXT value</li>
            <li>{@code pUserData} <b>must</b> be a pointer value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceMemoryReportCallbackEXT
        """

    Expression("#STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceMemoryReportFlagsEXT("flags", "0 and reserved for future use.")
    PFN_vkDeviceMemoryReportCallbackEXT("pfnUserCallback", "the application callback function to call.")
    opaque_p("pUserData", "user data to be passed to the callback.")
}

val VkPhysicalDeviceRobustness2FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceRobustness2FeaturesEXT") {
    documentation =
        """
        Structure describing the out-of-bounds behavior for an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRobustness2FeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRobustness2FeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code robustBufferAccess2} is enabled then <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustBufferAccess">{@code robustBufferAccess}</a> <b>must</b> also be enabled</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("robustBufferAccess2", "indicates whether buffer accesses are tightly bounds-checked against the range of the descriptor. Uniform buffers <b>must</b> be bounds-checked to the range of the descriptor, where the range is rounded up to a multiple of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#limits-robustUniformBufferAccessSizeAlignment\">{@code robustUniformBufferAccessSizeAlignment}</a>. Storage buffers <b>must</b> be bounds-checked to the range of the descriptor, where the range is rounded up to a multiple of <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#limits-robustStorageBufferAccessSizeAlignment\">{@code robustStorageBufferAccessSizeAlignment}</a>. Out of bounds buffer loads will return zero values, and <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures\">image load, sample, and atomic operations</a> from texel buffers will have <code>(0,0,1)</code> values <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-conversion-to-rgba\">inserted for missing G, B, or A components</a> based on the format.")
    VkBool32("robustImageAccess2", "indicates whether image accesses are tightly bounds-checked against the dimensions of the image view. Out of bounds <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures\">image load, sample, and atomic operations</a> from images will return zero values, with <code>(0,0,1)</code> values <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-conversion-to-rgba\">inserted for missing G, B, or A components</a> based on the format.")
    VkBool32("nullDescriptor", "")
}

val VkPhysicalDeviceRobustness2PropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceRobustness2PropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing robust buffer access properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRobustness2PropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkDeviceSize("robustStorageBufferAccessSizeAlignment", "the number of bytes that the range of a storage buffer descriptor is rounded up to when used for bounds-checking when the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess2\">{@code robustBufferAccess2}</a> feature is enabled. This value <b>must</b> be either 1 or 4.")
    VkDeviceSize("robustUniformBufferAccessSizeAlignment", "the number of bytes that the range of a uniform buffer descriptor is rounded up to when used for bounds-checking when the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess2\">{@code robustBufferAccess2}</a> feature is enabled. This value <b>must</b> be a power of two in the range [1, 256].")
}

val VkSamplerCustomBorderColorCreateInfoEXT = struct(Module.VULKAN, "VkSamplerCustomBorderColorCreateInfoEXT") {
    documentation =
        """
        Structure specifying custom border color.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        If {@code format} is a depth/stencil format, the aspect is determined by the value of ##VkSamplerCreateInfo{@code ::borderColor}. If ##VkSamplerCreateInfo{@code ::borderColor} is #BORDER_COLOR_FLOAT_CUSTOM_EXT, the depth aspect is considered. If ##VkSamplerCreateInfo{@code ::borderColor} is #BORDER_COLOR_INT_CUSTOM_EXT, the stencil aspect is considered.

        If {@code format} is #FORMAT_UNDEFINED, the ##VkSamplerCreateInfo{@code ::borderColor} is #BORDER_COLOR_INT_CUSTOM_EXT, and the sampler is used with an image with a stencil format, then the implementation <b>must</b> source the custom border color from either the first or second components of ##VkSamplerCreateInfo{@code ::customBorderColor} and <b>should</b> source it from the first component.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code format} is not #FORMAT_UNDEFINED and {@code format} is not a depth/stencil format then the ##VkSamplerCreateInfo{@code ::borderColor} type <b>must</b> match the sampled type of the provided {@code format}, as shown in the <em>SPIR-V Type</em> column of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-numericformat">Interpretation of Numeric Format</a> table</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-customBorderColorWithoutFormat">{@code customBorderColorWithoutFormat}</a> feature is not enabled then {@code format} <b>must</b> not be #FORMAT_UNDEFINED</li>
            <li>If the sampler is used to sample an image view of #FORMAT_B4G4R4A4_UNORM_PACK16, #FORMAT_B5G6R5_UNORM_PACK16, #FORMAT_A1B5G5R5_UNORM_PACK16_KHR, or #FORMAT_B5G5R5A1_UNORM_PACK16 format then {@code format} <b>must</b> not be #FORMAT_UNDEFINED</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT</li>
            <li>{@code format} <b>must</b> be a valid {@code VkFormat} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkClearColorValue
        """

    Expression("#STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkClearColorValue("customBorderColor", "a ##VkClearColorValue representing the desired custom sampler border color.")
    VkFormat("format", "a {@code VkFormat} representing the format of the sampled image view(s). This field may be #FORMAT_UNDEFINED if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-customBorderColorWithoutFormat\">{@code customBorderColorWithoutFormat}</a> feature is enabled.")
}

val VkPhysicalDeviceCustomBorderColorPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceCustomBorderColorPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing whether custom border colors can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCustomBorderColorPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("maxCustomBorderColorSamplers", "indicates the maximum number of samplers with custom border colors which <b>can</b> simultaneously exist on a device.")
}

val VkPhysicalDeviceCustomBorderColorFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceCustomBorderColorFeaturesEXT") {
    documentation =
        """
        Structure describing whether custom border colors can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCustomBorderColorFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCustomBorderColorFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("customBorderColors", """indicates that the implementation supports providing a {@code borderColor} value with one of the following values at sampler creation time:

        <ul>
            <li>#BORDER_COLOR_FLOAT_CUSTOM_EXT</li>
            <li>#BORDER_COLOR_INT_CUSTOM_EXT</li>
        </ul>""")
    VkBool32("customBorderColorWithoutFormat", "indicates that explicit formats are not required for custom border colors and the value of the {@code format} member of the ##VkSamplerCustomBorderColorCreateInfoEXT structure <b>may</b> be #FORMAT_UNDEFINED. If this feature bit is not set, applications <b>must</b> provide the {@code VkFormat} of the image view(s) being sampled by this sampler in the {@code format} member of the ##VkSamplerCustomBorderColorCreateInfoEXT structure.")
}

val VkPhysicalDevicePresentBarrierFeaturesNV = struct(Module.VULKAN, "VkPhysicalDevicePresentBarrierFeaturesNV") {
    documentation =
        """
        Structure indicating support for VK_NV_present_barrier extension.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePresentBarrierFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePresentBarrierFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("presentBarrier", "indicates that the implementation supports the present barrier feature.")
}

val VkSurfaceCapabilitiesPresentBarrierNV = struct(Module.VULKAN, "VkSurfaceCapabilitiesPresentBarrierNV") {
    documentation =
        """
        Structure describing present barrier capabilities of a surface.

        <h5>Description</h5>
        This structure <b>can</b> be included in the {@code pNext} chain of ##VkSurfaceCapabilities2KHR to determine support for present barrier access. If {@code presentBarrierSupported} is #FALSE, it indicates that the present barrier feature is not obtainable for this surface.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("presentBarrierSupported", "a boolean describing whether the surface is able to make use of the present barrier feature.")
}

val VkSwapchainPresentBarrierCreateInfoNV = struct(Module.VULKAN, "VkSwapchainPresentBarrierCreateInfoNV") {
    documentation =
        """
        specify the present barrier membership of this swapchain.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkSwapchainCreateInfoKHR does not include this structure, the default value for {@code presentBarrierEnable} is #FALSE, meaning the swapchain does not request to use the present barrier. Additionally, when recreating a swapchain that was using the present barrier, and the {@code pNext} chain of ##VkSwapchainCreateInfoKHR does not include this structure, it means the swapchain will stop using the present barrier.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("presentBarrierEnable", "a boolean value indicating a request for using the <em>present barrier</em>.")
}

val VkPresentIdKHR = struct(Module.VULKAN, "VkPresentIdKHR") {
    documentation =
        """
        The list of presentation identifiers.

        <h5>Description</h5>
        For applications to be able to reference specific presentation events queued by a call to {@code vkQueuePresentKHR}, an identifier needs to be associated with them. When the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-presentId">{@code presentId}</a> feature is enabled, applications <b>can</b> include the ##VkPresentIdKHR structure in the {@code pNext} chain of the ##VkPresentInfoKHR structure to supply identifiers.

        Each {@code VkSwapchainKHR} has a presentId associated with it. This value is initially set to zero when the {@code VkSwapchainKHR} is created.

        When a ##VkPresentIdKHR structure with a non-NULL {@code pPresentIds} is included in the {@code pNext} chain of a ##VkPresentInfoKHR structure, each {@code pSwapchains} entry has a presentId associated in the {@code pPresentIds} array at the same index as the swapchain in the {@code pSwapchains} array. If this presentId is non-zero, then the application <b>can</b> later use this value to refer to that image presentation. A value of zero indicates that this presentation has no associated presentId. A non-zero presentId <b>must</b> be greater than any non-zero presentId passed previously by the application for the same swapchain.

        There is no requirement for any precise timing relationship between the presentation of the image to the user and the update of the presentId value, but implementations <b>should</b> make this as close as possible to the presentation of the first pixel in the new image to the user.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code swapchainCount} <b>must</b> be the same value as ##VkPresentInfoKHR{@code ::swapchainCount}, where this ##VkPresentIdKHR is in the {@code pNext} chain of the ##VkPresentInfoKHR structure</li>
            <li>Each {@code presentIds} entry <b>must</b> be greater than any previous {@code presentIds} entry passed for the associated {@code pSwapchains} entry</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PRESENT_ID_KHR</li>
            <li>If {@code pPresentIds} is not {@code NULL}, {@code pPresentIds} <b>must</b> be a valid pointer to an array of {@code swapchainCount} {@code uint64_t} values</li>
            <li>{@code swapchainCount} <b>must</b> be greater than 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PRESENT_ID_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pPresentIds", optional = true)..uint32_t("swapchainCount", "the number of swapchains being presented to the {@code vkQueuePresentKHR} command.")
    nullable..uint64_t.const.p("pPresentIds", "{@code NULL} or a pointer to an array of {@code uint64_t} with {@code swapchainCount} entries. If not {@code NULL}, each non-zero value in {@code pPresentIds} specifies the present id to be associated with the presentation of the swapchain with the same index in the #QueuePresentKHR() call.")
}

val VkPhysicalDevicePresentIdFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDevicePresentIdFeaturesKHR") {
    documentation =
        """
        Structure indicating support for present id.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePresentIdFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePresentIdFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("presentId", "indicates that the implementation supports specifying present ID values in the ##VkPresentIdKHR extension to the ##VkPresentInfoKHR struct.")
}

val VkPhysicalDevicePrivateDataFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePrivateDataFeaturesEXT", alias = VkPhysicalDevicePrivateDataFeatures) {
    documentation = "See ##VkPhysicalDevicePrivateDataFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("privateData", "")
}

val VkDevicePrivateDataCreateInfoEXT = struct(Module.VULKAN, "VkDevicePrivateDataCreateInfoEXT", alias = VkDevicePrivateDataCreateInfo) {
    documentation = "See ##VkDevicePrivateDataCreateInfo."

    Expression("#STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint32_t("privateDataSlotRequestCount", "")
}

val VkPrivateDataSlotCreateInfoEXT = struct(Module.VULKAN, "VkPrivateDataSlotCreateInfoEXT", alias = VkPrivateDataSlotCreateInfo) {
    documentation = "See ##VkPrivateDataSlotCreateInfo."

    Expression("#STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPrivateDataSlotCreateFlags("flags", "")
}

val VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT", alias = VkPhysicalDevicePipelineCreationCacheControlFeatures) {
    documentation = "See ##VkPhysicalDevicePipelineCreationCacheControlFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("pipelineCreationCacheControl", "")
}

val VkVideoEncodeInfoKHR = struct(Module.VULKAN, "VkVideoEncodeInfoKHR") {
    documentation =
        """
        Structure to chain codec-specific structures to.

        <h5>Description</h5>
        The coded size of the encode operation is specified in {@code codedExtent} of {@code srcPictureResource}.

        Multiple #CmdEncodeVideoKHR() commands <b>may</b> be recorded within a Vulkan Video Encode Context. The execution of each #CmdEncodeVideoKHR() command will result in generating codec-specific bitstream units. These bitstream units are generated consecutively into the bitstream buffer specified in {@code dstBuffer} of a ##VkVideoEncodeInfoKHR structure within the #CmdBeginVideoCodingKHR() command. The produced bitstream is the sum of all these bitstream units, including any padding between the bitstream units. Any bitstream padding <b>must</b> be filled with data compliant to the codec standard so as not to cause any syntax errors during decoding of the bitstream units with the padding included. The range of the bitstream buffer written <b>can</b> be queried via <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#queries-video-encode-feedback">video encode feedback queries</a>.

        <h5>Valid Usage</h5>
        <ul>
            <li>The bound video session <b>must</b> not be in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-session-uninitialized">uninitialized</a> state at the time the command is executed on the device</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264PictureInfoEXT or ##VkVideoEncodeH265PictureInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>{@code dstBuffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code srcPictureResource} <b>must</b> be a valid ##VkVideoPictureResourceInfoKHR structure</li>
            <li>If {@code pSetupReferenceSlot} is not {@code NULL}, {@code pSetupReferenceSlot} <b>must</b> be a valid pointer to a valid ##VkVideoReferenceSlotInfoKHR structure</li>
            <li>If {@code referenceSlotCount} is not 0, {@code pReferenceSlots} <b>must</b> be a valid pointer to an array of {@code referenceSlotCount} valid ##VkVideoReferenceSlotInfoKHR structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoPictureResourceInfoKHR, ##VkVideoReferenceSlotInfoKHR, #CmdEncodeVideoKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoEncodeH264PictureInfoEXT", "VkVideoEncodeH265PictureInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "a pointer to a structure extending this structure. A codec-specific extension structure <b>must</b> be chained to specify what bitstream unit to generate with this encode operation.")
    VkVideoEncodeFlagsKHR("flags", "reserved for future use.")
    VkBuffer("dstBuffer", "the destination video bitstream buffer to write the encoded bitstream to.")
    VkDeviceSize("dstBufferOffset", "the starting offset in bytes from the start of {@code dstBuffer} to write the encoded bitstream to. {@code dstBufferOffset}’s value <b>must</b> be aligned to ##VkVideoCapabilitiesKHR{@code ::minBitstreamBufferOffsetAlignment}, as reported by the implementation.")
    VkDeviceSize("dstBufferRange", "the maximum size in bytes of the encoded bitstream written to {@code dstBuffer}, starting from {@code dstBufferOffset}. {@code dstBufferRange}’s value <b>must</b> be aligned to ##VkVideoCapabilitiesKHR{@code ::minBitstreamBufferSizeAlignment}, as reported by the implementation.")
    VkVideoPictureResourceInfoKHR("srcPictureResource", "the Picture Resource of the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#encode-input-picture\">Input Picture</a> to be encoded by the operation.")
    nullable..VkVideoReferenceSlotInfoKHR.const.p("pSetupReferenceSlot", "a pointer to a ##VkVideoReferenceSlotInfoKHR structure used for generating a reconstructed reference slot and Picture Resource. {@code pSetupReferenceSlot→slotIndex} specifies the slot index number to use as a target for producing the Reconstructed (DPB) data. {@code pSetupReferenceSlot} <b>must</b> be one of the entries provided in ##VkVideoBeginCodingInfoKHR via the {@code pReferenceSlots} within the #CmdBeginVideoCodingKHR() command that established the Vulkan Video Encode Context for this command.")
    AutoSize("pReferenceSlots", optional = true)..uint32_t("referenceSlotCount", "the number of Reconstructed Reference Pictures that will be used when this encoding operation is executing.")
    VkVideoReferenceSlotInfoKHR.const.p("pReferenceSlots", "{@code NULL} or a pointer to an array of ##VkVideoReferenceSlotInfoKHR structures that will be used when this encoding operation is executing. Each entry in {@code pReferenceSlots} <b>must</b> be one of the entries provided in ##VkVideoBeginCodingInfoKHR via the {@code pReferenceSlots} within the #CmdBeginVideoCodingKHR() command that established the Vulkan Video Encode Context for this command.")
    uint32_t("precedingExternallyEncodedBytes", "the number of bytes externally encoded for insertion in the active video encode session overall bitstream prior to the bitstream that will be generated by the implementation for this instance of ##VkVideoEncodeInfoKHR. The value provided is used to update the implementation’s rate control algorithm for the rate control layer this instance of ##VkVideoEncodeInfoKHR belongs to, by accounting for the bitrate budget consumed by these externally encoded bytes. See ##VkVideoEncodeRateControlInfoKHR for additional information about encode rate control.")
}

val VkVideoEncodeCapabilitiesKHR = struct(Module.VULKAN, "VkVideoEncodeCapabilitiesKHR", mutable = false) {
    documentation =
        """
        Structure specifying encode capabilities.

        <h5>Description</h5>
        Implementations <b>must</b> include support for at least #VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR and #VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR in {@code supportedEncodeFeedbackFlags}.

        The input content and encode resolution (specified in ##VkVideoEncodeInfoKHR{@code ::codedExtent}) may not be aligned with the codec-specific coding block size. For example, the input content may be 1920x1080 and the coding block size may be 16x16 pixel blocks. In this example, the content is horizontally aligned with the coding block size, but not vertically aligned with the coding block size. Encoding of the last row of blocks may be impacted by contents of the input image in pixel rows 1081 to 1088 (the next vertical alignment with the coding block size). In general, to ensure efficient encoding for the last row/column of blocks, and/or to ensure consistent encoding results between repeated encoding of the same input content, these extra pixel rows/columns should be filled to known values up to the coding block size alignment before encoding operations are performed. Some implementations support performing auto-fill of unaligned pixels beyond a specific alignment for the purposes of encoding, which is reported in {@code encodeInputPictureGranularity}. For example, if an implementation reports 1x1 in {@code encodeInputPictureGranularity}, then the implementation will perform auto-fill for any unaligned pixels beyond the encode resolution up to the next coding block size. For a coding block size of 16x16, if the implementation reports 16x16 in {@code encodeInputPictureGranularity}, then it is the application’s responsibility to fill any unaligned pixels, if desired. When the application does not fill these unaligned pixels, there <b>may</b> be an impact on the encoding efficiency but there will be no effect on the validity of the generated bitstream. If the implementation reports 8x8 in {@code encodeInputPictureGranularity}, then for the 1920x1080 example, since the content is aligned to 8 pixels vertically, the implementation will auto-fill pixel rows 1081 to 1088 (up to the 16x16 coding block size in the example). The auto-fill value(s) are implementation-specific. The auto-fill value(s) are not written to the input image memory, but are used as part of the encoding operation on the input image.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoEncodeCapabilityFlagsKHR("flags", "a bitmask of {@code VkVideoEncodeCapabilityFlagBitsKHR} describing supported encoding features.")
    VkVideoEncodeRateControlModeFlagsKHR("rateControlModes", "a bitmask of {@code VkVideoEncodeRateControlModeFlagBitsKHR} indicating supported rate control modes.")
    uint32_t("maxRateControlLayers", "indicates the maximum number of rate control layers supported.")
    uint64_t("maxBitrate", "indicates the maximum supported bitrate.")
    uint32_t("maxQualityLevels", "indicates the number of discrete video encode quality levels supported. Implementations <b>must</b> report at least 1.")
    VkExtent2D("encodeInputPictureGranularity", "indicates the granularity at which <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#encode-input-picture\">encode input picture</a> data is encoded.")
    VkVideoEncodeFeedbackFlagsKHR("supportedEncodeFeedbackFlags", "a bitmask of {@code VkVideoEncodeFeedbackFlagBitsKHR} values specifying the supported flags for <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#queries-video-encode-feedback\">video encode feedback queries</a>.")
}

val VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = struct(Module.VULKAN, "VkQueryPoolVideoEncodeFeedbackCreateInfoKHR") {
    documentation =
        """
        Structure specifying enabled video encode feedback values.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR</li>
            <li>{@code encodeFeedbackFlags} <b>must</b> be a valid combination of {@code VkVideoEncodeFeedbackFlagBitsKHR} values</li>
            <li>{@code encodeFeedbackFlags} <b>must</b> not be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoEncodeFeedbackFlagsKHR("encodeFeedbackFlags", "a bitmask of {@code VkVideoEncodeFeedbackFlagBitsKHR} values specifying the set of enabled video encode feedback values captured by queries of the new pool.")
}

val VkVideoEncodeUsageInfoKHR = struct(Module.VULKAN, "VkVideoEncodeUsageInfoKHR") {
    documentation =
        """
        Structure specifying video encode usage information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR</li>
            <li>{@code videoUsageHints} <b>must</b> be a valid combination of {@code VkVideoEncodeUsageFlagBitsKHR} values</li>
            <li>{@code videoContentHints} <b>must</b> be a valid combination of {@code VkVideoEncodeContentFlagBitsKHR} values</li>
            <li>If {@code tuningMode} is not 0, {@code tuningMode} <b>must</b> be a valid {@code VkVideoEncodeTuningModeKHR} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoEncodeUsageFlagsKHR("videoUsageHints", "a bitmask of {@code VkVideoEncodeUsageFlagBitsKHR} specifying hints about the intended use of the video encode profile.")
    VkVideoEncodeContentFlagsKHR("videoContentHints", "a bitmask of {@code VkVideoEncodeContentFlagBitsKHR} specifying hints about the content to be encoded using the video encode profile.")
    VkVideoEncodeTuningModeKHR("tuningMode", "a {@code VkVideoEncodeTuningModeKHR} value specifying the tuning mode to use when encoding with the video profile.")
}

val VkVideoEncodeRateControlLayerInfoKHR = struct(Module.VULKAN, "VkVideoEncodeRateControlLayerInfoKHR") {
    documentation =
        """
        Structure to set encode per-layer rate control parameters.

        <h5>Description</h5>
        A codec-specific structure specifying additional per-layer rate control settings <b>must</b> be chained to ##VkVideoEncodeRateControlLayerInfoKHR. If multiple rate control layers are enabled (##VkVideoEncodeRateControlInfoKHR{@code ::layerCount} is greater than 1), then the chained codec-specific extension structure also identifies the specific video coding layer its parent ##VkVideoEncodeRateControlLayerInfoKHR applies to. If multiple rate control layers are enabled, the number of rate control layers <b>must</b> match the number of video coding layers. The specification for an encode codec-specific extension would describe how multiple video coding layers are enabled for the corresponding codec.

        Per-layer rate control settings for all enabled rate control layers <b>must</b> be initialized or re-initialized whenever stream rate control settings are provided via ##VkVideoEncodeRateControlInfoKHR. This is done by specifying settings for all enabled rate control layers in ##VkVideoEncodeRateControlInfoKHR{@code ::pLayers}.

        It is possible for an application to enable multiple video coding layers (via codec-specific extensions to encoding operations) while only enabling a single layer of rate control for the entire video stream. To achieve this, {@code layerCount} in ##VkVideoEncodeRateControlInfoKHR <b>must</b> be set to 1, and the single ##VkVideoEncodeRateControlLayerInfoKHR provided in {@code pLayers} would apply to all encoded segments of the video stream, regardless of which codec-defined video coding layer they belong to. In this case, the implementation decides bitrate distribution across video coding layers (if applicable to the specified stream rate control mode).

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264RateControlLayerInfoEXT or ##VkVideoEncodeH265RateControlLayerInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeRateControlInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoEncodeH264RateControlLayerInfoEXT", "VkVideoEncodeH265RateControlLayerInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "a pointer to a structure extending this structure.")
    uint64_t("averageBitrate", "the average bitrate in bits/second. Valid when rate control mode is #VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR or #VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR.")
    uint64_t("maxBitrate", "the peak bitrate in bits/second. Valid when rate control mode is #VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR.")
    uint32_t("frameRateNumerator", "the numerator of the frame rate. Valid when rate control mode is #VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR or #VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR.")
    uint32_t("frameRateDenominator", "the denominator of the frame rate. Valid when rate control mode is #VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR or #VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR.")
}

val VkVideoEncodeRateControlInfoKHR = struct(Module.VULKAN, "VkVideoEncodeRateControlInfoKHR") {
    documentation =
        """
        Structure to set encode stream rate control parameters.

        <h5>Description</h5>
        Including this structure in the {@code pNext} chain of ##VkVideoCodingControlInfoKHR and including #VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR in ##VkVideoCodingControlInfoKHR{@code ::flags} will define stream rate control settings for video encoding.

        Additional structures providing codec-specific rate control parameters <b>may</b> need to be included in the {@code pNext} chain of ##VkVideoCodingControlInfoKHR depending on the codec profile the bound video session was created with and the parameters specified in ##VkVideoEncodeRateControlInfoKHR (see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#video-coding-control">Video Coding Control</a>).

        To ensure that the video session is properly initialized with stream-level rate control settings, the application <b>must</b> call #CmdControlVideoCodingKHR() with stream-level rate control settings at least once in execution order before the first #CmdEncodeVideoKHR() command that is executed after video session reset. If not provided, default implementation-specific stream rate control settings will be used.

        Stream rate control settings <b>can</b> also be re-initialized during an active video encoding session. The re-initialization takes effect whenever the ##VkVideoEncodeRateControlInfoKHR structure is included in the {@code pNext} chain of the ##VkVideoCodingControlInfoKHR structure in the call to #CmdControlVideoCodingKHR(), and only impacts #CmdEncodeVideoKHR() operations that follow in execution order.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>If {@code rateControlMode} is not 0, {@code rateControlMode} <b>must</b> be a valid {@code VkVideoEncodeRateControlModeFlagBitsKHR} value</li>
            <li>If {@code layerCount} is not 0, {@code pLayers} <b>must</b> be a valid pointer to an array of {@code layerCount} valid ##VkVideoEncodeRateControlLayerInfoKHR structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoEncodeRateControlLayerInfoKHR
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoEncodeRateControlFlagsKHR("flags", "reserved for future use.")
    VkVideoEncodeRateControlModeFlagBitsKHR("rateControlMode", "a {@code VkVideoEncodeRateControlModeFlagBitsKHR} value specifying the encode stream rate control mode.")
    AutoSize("pLayers", optional = true)..uint32_t("layerCount", "specifies the number of rate control layers in the video encode stream.")
    VkVideoEncodeRateControlLayerInfoKHR.const.p("pLayers", "a pointer to an array of ##VkVideoEncodeRateControlLayerInfoKHR structures specifying the rate control configurations of {@code layerCount} rate control layers.")
    uint32_t("virtualBufferSizeInMs", "the leaky bucket model virtual buffer size in milliseconds, with respect to peak bitrate. Valid when rate control mode is #VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR or #VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR. For example, virtual buffer size is ({@code virtualBufferSizeInMs} × {@code maxBitrate} / 1000).")
    uint32_t("initialVirtualBufferSizeInMs", "the initial occupancy in milliseconds of the virtual buffer in the leaky bucket model. Valid when rate control mode is #VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR or #VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR.")
}

val VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = struct(Module.VULKAN, "VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR") {
    documentation =
        """
        Structure describing the video encode profile and quality level to query properties for.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pVideoProfile} <b>must</b> be a valid pointer to a valid ##VkVideoProfileInfoKHR structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkVideoProfileInfoKHR, #GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoProfileInfoKHR.const.p("pVideoProfile", "a pointer to a ##VkVideoProfileInfoKHR structure specifying the video profile to query the video encode quality level properties for.")
    uint32_t("qualityLevel", "the video encode quality level to query properties for.")
}

val VkVideoEncodeQualityLevelPropertiesKHR = struct(Module.VULKAN, "VkVideoEncodeQualityLevelPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing the video encode quality level properties.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264QualityLevelPropertiesEXT or ##VkVideoEncodeH265QualityLevelPropertiesEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    PointerSetter(
        "VkVideoEncodeH264QualityLevelPropertiesEXT", "VkVideoEncodeH265QualityLevelPropertiesEXT",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkVideoEncodeRateControlModeFlagBitsKHR("preferredRateControlMode", "a {@code VkVideoEncodeRateControlModeFlagBitsKHR} value indicating the preferred rate control mode to use with the video encode quality level.")
    uint32_t("preferredRateControlLayerCount", "indicates the preferred number of rate control layers to use with the quality level.")
}

val VkVideoEncodeQualityLevelInfoKHR = struct(Module.VULKAN, "VkVideoEncodeQualityLevelInfoKHR") {
    documentation =
        """
        Structure specifying used video encode quality level.

        <h5>Description</h5>
        This structure <b>can</b> be specified in the following places:

        <ul>
            <li>In the {@code pNext} chain of ##VkVideoSessionParametersCreateInfoKHR to specify the video encode quality level to use for a video session parameters object created for a video encode session. If no instance of this structure is included in the {@code pNext} chain of ##VkVideoSessionParametersCreateInfoKHR, then the video session parameters object is created with a video encode quality level of zero.</li>
            <li>In the {@code pNext} chain of ##VkVideoCodingControlInfoKHR to change the video encode quality level state of the bound video session.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("qualityLevel", "the used video encode quality level.")
}

val VkVideoEncodeSessionParametersGetInfoKHR = struct(Module.VULKAN, "VkVideoEncodeSessionParametersGetInfoKHR") {
    documentation =
        """
        Structure specifying parameters for retrieving encoded video session parameter data.

        <h5>Description</h5>
        Depending on the used video encode operation, additional codec-specific structures <b>may</b> need to be included in the {@code pNext} chain of this structure to identify the specific video session parameters to retrieve encoded parameter data for, as described in the corresponding sections.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264SessionParametersGetInfoEXT or ##VkVideoEncodeH265SessionParametersGetInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code videoSessionParameters} <b>must</b> be a valid {@code VkVideoSessionParametersKHR} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetEncodedVideoSessionParametersKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkVideoEncodeH264SessionParametersGetInfoEXT", "VkVideoEncodeH265SessionParametersGetInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkVideoSessionParametersKHR("videoSessionParameters", "the {@code VkVideoSessionParametersKHR} object to retrieve encoded parameter data from.")
}

val VkVideoEncodeSessionParametersFeedbackInfoKHR = struct(Module.VULKAN, "VkVideoEncodeSessionParametersFeedbackInfoKHR", mutable = false) {
    documentation =
        """
        Structure providing feedback about the requested video session parameters.

        <h5>Description</h5>
        Depending on the used video encode operation, additional codec-specific structures <b>may</b> need to be included in the {@code pNext} chain of this structure to capture feedback information about the requested parameter data, as described in the corresponding sections.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkVideoEncodeH264SessionParametersFeedbackInfoEXT or ##VkVideoEncodeH265SessionParametersFeedbackInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
        </ul>

        <h5>See Also</h5>
        #GetEncodedVideoSessionParametersKHR()
        """

    Expression("#STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    PointerSetter(
        "VkVideoEncodeH264SessionParametersFeedbackInfoEXT", "VkVideoEncodeH265SessionParametersFeedbackInfoEXT",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("hasOverrides", "indicates whether any of the requested parameter data were overridden by the implementation.")
}

val VkPhysicalDeviceDiagnosticsConfigFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceDiagnosticsConfigFeaturesNV") {
    documentation =
        """
        Structure describing the device-generated diagnostic configuration features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDiagnosticsConfigFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("diagnosticsConfig", "indicates whether the implementation supports the ability to configure diagnostic tools.")
}

val VkDeviceDiagnosticsConfigCreateInfoNV = struct(Module.VULKAN, "VkDeviceDiagnosticsConfigCreateInfoNV") {
    documentation =
        """
        Specify diagnostics config for a Vulkan device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkDeviceDiagnosticsConfigFlagBitsNV} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceDiagnosticsConfigFlagsNV("flags", "a bitmask of {@code VkDeviceDiagnosticsConfigFlagBitsNV} specifying additional parameters for configuring diagnostic tools.")
}

val VkQueryLowLatencySupportNV = struct(Module.VULKAN, "VkQueryLowLatencySupportNV") {
    documentation =
        """
        Structure used for NVIDIA Reflex Support.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV</li>
            <li>{@code pQueriedLowLatencyData} <b>must</b> be a pointer value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    opaque_p("pQueriedLowLatencyData", "used for NVIDIA Reflex Support.")
}

val VkExportMetalObjectCreateInfoEXT = struct(Module.VULKAN, "VkExportMetalObjectCreateInfoEXT") {
    documentation =
        """
        Structure that identifies the Metal objects that can be exported from Vulkan objects.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT</li>
            <li>If {@code exportObjectType} is not 0, {@code exportObjectType} <b>must</b> be a valid {@code VkExportMetalObjectTypeFlagBitsEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExportMetalObjectTypeFlagBitsEXT("exportObjectType", "a {@code VkExportMetalObjectTypeFlagBitsEXT} indicating the type of Metal object that the application may request to be exported from the Vulkan object.")
}

val VkExportMetalObjectsInfoEXT = struct(Module.VULKAN, "VkExportMetalObjectsInfoEXT") {
    documentation =
        """
        Structure whose pNext chain identifies Vulkan objects and corresponding Metal objects.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the {@code pNext} chain includes a ##VkExportMetalDeviceInfoEXT structure, the {@code VkInstance} <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkInstanceCreateInfo structure in the #CreateInstance() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalCommandQueueInfoEXT structure, the {@code VkInstance} <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkInstanceCreateInfo structure in the #CreateInstance() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalBufferInfoEXT structure, the {@code VkDeviceMemory} in its {@code memory} member <b>must</b> have been allocated with #EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkMemoryAllocateInfo structure in the #AllocateMemory() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, exactly one of its {@code image}, {@code imageView}, or {@code bufferView} members <b>must</b> not be #NULL_HANDLE</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and its {@code image} member is not #NULL_HANDLE, the {@code VkImage} in its {@code image} member <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkImageCreateInfo structure in the #CreateImage() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and its {@code imageView} member is not #NULL_HANDLE, the {@code VkImageView} in its {@code imageView} member <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkImageViewCreateInfo structure in the #CreateImageView() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and its {@code bufferView} member is not #NULL_HANDLE, the {@code VkBufferView} in its {@code bufferView} member <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkBufferViewCreateInfo structure in the #CreateBufferView() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and if either its {@code image} or {@code imageView} member is not #NULL_HANDLE, then {@code plane} <b>must</b> be #IMAGE_ASPECT_PLANE_0_BIT, #IMAGE_ASPECT_PLANE_1_BIT, or #IMAGE_ASPECT_PLANE_2_BIT</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and if the {@code VkImage} in its {@code image} member does not have a multi-planar format, then its {@code plane} member <b>must</b> be #IMAGE_ASPECT_PLANE_0_BIT</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and if the {@code VkImage} in its {@code image} member has a multi-planar format with only two planes, then its {@code plane} member <b>must</b> not be #IMAGE_ASPECT_PLANE_2_BIT</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and if the {@code VkImageView} in its {@code imageView} member does not have a multi-planar format, then its {@code plane} member <b>must</b> be #IMAGE_ASPECT_PLANE_0_BIT</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalTextureInfoEXT structure, and if the {@code VkImageView} in its {@code imageView} member has a multi-planar format with only two planes, then its {@code plane} member <b>must</b> not be #IMAGE_ASPECT_PLANE_2_BIT</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalIOSurfaceInfoEXT structure, the {@code VkImage} in its {@code image} member <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkImageCreateInfo structure in the #CreateImage() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalSharedEventInfoEXT structure, exactly one of its {@code semaphore} or {@code event} members <b>must</b> not be #NULL_HANDLE</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalSharedEventInfoEXT structure, and its {@code semaphore} member is not #NULL_HANDLE, the {@code VkSemaphore} in its {@code semaphore} member <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkSemaphoreCreateInfo structure in the #CreateSemaphore() command</li>
            <li>If the {@code pNext} chain includes a ##VkExportMetalSharedEventInfoEXT structure, and its {@code event} member is not #NULL_HANDLE, the {@code VkEvent} in its {@code event} member <b>must</b> have been created with #EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT in the {@code exportObjectType} member of a ##VkExportMetalObjectCreateInfoEXT structure in the {@code pNext} chain of the ##VkEventCreateInfo structure in the #CreateEvent() command</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkExportMetalBufferInfoEXT, ##VkExportMetalCommandQueueInfoEXT, ##VkExportMetalDeviceInfoEXT, ##VkExportMetalIOSurfaceInfoEXT, ##VkExportMetalSharedEventInfoEXT, or ##VkExportMetalTextureInfoEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique, with the exception of structures of type ##VkExportMetalBufferInfoEXT, ##VkExportMetalCommandQueueInfoEXT, ##VkExportMetalIOSurfaceInfoEXT, ##VkExportMetalSharedEventInfoEXT, or ##VkExportMetalTextureInfoEXT</li>
        </ul>

        <h5>See Also</h5>
        #ExportMetalObjectsEXT()
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkExportMetalBufferInfoEXT", "VkExportMetalCommandQueueInfoEXT", "VkExportMetalDeviceInfoEXT", "VkExportMetalIOSurfaceInfoEXT", "VkExportMetalSharedEventInfoEXT", "VkExportMetalTextureInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
}

val VkExportMetalDeviceInfoEXT = struct(Module.VULKAN, "VkExportMetalDeviceInfoEXT") {
    documentation =
        """
        Structure that identifies a VkDevice object and corresponding Metal MTLDevice object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    MTLDevice_id("mtlDevice", "the Metal {@code id&lt;MTLDevice&gt;} object underlying the {@code VkPhysicalDevice} associated with the {@code VkDevice} object identified in the call. The implementation will return the {@code MTLDevice} in this member, or it will return {@code NULL} if no {@code MTLDevice} could be found underlying the {@code VkPhysicalDevice} object.")
}

val VkExportMetalCommandQueueInfoEXT = struct(Module.VULKAN, "VkExportMetalCommandQueueInfoEXT") {
    documentation =
        """
        Structure that identifies a VkQueue object and corresponding Metal MTLCommandQueue object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT</li>
            <li>{@code queue} <b>must</b> be a valid {@code VkQueue} handle</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkQueue("queue", "a {@code VkQueue}.")
    MTLCommandQueue_id("mtlCommandQueue", "the Metal {@code id&lt;MTLCommandQueue&gt;} object underlying the {@code VkQueue} object in {@code queue}. The implementation will return the {@code MTLCommandQueue} in this member, or it will return {@code NULL} if no {@code MTLCommandQueue} could be found underlying the {@code VkQueue} object.")
}

val VkExportMetalBufferInfoEXT = struct(Module.VULKAN, "VkExportMetalBufferInfoEXT") {
    documentation =
        """
        Structure that identifies a VkDeviceMemory object and corresponding Metal MTLBuffer object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceMemory("memory", "a {@code VkDeviceMemory}.")
    MTLBuffer_id("mtlBuffer", "the Metal {@code id&lt;MTLBuffer&gt;} object underlying the {@code VkDeviceMemory} object in {@code memory}. The implementation will return the {@code MTLBuffer} in this member, or it will return {@code NULL} if no {@code MTLBuffer} could be found underlying the {@code VkDeviceMemory} object.")
}

val VkImportMetalBufferInfoEXT = struct(Module.VULKAN, "VkImportMetalBufferInfoEXT") {
    documentation =
        """
        Structure that identifies a Metal MTLBuffer object to use when creating a VkDeviceMemory object.

        <h5>Description</h5>
        The app <b>must</b> ensure that the configuration of the {@code id&lt;MTLBuffer&gt;} object is compatible with the configuration of the {@code VkDeviceMemory}. Failure to do so results in undefined behavior.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    MTLBuffer_id("mtlBuffer", "the Metal {@code id&lt;MTLBuffer&gt;} object that is to underlie the {@code VkDeviceMemory}.")
}

val VkExportMetalTextureInfoEXT = struct(Module.VULKAN, "VkExportMetalTextureInfoEXT") {
    documentation =
        """
        Structure that identifies a VkImage, VkImageView, or VkBufferView object and corresponding Metal MTLTexture object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT</li>
            <li>If {@code image} is not #NULL_HANDLE, {@code image} <b>must</b> be a valid {@code VkImage} handle</li>
            <li>If {@code imageView} is not #NULL_HANDLE, {@code imageView} <b>must</b> be a valid {@code VkImageView} handle</li>
            <li>If {@code bufferView} is not #NULL_HANDLE, {@code bufferView} <b>must</b> be a valid {@code VkBufferView} handle</li>
            <li>{@code plane} <b>must</b> be a valid {@code VkImageAspectFlagBits} value</li>
            <li>Each of {@code bufferView}, {@code image}, and {@code imageView} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImage("image", "#NULL_HANDLE or a {@code VkImage}.")
    VkImageView("imageView", "#NULL_HANDLE or a {@code VkImageView}.")
    VkBufferView("bufferView", "#NULL_HANDLE or a {@code VkBufferView}.")
    VkImageAspectFlagBits("plane", "indicates the plane of a multi-planar {@code VkImage} or {@code VkImageView}.")
    MTLTexture_id("mtlTexture", "the Metal {@code id&lt;MTLTexture&gt;} object underlying the {@code VkImage}, {@code VkImageView}, or {@code VkBufferView} object in {@code image}, {@code imageView}, or {@code bufferView}, respectively, at the plane indicated in {@code aspectMask}. The implementation will return the {@code MTLTexture} in this member, or it will return {@code NULL} if no {@code MTLTexture} could be found underlying the {@code VkImage}, {@code VkImageView}, or {@code VkBufferView} object, at the plane indicated in {@code aspectMask}.")
}

val VkImportMetalTextureInfoEXT = struct(Module.VULKAN, "VkImportMetalTextureInfoEXT") {
    documentation =
        """
        Structure that identifies Metal MTLTexture objects to use when creating a VkImage.

        <h5>Description</h5>
        The {@code pNext} chain <b>must</b> include one ##VkImportMetalTextureInfoEXT structure for each plane in the {@code VkImage}. The app <b>must</b> ensure that the configuration of the Metal {@code id&lt;MTLTexture&gt;} objects are compatible with the configuration of the {@code VkImage}. Failure to do so results in undefined behavior.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT</li>
            <li>{@code plane} <b>must</b> be a valid {@code VkImageAspectFlagBits} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageAspectFlagBits("plane", "indicates the plane of the {@code VkImage} that the {@code id&lt;MTLTexture&gt;} object should be attached to.")
    MTLTexture_id("mtlTexture", "a the Metal {@code id&lt;MTLTexture&gt;} object that is to underlie the {@code VkImage} plane.")
}

val VkExportMetalIOSurfaceInfoEXT = struct(Module.VULKAN, "VkExportMetalIOSurfaceInfoEXT") {
    documentation =
        """
        Structure that identifies a VkImage object and corresponding Metal IOSurfaceRef object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT</li>
            <li>{@code image} <b>must</b> be a valid {@code VkImage} handle</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImage("image", "a {@code VkImage}.")
    IOSurfaceRef("ioSurface", "the Metal {@code IOSurfaceRef} object underlying the {@code VkImage} object in {@code image}. The implementation will return the {@code IOSurfaceRef} in this member, or it will return {@code NULL} if no {@code IOSurfaceRef} could be found underlying the {@code VkImage} object.")
}

val VkImportMetalIOSurfaceInfoEXT = struct(Module.VULKAN, "VkImportMetalIOSurfaceInfoEXT") {
    documentation =
        """
        Structure that identifies a VkImage object and corresponding Metal IOSurfaceRef object to use.

        <h5>Description</h5>
        If {@code ioSurface} is not #NULL_HANDLE, it will be used to underlie the {@code VkImage}. If {@code ioSurface} is #NULL_HANDLE, the implementation will create a new {@code IOSurface} to underlie the {@code VkImage}.

        If provided, the app <b>must</b> ensure that the configuration of the {@code IOSurfaceRef} object is compatible with the configuration of the {@code VkImage}. Failure to do so results in undefined behavior.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    IOSurfaceRef("ioSurface", "#NULL_HANDLE or the Metal {@code IOSurfaceRef} object that is to underlie the {@code VkImage}.")
}

val VkExportMetalSharedEventInfoEXT = struct(Module.VULKAN, "VkExportMetalSharedEventInfoEXT") {
    documentation =
        """
        Structure that identifies a VkSemaphore or VkEvent object and corresponding Metal MTLSharedEvent object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT</li>
            <li>If {@code semaphore} is not #NULL_HANDLE, {@code semaphore} <b>must</b> be a valid {@code VkSemaphore} handle</li>
            <li>If {@code event} is not #NULL_HANDLE, {@code event} <b>must</b> be a valid {@code VkEvent} handle</li>
            <li>Both of {@code event}, and {@code semaphore} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSemaphore("semaphore", "#NULL_HANDLE or a {@code VkSemaphore}.")
    VkEvent("event", "#NULL_HANDLE or a {@code VkEvent}.")
    MTLSharedEvent_id("mtlSharedEvent", "the Metal {@code id&lt;MTLSharedEvent&gt;} object underlying the {@code VkSemaphore} or {@code VkEvent} object in {@code semaphore} or {@code event}, respectively. The implementation will return the {@code MTLSharedEvent} in this member, or it will return {@code NULL} if no {@code MTLSharedEvent} could be found underlying the {@code VkSemaphore} or {@code VkEvent} object.")
}

val VkImportMetalSharedEventInfoEXT = struct(Module.VULKAN, "VkImportMetalSharedEventInfoEXT") {
    documentation =
        """
        Structure that identifies a VkSemaphore or VkEvent object and corresponding Metal Shared Event object to use.

        <h5>Description</h5>
        If the {@code pNext} chain of the ##VkSemaphoreCreateInfo structure includes both ##VkImportMetalSharedEventInfoEXT and ##VkSemaphoreTypeCreateInfo, the {@code signaledValue} property of the imported {@code id&lt;MTLSharedEvent&gt;} object will be set to {@code initialValue} of ##VkSemaphoreTypeCreateInfo.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    MTLSharedEvent_id("mtlSharedEvent", "the Metal {@code id&lt;MTLSharedEvent&gt;} object that is to underlie the {@code VkSemaphore} or {@code VkEvent}.")
}

val VkMemoryBarrier2KHR = struct(Module.VULKAN, "VkMemoryBarrier2KHR", alias = VkMemoryBarrier2) {
    documentation = "See ##VkMemoryBarrier2."

    Expression("#STRUCTURE_TYPE_MEMORY_BARRIER_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPipelineStageFlags2("srcStageMask", "")
    VkAccessFlags2("srcAccessMask", "")
    VkPipelineStageFlags2("dstStageMask", "")
    VkAccessFlags2("dstAccessMask", "")
}

val VkBufferMemoryBarrier2KHR = struct(Module.VULKAN, "VkBufferMemoryBarrier2KHR", alias = VkBufferMemoryBarrier2) {
    documentation = "See ##VkBufferMemoryBarrier2."

    Expression("#STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPipelineStageFlags2("srcStageMask", "")
    VkAccessFlags2("srcAccessMask", "")
    VkPipelineStageFlags2("dstStageMask", "")
    VkAccessFlags2("dstAccessMask", "")
    uint32_t("srcQueueFamilyIndex", "")
    uint32_t("dstQueueFamilyIndex", "")
    VkBuffer("buffer", "")
    VkDeviceSize("offset", "")
    VkDeviceSize("size", "")
}

val VkImageMemoryBarrier2KHR = struct(Module.VULKAN, "VkImageMemoryBarrier2KHR", alias = VkImageMemoryBarrier2) {
    documentation = "See ##VkImageMemoryBarrier2."

    Expression("#STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPipelineStageFlags2("srcStageMask", "")
    VkAccessFlags2("srcAccessMask", "")
    VkPipelineStageFlags2("dstStageMask", "")
    VkAccessFlags2("dstAccessMask", "")
    VkImageLayout("oldLayout", "")
    VkImageLayout("newLayout", "")
    uint32_t("srcQueueFamilyIndex", "")
    uint32_t("dstQueueFamilyIndex", "")
    VkImage("image", "")
    VkImageSubresourceRange("subresourceRange", "")
}

val VkDependencyInfoKHR = struct(Module.VULKAN, "VkDependencyInfoKHR", alias = VkDependencyInfo) {
    documentation = "See ##VkDependencyInfo."

    Expression("#STRUCTURE_TYPE_DEPENDENCY_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkDependencyFlags("dependencyFlags", "")
    AutoSize("pMemoryBarriers", optional = true)..uint32_t("memoryBarrierCount", "")
    VkMemoryBarrier2.const.p("pMemoryBarriers", "")
    AutoSize("pBufferMemoryBarriers", optional = true)..uint32_t("bufferMemoryBarrierCount", "")
    VkBufferMemoryBarrier2.const.p("pBufferMemoryBarriers", "")
    AutoSize("pImageMemoryBarriers", optional = true)..uint32_t("imageMemoryBarrierCount", "")
    VkImageMemoryBarrier2.const.p("pImageMemoryBarriers", "")
}

val VkSubmitInfo2KHR = struct(Module.VULKAN, "VkSubmitInfo2KHR", alias = VkSubmitInfo2) {
    documentation = "See ##VkSubmitInfo2."

    Expression("#STRUCTURE_TYPE_SUBMIT_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSubmitFlags("flags", "")
    AutoSize("pWaitSemaphoreInfos", optional = true)..uint32_t("waitSemaphoreInfoCount", "")
    VkSemaphoreSubmitInfo.const.p("pWaitSemaphoreInfos", "")
    AutoSize("pCommandBufferInfos", optional = true)..uint32_t("commandBufferInfoCount", "")
    VkCommandBufferSubmitInfo.const.p("pCommandBufferInfos", "")
    AutoSize("pSignalSemaphoreInfos", optional = true)..uint32_t("signalSemaphoreInfoCount", "")
    VkSemaphoreSubmitInfo.const.p("pSignalSemaphoreInfos", "")
}

val VkSemaphoreSubmitInfoKHR = struct(Module.VULKAN, "VkSemaphoreSubmitInfoKHR", alias = VkSemaphoreSubmitInfo) {
    documentation = "See ##VkSemaphoreSubmitInfo."

    Expression("#STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkSemaphore("semaphore", "")
    uint64_t("value", "")
    VkPipelineStageFlags2("stageMask", "")
    uint32_t("deviceIndex", "")
}

val VkCommandBufferSubmitInfoKHR = struct(Module.VULKAN, "VkCommandBufferSubmitInfoKHR", alias = VkCommandBufferSubmitInfo) {
    documentation = "See ##VkCommandBufferSubmitInfo."

    Expression("#STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkCommandBuffer("commandBuffer", "")
    uint32_t("deviceMask", "")
}

val VkPhysicalDeviceSynchronization2FeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceSynchronization2FeaturesKHR", alias = VkPhysicalDeviceSynchronization2Features) {
    documentation = "See ##VkPhysicalDeviceSynchronization2Features."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("synchronization2", "")
}

val VkQueueFamilyCheckpointProperties2NV = struct(Module.VULKAN, "VkQueueFamilyCheckpointProperties2NV", mutable = false) {
    documentation =
        """
        Return structure for queue family checkpoint information query.

        <h5>Description</h5>
        Additional queue family information can be queried by setting ##VkQueueFamilyProperties2{@code ::pNext} to point to a ##VkQueueFamilyCheckpointProperties2NV structure.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkPipelineStageFlags2("checkpointExecutionStageMask", "a mask indicating which pipeline stages the implementation can execute checkpoint markers in.")
}

val VkCheckpointData2NV = struct(Module.VULKAN, "VkCheckpointData2NV", mutable = false) {
    documentation =
        """
        Return structure for command buffer checkpoint data.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        The stages at which a checkpoint marker <b>can</b> be executed are implementation-defined and <b>can</b> be queried by calling #GetPhysicalDeviceQueueFamilyProperties2().

        <h5>See Also</h5>
        #GetQueueCheckpointData2NV()
        """

    Expression("#STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkPipelineStageFlags2("stage", "indicates a single pipeline stage which the checkpoint marker data refers to.")
    nullable..opaque_p("pCheckpointMarker", "contains the value of the last checkpoint marker executed in the stage that {@code stage} refers to.")
}

val VkPhysicalDeviceDescriptorBufferPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDescriptorBufferPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing descriptor buffer properties supported by an implementation.

        <h5>Description</h5>
        A descriptor binding with type #DESCRIPTOR_TYPE_MUTABLE_VALVE has a descriptor size which is implied by the descriptor types included in the ##VkMutableDescriptorTypeCreateInfoVALVE{@code ::pDescriptorTypes} list. The descriptor size is equal to the maximum size of any descriptor type included in the {@code pDescriptorTypes} list.

        As there is no way to request robust and non-robust descriptors separately, or specify robust/non-robust descriptors in the set layout, if <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-robustBufferAccess">{@code robustBufferAccess}</a> is enabled then robust descriptors are always used.

        If the ##VkPhysicalDeviceDescriptorBufferPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("combinedImageSamplerDescriptorSingleArray", "indicates that the implementation does not require an array of {@code VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER} descriptors to be written into a descriptor buffer as an array of image descriptors, immediately followed by an array of sampler descriptors.")
    VkBool32("bufferlessPushDescriptors", "indicates that the implementation does not require a buffer created with {@code VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT} to be bound when using push descriptors.")
    VkBool32("allowSamplerImageViewPostSubmitCreation", "indicates that the implementation does not restrict when the {@code VkSampler} or {@code VkImageView} objects used to retrieve descriptor data <b>can</b> be created in relation to command buffer submission. If this value is #FALSE, then the application <b>must</b> create any {@code VkSampler} or {@code VkImageView} objects whose descriptor data is accessed during the execution of a command buffer, before the #QueueSubmit() , or #QueueSubmit2(), call that submits that command buffer.")
    VkDeviceSize("descriptorBufferOffsetAlignment", "indicates the <b>required</b> alignment in bytes when setting offsets into the descriptor buffer.")
    uint32_t("maxDescriptorBufferBindings", "indicates the maximum sum total number of descriptor buffers and embedded immutable sampler sets that <b>can</b> be bound.")
    uint32_t("maxResourceDescriptorBufferBindings", "indicates the maximum number of resource descriptor buffers that <b>can</b> be bound.")
    uint32_t("maxSamplerDescriptorBufferBindings", "indicates the maximum number of sampler descriptor buffers that <b>can</b> be bound.")
    uint32_t("maxEmbeddedImmutableSamplerBindings", "indicates the maximum number of embedded immutable sampler sets that <b>can</b> be bound.")
    uint32_t("maxEmbeddedImmutableSamplers", "indicates the maximum number of unique immutable samplers in descriptor set layouts created with #DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT, and pipeline layouts created from them, which <b>can</b> simultaneously exist on a device.")
    size_t("bufferCaptureReplayDescriptorDataSize", "indicates the maximum size in bytes of the opaque data used for capture and replay with buffers.")
    size_t("imageCaptureReplayDescriptorDataSize", "indicates the maximum size in bytes of the opaque data used for capture and replay with images.")
    size_t("imageViewCaptureReplayDescriptorDataSize", "indicates the maximum size in bytes of the opaque data used for capture and replay with image views.")
    size_t("samplerCaptureReplayDescriptorDataSize", "indicates the maximum size in bytes of the opaque data used for capture and replay with samplers.")
    size_t("accelerationStructureCaptureReplayDescriptorDataSize", "indicates the maximum size in bytes of the opaque data used for capture and replay with acceleration structures.")
    size_t("samplerDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_SAMPLER descriptor.")
    size_t("combinedImageSamplerDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor.")
    size_t("sampledImageDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_SAMPLED_IMAGE descriptor.")
    size_t("storageImageDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_STORAGE_IMAGE descriptor.")
    size_t("uniformTexelBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess\">{@code robustBufferAccess}</a> feature is not enabled.")
    size_t("robustUniformTexelBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess\">{@code robustBufferAccess}</a> feature is enabled.")
    size_t("storageTexelBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess\">{@code robustBufferAccess}</a> feature is not enabled.")
    size_t("robustStorageTexelBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess\">{@code robustBufferAccess}</a> feature is enabled.")
    size_t("uniformBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_UNIFORM_BUFFER descriptor.")
    size_t("robustUniformBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_UNIFORM_BUFFER descriptor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess\">{@code robustBufferAccess}</a> feature is enabled.")
    size_t("storageBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_STORAGE_BUFFER descriptor.")
    size_t("robustStorageBufferDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_STORAGE_BUFFER descriptor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-robustBufferAccess\">{@code robustBufferAccess}</a> feature is enabled.")
    size_t("inputAttachmentDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_INPUT_ATTACHMENT descriptor.")
    size_t("accelerationStructureDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR or #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV descriptor.")
    VkDeviceSize("maxSamplerDescriptorBufferRange", "indicates the maximum range in bytes from the address of a sampler descriptor buffer binding that is accessible to a shader.")
    VkDeviceSize("maxResourceDescriptorBufferRange", "indicates the maximum range in bytes from the address of a resource descriptor buffer binding that is accessible to a shader.")
    VkDeviceSize("samplerDescriptorBufferAddressSpaceSize", "indicates the total size in bytes of the address space available for descriptor buffers created with #BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT.")
    VkDeviceSize("resourceDescriptorBufferAddressSpaceSize", "indicates the total size in bytes of the address space available for descriptor buffers created with #BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT.")
    VkDeviceSize("descriptorBufferAddressSpaceSize", "indicates the total size in bytes of the address space available for descriptor buffers created with both #BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT and #BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT.")
}

val VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing descriptor buffer density map properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    size_t("combinedImageSamplerDensityMapDescriptorSize", "indicates the size in bytes of a #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor when creating the descriptor with #SAMPLER_CREATE_SUBSAMPLED_BIT_EXT set.")
}

val VkPhysicalDeviceDescriptorBufferFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDescriptorBufferFeaturesEXT") {
    documentation =
        """
        Structure describing the descriptor buffer features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDescriptorBufferFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDescriptorBufferFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("descriptorBuffer", "indicates that the implementation supports putting shader-accessible descriptors directly in memory.")
    VkBool32("descriptorBufferCaptureReplay", "indicates that the implementation supports capture and replay when using descriptor buffers. If this is #TRUE, all resources created with #BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, #IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, #IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, #SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, or #ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT <b>must</b> be created before resources of the same types without those flags.")
    VkBool32("descriptorBufferImageLayoutIgnored", "indicates that the implementation will ignore {@code imageLayout} in ##VkDescriptorImageInfo when calling #GetDescriptorEXT().")
    VkBool32("descriptorBufferPushDescriptors", "indicates that the implementation supports using push descriptors with descriptor buffers.")
}

val VkDescriptorAddressInfoEXT = struct(Module.VULKAN, "VkDescriptorAddressInfoEXT") {
    documentation =
        """
        Structure specifying descriptor buffer address info.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code address} <b>must</b> not be zero</li>
            <li>If {@code address} is zero, {@code range} <b>must</b> be #WHOLE_SIZE</li>
            <li>If {@code address} is not zero, {@code range} <b>must</b> not be #WHOLE_SIZE</li>
            <li>If {@code address} is not zero, {@code address} <b>must</b> be a valid device address at an offset within a {@code VkBuffer}</li>
            <li>{@code range} <b>must</b> be less than or equal to the size of the buffer containing {@code address} minus the offset of {@code address} from the base address of the buffer</li>
            <li>{@code range} <b>must</b> not be zero</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code format} <b>must</b> be a valid {@code VkFormat} value</li>
        </ul>

        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is enabled, {@code address} <b>can</b> be zero. Loads from a null descriptor return zero values and stores and atomics to a null descriptor are discarded.

        <h5>See Also</h5>
        ##VkDescriptorDataEXT
        """

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceAddress("address", "either 0 or a device address at an offset in a buffer, where the base address can be queried from #GetBufferDeviceAddress().")
    VkDeviceSize("range", "the size in bytes of the buffer or buffer view used by the descriptor.")
    VkFormat("format", "the format of the data elements in the buffer view and is ignored for buffers.")
}

val VkDescriptorBufferBindingInfoEXT = struct(Module.VULKAN, "VkDescriptorBufferBindingInfoEXT") {
    documentation =
        """
        Structure specifying descriptor buffer binding information.

        <h5>Description</h5>
        If a ##VkPipelineCreateFlags2CreateInfoKHR structure is present in the {@code pNext} chain, ##VkPipelineCreateFlags2CreateInfoKHR{@code ::flags} from that structure is used instead of {@code flags} from this structure.

        <h5>Valid Usage</h5>
        <ul>
            <li>If <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-bufferlessPushDescriptors">##VkPhysicalDeviceDescriptorBufferPropertiesEXT{@code ::bufferlessPushDescriptors}</a> is #FALSE, and {@code usage} contains #BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT, then the {@code pNext} chain <b>must</b> include a ##VkDescriptorBufferBindingPushDescriptorBufferHandleEXT structure</li>
            <li>{@code address} <b>must</b> be aligned to ##VkPhysicalDeviceDescriptorBufferPropertiesEXT{@code ::descriptorBufferOffsetAlignment}</li>
            <li>If {@code usage} includes #BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT, {@code address} <b>must</b> be an address within a valid buffer that was created with #BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT</li>
            <li>If {@code usage} includes #BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT, {@code address} <b>must</b> be an address within a valid buffer that was created with #BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT</li>
            <li>If {@code usage} includes #BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT, {@code address} <b>must</b> be an address within a valid buffer that was created with #BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT</li>
            <li>Each {@code pNext} member of any structure (including this one) in the {@code pNext} chain <b>must</b> be either {@code NULL} or a pointer to a valid instance of ##VkBufferUsageFlags2CreateInfoKHR or ##VkDescriptorBufferBindingPushDescriptorBufferHandleEXT</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code usage} <b>must</b> be a valid combination of {@code VkBufferUsageFlagBits} values</li>
            <li>{@code usage} <b>must</b> not be 0</li>
        </ul>

        <h5>See Also</h5>
        #CmdBindDescriptorBuffersEXT()
        """

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkBufferUsageFlags2CreateInfoKHR", "VkDescriptorBufferBindingPushDescriptorBufferHandleEXT",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceAddress("address", "a {@code VkDeviceAddress} specifying the device address defining the descriptor buffer to be bound.")
    VkBufferUsageFlags("usage", "a bitmask of {@code VkBufferUsageFlagBits} specifying the ##VkBufferCreateInfo{@code ::usage} for the buffer from which {@code address} was queried.")
}

val VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = struct(Module.VULKAN, "VkDescriptorBufferBindingPushDescriptorBufferHandleEXT") {
    documentation =
        """
        Structure specifying push descriptor buffer binding information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT</li>
            <li>{@code buffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBuffer("buffer", "")
}

val VkDescriptorDataEXT = union(Module.VULKAN, "VkDescriptorDataEXT") {
    documentation =
        """
        Structure specifying descriptor data.

        <h5>Description</h5>
        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is enabled, {@code pSampledImage}, {@code pStorageImage}, {@code pUniformTexelBuffer}, {@code pStorageTexelBuffer}, {@code pUniformBuffer}, and {@code pStorageBuffer} <b>can</b> each be {@code NULL}. Loads from a null descriptor return zero values and stores and atomics to a null descriptor are discarded.

        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is enabled, {@code accelerationStructure} <b>can</b> be 0. A null acceleration structure descriptor results in the miss shader being invoked.

        <h5>Valid Usage</h5>
        <ul>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_UNIFORM_BUFFER, and {@code pUniformBuffer→address} is the address of a non-sparse buffer, then that buffer <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_STORAGE_BUFFER, and {@code pStorageBuffer→address} is the address of a non-sparse buffer, then that buffer <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, and {@code pUniformTexelBuffer→address} is the address of a non-sparse buffer, then that buffer <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, and {@code pStorageTexelBuffer→address} is the address of a non-sparse buffer, then that buffer <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code pCombinedImageSampler→imageView} <b>must</b> not be #NULL_HANDLE</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_SAMPLED_IMAGE, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code pSampledImage} <b>must</b> not be {@code NULL} and {@code pSampledImage→imageView} <b>must</b> not be #NULL_HANDLE</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_STORAGE_IMAGE, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code pStorageImage} <b>must</b> not be {@code NULL} and {@code pStorageImage→imageView} <b>must</b> not be #NULL_HANDLE</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code pUniformTexelBuffer} <b>must</b> not be {@code NULL}</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code pStorageTexelBuffer} <b>must</b> not be {@code NULL}</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_UNIFORM_BUFFER, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code pUniformBuffer} <b>must</b> not be {@code NULL}</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_STORAGE_BUFFER, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code pStorageBuffer} <b>must</b> not be {@code NULL}</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code accelerationStructure} <b>must</b> not be 0</li>
            <li>If ##VkDescriptorGetInfoEXT:{@code type} is #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, and the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-nullDescriptor">{@code nullDescriptor}</a> feature is not enabled, {@code accelerationStructure} <b>must</b> not be 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkDescriptorAddressInfoEXT, ##VkDescriptorGetInfoEXT, ##VkDescriptorImageInfo
        """

    VkSampler.const.p("pSampler", "a pointer to a {@code VkSampler} handle specifying the parameters of a #DESCRIPTOR_TYPE_SAMPLER descriptor.")
    VkDescriptorImageInfo.const.p("pCombinedImageSampler", "a pointer to a ##VkDescriptorImageInfo structure specifying the parameters of a #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptor.")
    VkDescriptorImageInfo.const.p("pInputAttachmentImage", "a pointer to a ##VkDescriptorImageInfo structure specifying the parameters of a #DESCRIPTOR_TYPE_INPUT_ATTACHMENT descriptor.")
    nullable..VkDescriptorImageInfo.const.p("pSampledImage", "a pointer to a ##VkDescriptorImageInfo structure specifying the parameters of a #DESCRIPTOR_TYPE_SAMPLED_IMAGE descriptor.")
    nullable..VkDescriptorImageInfo.const.p("pStorageImage", "a pointer to a ##VkDescriptorImageInfo structure specifying the parameters of a #DESCRIPTOR_TYPE_STORAGE_IMAGE descriptor.")
    nullable..VkDescriptorAddressInfoEXT.const.p("pUniformTexelBuffer", "a pointer to a ##VkDescriptorAddressInfoEXT structure specifying the parameters of a #DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor.")
    nullable..VkDescriptorAddressInfoEXT.const.p("pStorageTexelBuffer", "a pointer to a ##VkDescriptorAddressInfoEXT structure specifying the parameters of a #DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor.")
    nullable..VkDescriptorAddressInfoEXT.const.p("pUniformBuffer", "a pointer to a ##VkDescriptorAddressInfoEXT structure specifying the parameters of a #DESCRIPTOR_TYPE_UNIFORM_BUFFER descriptor.")
    nullable..VkDescriptorAddressInfoEXT.const.p("pStorageBuffer", "a pointer to a ##VkDescriptorAddressInfoEXT structure specifying the parameters of a #DESCRIPTOR_TYPE_STORAGE_BUFFER descriptor.")
    VkDeviceAddress("accelerationStructure", "the address of a {@code VkAccelerationStructureKHR} specifying the parameters of a #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR descriptor , or a {@code VkAccelerationStructureNV} handle specifying the parameters of a #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV descriptor.")
}

val VkDescriptorGetInfoEXT = struct(Module.VULKAN, "VkDescriptorGetInfoEXT") {
    documentation =
        """
        Structure specifying parameters of descriptor to get.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code type} <b>must</b> not be #DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, #DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC or #DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the {@code pCombinedImageSampler→sampler} member of {@code data} <b>must</b> be a {@code VkSampler} created on {@code device}</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the {@code pCombinedImageSampler→imageView} member of {@code data} <b>must</b> be a {@code VkImageView} created on {@code device}, or #NULL_HANDLE</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the {@code pInputAttachmentImage→imageView} member of {@code data} <b>must</b> be a {@code VkImageView} created on {@code device}</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_SAMPLED_IMAGE, and if {@code pSampledImage} is not {@code NULL}, the {@code pSampledImage→imageView} member of {@code data} <b>must</b> be a {@code VkImageView} created on {@code device}, or #NULL_HANDLE</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_STORAGE_IMAGE, and if {@code pStorageImage} is not {@code NULL}, the {@code pStorageImage→imageView} member of {@code data} <b>must</b> be a {@code VkImageView} created on {@code device}, or #NULL_HANDLE</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, {@code pUniformTexelBuffer} is not {@code NULL} and {@code pUniformTexelBuffer→address} is not zero, {@code pUniformTexelBuffer→address} must be an address within a {@code VkBuffer} created on {@code device}</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, {@code pStorageTexelBuffer} is not {@code NULL} and {@code pStorageTexelBuffer→address} is not zero, {@code pStorageTexelBuffer→address} must be an address within a {@code VkBuffer} created on {@code device}</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_UNIFORM_BUFFER, {@code pUniformBuffer} is not {@code NULL} and {@code pUniformBuffer→address} is not zero, {@code pUniformBuffer→address} must be an address within a {@code VkBuffer} created on {@code device}</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_STORAGE_BUFFER, {@code pStorageBuffer} is not {@code NULL} and {@code pStorageBuffer→address} is not zero, {@code pStorageBuffer→address} must be an address within a {@code VkBuffer} created on {@code device}</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR and {@code accelerationStructure} is not 0, {@code accelerationStructure} <b>must</b> contain the address of a {@code VkAccelerationStructureKHR} created on {@code device}</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV and {@code accelerationStructure} is not 0, {@code accelerationStructure} <b>must</b> contain the handle of a {@code VkAccelerationStructureNV} created on {@code device}, returned by #GetAccelerationStructureHandleNV()</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkDescriptorType} value</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_SAMPLER, the {@code pSampler} member of {@code data} <b>must</b> be a valid pointer to a valid {@code VkSampler} handle</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the {@code pCombinedImageSampler} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorImageInfo structure</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the {@code pInputAttachmentImage} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorImageInfo structure</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_SAMPLED_IMAGE, and if {@code pSampledImage} is not {@code NULL}, the {@code pSampledImage} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorImageInfo structure</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_STORAGE_IMAGE, and if {@code pStorageImage} is not {@code NULL}, the {@code pStorageImage} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorImageInfo structure</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, and if {@code pUniformTexelBuffer} is not {@code NULL}, the {@code pUniformTexelBuffer} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorAddressInfoEXT structure</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, and if {@code pStorageTexelBuffer} is not {@code NULL}, the {@code pStorageTexelBuffer} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorAddressInfoEXT structure</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_UNIFORM_BUFFER, and if {@code pUniformBuffer} is not {@code NULL}, the {@code pUniformBuffer} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorAddressInfoEXT structure</li>
            <li>If {@code type} is #DESCRIPTOR_TYPE_STORAGE_BUFFER, and if {@code pStorageBuffer} is not {@code NULL}, the {@code pStorageBuffer} member of {@code data} <b>must</b> be a valid pointer to a valid ##VkDescriptorAddressInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkDescriptorDataEXT, #GetDescriptorEXT()
        """

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDescriptorType("type", "the type of descriptor to get.")
    VkDescriptorDataEXT("data", "a structure containing the information needed to get the descriptor.")
}

val VkBufferCaptureDescriptorDataInfoEXT = struct(Module.VULKAN, "VkBufferCaptureDescriptorDataInfoEXT") {
    documentation =
        """
        Structure specifying a buffer for descriptor capture.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code buffer} <b>must</b> have been created with #BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in ##VkBufferCreateInfo{@code ::flags}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code buffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetBufferOpaqueCaptureDescriptorDataEXT()
        """

    Expression("#STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBuffer("buffer", "the {@code VkBuffer} handle of the buffer to get opaque capture data for.")
}

val VkImageCaptureDescriptorDataInfoEXT = struct(Module.VULKAN, "VkImageCaptureDescriptorDataInfoEXT") {
    documentation =
        """
        Structure specifying an image for descriptor capture.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code image} <b>must</b> have been created with #IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in ##VkImageCreateInfo{@code ::flags}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code image} <b>must</b> be a valid {@code VkImage} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetImageOpaqueCaptureDescriptorDataEXT()
        """

    Expression("#STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImage("image", "the {@code VkImage} handle of the image to get opaque capture data for.")
}

val VkImageViewCaptureDescriptorDataInfoEXT = struct(Module.VULKAN, "VkImageViewCaptureDescriptorDataInfoEXT") {
    documentation =
        """
        Structure specifying an image view for descriptor capture.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code imageView} <b>must</b> have been created with #IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in ##VkImageViewCreateInfo{@code ::flags}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code imageView} <b>must</b> be a valid {@code VkImageView} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetImageViewOpaqueCaptureDescriptorDataEXT()
        """

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageView("imageView", "the {@code VkImageView} handle of the image view to get opaque capture data for.")
}

val VkSamplerCaptureDescriptorDataInfoEXT = struct(Module.VULKAN, "VkSamplerCaptureDescriptorDataInfoEXT") {
    documentation =
        """
        Structure specifying a sampler for descriptor capture.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code sampler} <b>must</b> have been created with #SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in ##VkSamplerCreateInfo{@code ::flags}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code sampler} <b>must</b> be a valid {@code VkSampler} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetSamplerOpaqueCaptureDescriptorDataEXT()
        """

    Expression("#STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSampler("sampler", "the {@code VkSampler} handle of the sampler to get opaque capture data for.")
}

val VkOpaqueCaptureDescriptorDataCreateInfoEXT = struct(Module.VULKAN, "VkOpaqueCaptureDescriptorDataCreateInfoEXT") {
    documentation =
        """
        Structure specifying opaque capture descriptor data.

        <h5>Description</h5>
        During replay, opaque descriptor capture data <b>can</b> be specified by adding a ##VkOpaqueCaptureDescriptorDataCreateInfoEXT structure to the relevant {@code pNext} chain of a ##VkBufferCreateInfo, ##VkImageCreateInfo, ##VkImageViewCreateInfo, ##VkSamplerCreateInfo, ##VkAccelerationStructureCreateInfoNV or ##VkAccelerationStructureCreateInfoKHR structure.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT</li>
            <li>{@code opaqueCaptureDescriptorData} <b>must</b> be a pointer value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    opaque_const_p("opaqueCaptureDescriptorData", "a pointer to a user-allocated buffer containing opaque capture data retrieved using #GetBufferOpaqueCaptureDescriptorDataEXT(), #GetImageOpaqueCaptureDescriptorDataEXT(), #GetImageViewOpaqueCaptureDescriptorDataEXT(), #GetSamplerOpaqueCaptureDescriptorDataEXT(), or #GetAccelerationStructureOpaqueCaptureDescriptorDataEXT().")
}

val VkAccelerationStructureCaptureDescriptorDataInfoEXT = struct(Module.VULKAN, "VkAccelerationStructureCaptureDescriptorDataInfoEXT") {
    documentation =
        """
        Structure specifying an acceleration structure for descriptor capture.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code accelerationStructure} is not #NULL_HANDLE then {@code accelerationStructure} <b>must</b> have been created with #ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in ##VkAccelerationStructureCreateInfoKHR{@code ::createFlags}</li>
            <li>If {@code accelerationStructureNV} is not #NULL_HANDLE then {@code accelerationStructureNV} <b>must</b> have been created with #ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in ##VkAccelerationStructureCreateInfoNV{@code ::info.flags}</li>
            <li>If {@code accelerationStructure} is not #NULL_HANDLE then {@code accelerationStructureNV} <b>must</b> be #NULL_HANDLE</li>
            <li>If {@code accelerationStructureNV} is not #NULL_HANDLE then {@code accelerationStructure} <b>must</b> be #NULL_HANDLE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>If {@code accelerationStructure} is not #NULL_HANDLE, {@code accelerationStructure} <b>must</b> be a valid {@code VkAccelerationStructureKHR} handle</li>
            <li>If {@code accelerationStructureNV} is not #NULL_HANDLE, {@code accelerationStructureNV} <b>must</b> be a valid {@code VkAccelerationStructureNV} handle</li>
            <li>Both of {@code accelerationStructure}, and {@code accelerationStructureNV} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #GetAccelerationStructureOpaqueCaptureDescriptorDataEXT()
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkAccelerationStructureKHR("accelerationStructure", "the {@code VkAccelerationStructureKHR} handle of the acceleration structure to get opaque capture data for.")
    VkAccelerationStructureNV("accelerationStructureNV", "the {@code VkAccelerationStructureNV} handle of the acceleration structure to get opaque capture data for.")
}

val VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT") {
    documentation =
        """
        Structure describing support for graphics pipeline libraries.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("graphicsPipelineLibrary", "indicates that the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#pipelines-library\">graphics pipeline libraries</a>.")
}

val VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT") {
    documentation =
        """
        Structure describing additional properties of graphics pipeline libraries.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("graphicsPipelineLibraryFastLinking", "indicates whether fast linking of graphics pipelines is supported. If it is #TRUE, creating a graphics pipeline entirely from pipeline libraries without #PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT is comparable in cost to recording a command in a command buffer.")
    VkBool32("graphicsPipelineLibraryIndependentInterpolationDecoration", "indicates whether {@code NoPerspective} and {@code Flat} interpolation decorations in the last vertex processing stage and the fragment shader are required to match when using graphics pipeline libraries. If it is #TRUE, the interpolation decorations do not need to match. If it is #FALSE, these decorations <b>must</b> either be present in both stages or neither stage in order for a given interface variable to match.")
}

val VkGraphicsPipelineLibraryCreateInfoEXT = struct(Module.VULKAN, "VkGraphicsPipelineLibraryCreateInfoEXT") {
    documentation =
        """
        Structure specifying the subsets of the graphics pipeline being compiled.

        <h5>Description</h5>
        If a ##VkGraphicsPipelineLibraryCreateInfoEXT structure is included in the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo, it specifies the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#pipelines-graphics-subsets">subsets of the graphics pipeline</a> being created, excluding any subsets from linked pipeline libraries. If the pipeline is created with pipeline libraries, state from those libraries is aggregated with said subset.

        If this structure is omitted, and either ##VkGraphicsPipelineCreateInfo{@code ::flags} includes #PIPELINE_CREATE_LIBRARY_BIT_KHR or the ##VkGraphicsPipelineCreateInfo{@code ::pNext} chain includes a ##VkPipelineLibraryCreateInfoKHR structure with a {@code libraryCount} greater than 0, it is as if {@code flags} is 0. Otherwise if this structure is omitted, it is as if {@code flags} includes all possible subsets of the graphics pipeline (i.e. a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#pipelines-graphics-subsets-complete">complete graphics pipeline</a>).

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkGraphicsPipelineLibraryFlagBitsEXT} values</li>
            <li>{@code flags} <b>must</b> not be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkGraphicsPipelineLibraryFlagsEXT("flags", "a bitmask of {@code VkGraphicsPipelineLibraryFlagBitsEXT} specifying the subsets of the graphics pipeline that are being compiled.")
}

val VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = struct(Module.VULKAN, "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD") {
    documentation =
        """
        Structure describing whether early and late fragment tests can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderEarlyAndLateFragmentTests", "indicates whether the implementation supports the {@code EarlyAndLateFragmentTestsAMD} {@code Execution} {@code Mode}.")
}

val VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR") {
    documentation =
        """
        Structure describing barycentric support in fragment shaders that can be supported by an implementation.

        <h5>Description</h5>
        See <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-barycentric">Barycentric Interpolation</a> for more information.

        If the ##VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("fragmentShaderBarycentric", "indicates that the implementation supports the {@code BaryCoordKHR} and {@code BaryCoordNoPerspKHR} SPIR-V fragment shader built-ins and supports the {@code PerVertexKHR} SPIR-V decoration on fragment shader input variables.")
}

val VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing fragment shader barycentric limits of an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkBool32("triStripVertexOrderIndependentOfProvokingVertex", "indicates that the implementation does not change its vertex numbering for triangle strip primitives when the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#vertexpostproc-flatshading\">provoking vertex mode</a> is #PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT, as shown in the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-barycentric-order-table-last-vertex\">last vertex table</a>.")
}

val VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR") {
    documentation =
        """
        Structure describing support for shader subgroup uniform control flow by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderSubgroupUniformControlFlow", "specifies whether the implementation supports the shader execution mode {@code SubgroupUniformControlFlowKHR}")
}

val VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR", alias = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) {
    documentation = "See ##VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderZeroInitializeWorkgroupMemory", "")
}

val VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV") {
    documentation =
        """
        Structure indicating support for fragment shading rate enums.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("fragmentShadingRateEnums", "indicates that the implementation supports specifying fragment shading rates using the {@code VkFragmentShadingRateNV} enumerated type.")
    VkBool32("supersampleFragmentShadingRates", "indicates that the implementation supports fragment shading rate enum values indicating more than one invocation per fragment.")
    VkBool32("noInvocationFragmentShadingRates", "indicates that the implementation supports a fragment shading rate enum value indicating that no fragment shaders should be invoked when that shading rate is used.")
}

val VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV") {
    documentation =
        """
        Structure describing fragment shading rate limits that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These properties are related to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-fragment-shading-rate">fragment shading rates</a>.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV</li>
            <li>{@code maxFragmentShadingRateInvocationCount} <b>must</b> be a valid {@code VkSampleCountFlagBits} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSampleCountFlagBits("maxFragmentShadingRateInvocationCount", "a {@code VkSampleCountFlagBits} value indicating the maximum number of fragment shader invocations per fragment supported in pipeline, primitive, and attachment fragment shading rates.")
}

val VkPipelineFragmentShadingRateEnumStateCreateInfoNV = struct(Module.VULKAN, "VkPipelineFragmentShadingRateEnumStateCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters controlling the fragment shading rate using rate enums.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkGraphicsPipelineCreateInfo includes a ##VkPipelineFragmentShadingRateEnumStateCreateInfoNV structure, then that structure includes parameters controlling the pipeline fragment shading rate.

        If this structure is not present, {@code shadingRateType} is considered to be equal to #FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV, {@code shadingRate} is considered to be equal to #FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV, and both elements of {@code combinerOps} are considered to be equal to #FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFragmentShadingRateTypeNV("shadingRateType", "specifies a {@code VkFragmentShadingRateTypeNV} value indicating whether fragment shading rates are specified using fragment sizes or {@code VkFragmentShadingRateNV} enums.")
    VkFragmentShadingRateNV("shadingRate", "specifies a {@code VkFragmentShadingRateNV} value indicating the pipeline fragment shading rate.")
    VkFragmentShadingRateCombinerOpKHR("combinerOps", "specifies {@code VkFragmentShadingRateCombinerOpKHR} values determining how the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-pipeline\">pipeline</a>, <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-primitive\">primitive</a>, and <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-attachment\">attachment shading rates</a> are <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-combining\">combined</a> for fragments generated by drawing commands using the created pipeline.")[2]
}

val VkAccelerationStructureGeometryMotionTrianglesDataNV = struct(Module.VULKAN, "VkAccelerationStructureGeometryMotionTrianglesDataNV") {
    documentation =
        """
        Structure specifying vertex motion in a bottom-level acceleration structure.

        <h5>Description</h5>
        If ##VkAccelerationStructureGeometryMotionTrianglesDataNV is included in the {@code pNext} chain of a ##VkAccelerationStructureGeometryTrianglesDataKHR structure, the basic vertex positions are used for the position of the triangles in the geometry at time 0.0 and the {@code vertexData} in ##VkAccelerationStructureGeometryMotionTrianglesDataNV is used for the vertex positions at time 1.0, with positions linearly interpolated at intermediate times.

        Indexing for ##VkAccelerationStructureGeometryMotionTrianglesDataNV {@code vertexData} is equivalent to the basic vertex position data.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstKHR
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceOrHostAddressConstKHR("vertexData", "a pointer to vertex data for this geometry at time 1.0")
}

val VkAccelerationStructureMotionInfoNV = struct(Module.VULKAN, "VkAccelerationStructureMotionInfoNV") {
    documentation =
        """
        Structure specifying the parameters of a newly created acceleration structure object.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("maxInstances", "the maximum number of instances that <b>may</b> be used in the motion top-level acceleration structure.")
    VkAccelerationStructureMotionInfoFlagsNV("flags", "0 and reserved for future use.")
}

val VkAccelerationStructureMatrixMotionInstanceNV = struct(Module.VULKAN, "VkAccelerationStructureMatrixMotionInstanceNV") {
    documentation =
        """
        Structure specifying a single acceleration structure matrix motion instance for building into an acceleration structure geometry.

        <h5>Description</h5>
        The C language specification does not define the ordering of bit-fields, but in practice, this struct produces the correct layout with existing compilers. The intended bit pattern is for the following:

        <ul>
            <li>
                {@code instanceCustomIndex} and {@code mask} occupy the same memory as if a single {@code uint32_t} was specified in their place
                <ul>
                    <li>{@code instanceCustomIndex} occupies the 24 least significant bits of that memory</li>
                    <li>{@code mask} occupies the 8 most significant bits of that memory</li>
                </ul>
            </li>
            <li>
                {@code instanceShaderBindingTableRecordOffset} and {@code flags} occupy the same memory as if a single {@code uint32_t} was specified in their place
                <ul>
                    <li>{@code instanceShaderBindingTableRecordOffset} occupies the 24 least significant bits of that memory</li>
                    <li>{@code flags} occupies the 8 most significant bits of that memory</li>
                </ul>
            </li>
        </ul>

        If a compiler produces code that diverges from that pattern, applications <b>must</b> employ another method to set values according to the correct bit pattern.

        The transform for a matrix motion instance at a point in time is derived by component-wise linear interpolation of the two transforms. That is, for a {@code time} in [0,1] the resulting transform is

        <dl>
            <dd><code>transformT0 × (1 - time) + transformT1 × time</code></dd>
        </dl>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkGeometryInstanceFlagBitsKHR} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureMotionInstanceDataNV, ##VkTransformMatrixKHR
        """

    VkTransformMatrixKHR("transformT0", "a ##VkTransformMatrixKHR structure describing a transformation to be applied to the acceleration structure at time 0.")
    VkTransformMatrixKHR("transformT1", "a ##VkTransformMatrixKHR structure describing a transformation to be applied to the acceleration structure at time 1.")
    uint32_t("instanceCustomIndex", "a 24-bit user-specified index value accessible to ray shaders in the {@code InstanceCustomIndexKHR} built-in.", bits = 24)
    uint32_t("mask", "an 8-bit visibility mask for the geometry. The instance <b>may</b> only be hit if {@code Cull Mask &amp; instance.mask != 0}", bits = 8)
    uint32_t("instanceShaderBindingTableRecordOffset", "a 24-bit offset used in calculating the hit shader binding table index.", bits = 24)
    VkGeometryInstanceFlagsKHR("flags", "an 8-bit mask of {@code VkGeometryInstanceFlagBitsKHR} values to apply to this instance.", bits = 8)
    uint64_t("accelerationStructureReference", """either:

        <ul>
            <li>a device address containing the value obtained from #GetAccelerationStructureDeviceAddressKHR() or #GetAccelerationStructureHandleNV() (used by device operations which reference acceleration structures) or,</li>
            <li>a {@code VkAccelerationStructureKHR} object (used by host operations which reference acceleration structures).</li>
        </ul>""")
}

val VkSRTDataNV = struct(Module.VULKAN, "VkSRTDataNV") {
    documentation =
        """
        Structure specifying a transform in SRT decomposition.

        <h5>Description</h5>
        This transform decomposition consists of three elements. The first is a matrix S, consisting of a scale, shear, and translation, usually used to define the pivot point of the following rotation. This matrix is constructed from the parameters above by:

        S =
<table>
    <tr><td>sx</td><td>a</td><td>b</td><td>pvx</td></tr>
    <tr><td>0</td><td>sy</td><td>c</td><td>pvy</td></tr>
    <tr><td>0</td><td>0</td><td>sz</td><td>pvz</td></tr>
</table>

        The rotation quaternion is defined as:

        <dl>
            <dd><code>R = [ qx, qy, qz, qw ]</code></dd>
        </dl>

        This is a rotation around a conceptual normalized axis <code>[ ax, ay, az ]</code> of amount {@code theta} such that:

        <dl>
            <dd><code>[ qx, qy, qz ] = sin(theta/2) × [ ax, ay, az ]</code></dd>
        </dl>

        and

        <dl>
            <dd><code>qw = cos(theta/2)</code></dd>
        </dl>

        Finally, the transform has a translation T constructed from the parameters above by:

        T =
<table>
    <tr><td>1</td><td>0</td><td>0</td><td>tx</td></tr>
    <tr><td>0</td><td>1</td><td>0</td><td>ty</td></tr>
    <tr><td>0</td><td>0</td><td>1</td><td>tz</td></tr>
</table>

        The effective derived transform is then given by

        <dl>
            <dd><code>T × R × S</code></dd>
        </dl>

        <h5>See Also</h5>
        ##VkAccelerationStructureSRTMotionInstanceNV
        """

    float("sx", "the x component of the scale of the transform")
    float("a", "one component of the shear for the transform")
    float("b", "one component of the shear for the transform")
    float("pvx", "the x component of the pivot point of the transform")
    float("sy", "the y component of the scale of the transform")
    float("c", "one component of the shear for the transform")
    float("pvy", "the y component of the pivot point of the transform")
    float("sz", "the z component of the scale of the transform")
    float("pvz", "the z component of the pivot point of the transform")
    float("qx", "the x component of the rotation quaternion")
    float("qy", "the y component of the rotation quaternion")
    float("qz", "the z component of the rotation quaternion")
    float("qw", "the w component of the rotation quaternion")
    float("tx", "the x component of the post-rotation translation")
    float("ty", "the y component of the post-rotation translation")
    float("tz", "the z component of the post-rotation translation")
}

val VkAccelerationStructureSRTMotionInstanceNV = struct(Module.VULKAN, "VkAccelerationStructureSRTMotionInstanceNV") {
    documentation =
        """
        Structure specifying a single acceleration structure SRT motion instance for building into an acceleration structure geometry.

        <h5>Description</h5>
        The C language specification does not define the ordering of bit-fields, but in practice, this struct produces the correct layout with existing compilers. The intended bit pattern is for the following:

        <ul>
            <li>
                {@code instanceCustomIndex} and {@code mask} occupy the same memory as if a single {@code uint32_t} was specified in their place
                <ul>
                    <li>{@code instanceCustomIndex} occupies the 24 least significant bits of that memory</li>
                    <li>{@code mask} occupies the 8 most significant bits of that memory</li>
                </ul>
            </li>
            <li>
                {@code instanceShaderBindingTableRecordOffset} and {@code flags} occupy the same memory as if a single {@code uint32_t} was specified in their place
                <ul>
                    <li>{@code instanceShaderBindingTableRecordOffset} occupies the 24 least significant bits of that memory</li>
                    <li>{@code flags} occupies the 8 most significant bits of that memory</li>
                </ul>
            </li>
        </ul>

        If a compiler produces code that diverges from that pattern, applications <b>must</b> employ another method to set values according to the correct bit pattern.

        The transform for a SRT motion instance at a point in time is derived from component-wise linear interpolation of the two SRT transforms. That is, for a {@code time} in [0,1] the resulting transform is

        <dl>
            <dd><code>transformT0 × (1 - time) + transformT1 × time</code></dd>
        </dl>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkGeometryInstanceFlagBitsKHR} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureMotionInstanceDataNV, ##VkSRTDataNV
        """

    VkSRTDataNV("transformT0", "a ##VkSRTDataNV structure describing a transformation to be applied to the acceleration structure at time 0.")
    VkSRTDataNV("transformT1", "a ##VkSRTDataNV structure describing a transformation to be applied to the acceleration structure at time 1.")
    uint32_t("instanceCustomIndex", "a 24-bit user-specified index value accessible to ray shaders in the {@code InstanceCustomIndexKHR} built-in.", bits = 24)
    uint32_t("mask", "an 8-bit visibility mask for the geometry. The instance <b>may</b> only be hit if {@code Cull Mask &amp; instance.mask != 0}", bits = 8)
    uint32_t("instanceShaderBindingTableRecordOffset", "a 24-bit offset used in calculating the hit shader binding table index.", bits = 24)
    VkGeometryInstanceFlagsKHR("flags", "an 8-bit mask of {@code VkGeometryInstanceFlagBitsKHR} values to apply to this instance.", bits = 8)
    uint64_t("accelerationStructureReference", """either:

        <ul>
            <li>a device address containing the value obtained from #GetAccelerationStructureDeviceAddressKHR() or #GetAccelerationStructureHandleNV() (used by device operations which reference acceleration structures) or,</li>
            <li>a {@code VkAccelerationStructureKHR} object (used by host operations which reference acceleration structures).</li>
        </ul>""")
}

val VkAccelerationStructureMotionInstanceDataNV = union(Module.VULKAN, "VkAccelerationStructureMotionInstanceDataNV") {
    documentation =
        """
        Union specifying a acceleration structure motion instance data for building into an acceleration structure geometry.

        <h5>See Also</h5>
        ##VkAccelerationStructureInstanceKHR, ##VkAccelerationStructureMatrixMotionInstanceNV, ##VkAccelerationStructureMotionInstanceNV, ##VkAccelerationStructureSRTMotionInstanceNV
        """

    VkAccelerationStructureInstanceKHR("staticInstance", "a ##VkAccelerationStructureInstanceKHR structure containing data for a static instance.")
    VkAccelerationStructureMatrixMotionInstanceNV("matrixMotionInstance", "a ##VkAccelerationStructureMatrixMotionInstanceNV structure containing data for a matrix motion instance.")
    VkAccelerationStructureSRTMotionInstanceNV("srtMotionInstance", "a ##VkAccelerationStructureSRTMotionInstanceNV structure containing data for an SRT motion instance.")
}

val VkAccelerationStructureMotionInstanceNV = struct(Module.VULKAN, "VkAccelerationStructureMotionInstanceNV") {
    documentation =
        """
        Structure specifying a single acceleration structure motion instance for building into an acceleration structure geometry.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        If writing this other than with a standard C compiler, note that the final structure should be 152 bytes in size.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code type} <b>must</b> be a valid {@code VkAccelerationStructureMotionInstanceTypeNV} value</li>
            <li>{@code flags} <b>must</b> be 0</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV, the {@code staticInstance} member of {@code data} <b>must</b> be a valid ##VkAccelerationStructureInstanceKHR structure</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV, the {@code matrixMotionInstance} member of {@code data} <b>must</b> be a valid ##VkAccelerationStructureMatrixMotionInstanceNV structure</li>
            <li>If {@code type} is #ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV, the {@code srtMotionInstance} member of {@code data} <b>must</b> be a valid ##VkAccelerationStructureSRTMotionInstanceNV structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkAccelerationStructureMotionInstanceDataNV
        """

    VkAccelerationStructureMotionInstanceTypeNV("type", "a {@code VkAccelerationStructureMotionInstanceTypeNV} enumerant identifying which type of motion instance this is and which type of the union is valid.")
    VkAccelerationStructureMotionInstanceFlagsNV("flags", "currently unused, but is required to keep natural alignment of {@code data}.")
    VkAccelerationStructureMotionInstanceDataNV("data", "a ##VkAccelerationStructureMotionInstanceDataNV containing motion instance data for this instance.")
}

val VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV") {
    documentation =
        """
        Structure describing the ray tracing motion blur features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRayTracingMotionBlurFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRayTracingMotionBlurFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rayTracingMotionBlur", "indicates whether the implementation supports the motion blur feature.")
    VkBool32("rayTracingMotionBlurPipelineTraceRaysIndirect", "indicates whether the implementation supports indirect ray tracing commands with the motion blur feature enabled.")
}

val VkPhysicalDeviceMeshShaderFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMeshShaderFeaturesEXT") {
    documentation =
        """
        Structure describing mesh shading features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMeshShaderFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMeshShaderFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        The corresponding features of the ##VkPhysicalDeviceMeshShaderFeaturesNV structure <b>must</b> match those in ##VkPhysicalDeviceMeshShaderFeaturesEXT.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code multiviewMeshShader} is enabled then ##VkPhysicalDeviceMultiviewFeaturesKHR{@code ::multiview} <b>must</b> also be enabled</li>
            <li>If {@code primitiveFragmentShadingRateMeshShader} is enabled then ##VkPhysicalDeviceFragmentShadingRateFeaturesKHR{@code ::primitiveFragmentShadingRate} <b>must</b> also be enabled</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("taskShader", "specifies whether task shaders are supported. If this feature is not enabled, the #SHADER_STAGE_TASK_BIT_EXT and #PIPELINE_STAGE_TASK_SHADER_BIT_EXT enum values <b>must</b> not be used.")
    VkBool32("meshShader", "specifies whether mesh shaders are supported. If this feature is not enabled, the #SHADER_STAGE_MESH_BIT_EXT and #PIPELINE_STAGE_MESH_SHADER_BIT_EXT enum values <b>must</b> not be used.")
    VkBool32("multiviewMeshShader", "specifies whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-multiview\">{@code multiview}</a> rendering within a render pass, with mesh shaders. If this feature is not enabled, then a pipeline compiled against a subpass with a non-zero view mask <b>must</b> not include a mesh shader.")
    VkBool32("primitiveFragmentShadingRateMeshShader", "indicates that the implementation supports the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-fragment-shading-rate-primitive\">primitive fragment shading rate</a> in mesh shaders.")
    VkBool32("meshShaderQueries", "indicates that the implementation supports creating query pools using the #QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT query type and statistic queries containing the #QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT and #QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT flags")
}

val VkPhysicalDeviceMeshShaderPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMeshShaderPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing mesh shading properties.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMeshShaderPropertiesEXT structure is included in the {@code pNext} chain of ##VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxTaskWorkGroupTotalCount", "the maximum number of total local workgroups that <b>can</b> be launched by a single mesh tasks drawing command. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#drawing-mesh-shading\">Programmable Mesh Shading</a>.")
    uint32_t("maxTaskWorkGroupCount", "the maximum number of local workgroups that <b>can</b> be launched by a single mesh tasks drawing command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The workgroup count parameters to the drawing commands <b>must</b> be less than or equal to the corresponding limit. The product of these dimensions <b>must</b> be less than or equal to {@code maxTaskWorkGroupTotalCount}.")[3]
    uint32_t("maxTaskWorkGroupInvocations", "the maximum total number of task shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode in shader modules or by the object decorated by the {@code WorkgroupSize} decoration, <b>must</b> be less than or equal to this limit.")
    uint32_t("maxTaskWorkGroupSize", "the maximum size of a local task workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The {@code x}, {@code y}, and {@code z} sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode or by the object decorated by the {@code WorkgroupSize} decoration in shader modules, <b>must</b> be less than or equal to the corresponding limit.")[3]
    uint32_t("maxTaskPayloadSize", "the maximum total storage size, in bytes, available for variables declared with the {@code TaskPayloadWorkgroupEXT} storage class in shader modules in the task shader stage.")
    uint32_t("maxTaskSharedMemorySize", "the maximum total storage size, in bytes, available for variables declared with the {@code Workgroup} storage class in shader modules in the task shader stage.")
    uint32_t("maxTaskPayloadAndSharedMemorySize", "the maximum total storage size, in bytes, available for variables that are declared with the {@code TaskPayloadWorkgroupEXT} or {@code Workgroup} storage class, in shader modules in the task shader stage.")
    uint32_t("maxMeshWorkGroupTotalCount", "the maximum number of local output tasks a single task shader workgroup can emit.")
    uint32_t("maxMeshWorkGroupCount", "the maximum number of local output tasks a single task shader workgroup can emit, per dimension. These three values represent the maximum number of local output tasks for the X, Y, and Z dimensions, respectively. The workgroup count parameters to the {@code OpEmitMeshTasksEXT} <b>must</b> be less than or equal to the corresponding limit. The product of these dimensions <b>must</b> be less than or equal to {@code maxMeshWorkGroupTotalCount}.")[3]
    uint32_t("maxMeshWorkGroupInvocations", "the maximum total number of mesh shader invocations in a single local workgroup. The product of the X, Y, and Z sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode in shader modules or by the object decorated by the {@code WorkgroupSize} decoration, <b>must</b> be less than or equal to this limit.")
    uint32_t("maxMeshWorkGroupSize", "the maximum size of a local mesh workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The {@code x}, {@code y}, and {@code z} sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode or by the object decorated by the {@code WorkgroupSize} decoration in shader modules, <b>must</b> be less than or equal to the corresponding limit.")[3]
    uint32_t("maxMeshSharedMemorySize", "the maximum total storage size, in bytes, available for variables declared with the {@code Workgroup} storage class in shader modules in the mesh shader stage.")
    uint32_t("maxMeshPayloadAndSharedMemorySize", "the maximum total storage size, in bytes, available for variables that are declared with the {@code TaskPayloadWorkgroupEXT} or {@code Workgroup} storage class in shader modules in the mesh shader stage.")
    uint32_t("maxMeshOutputMemorySize", "the maximum total storage size, in bytes, available for output variables in shader modules in the mesh shader stage, according to the formula in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#mesh-output\">Mesh Shader Output</a>.")
    uint32_t("maxMeshPayloadAndOutputMemorySize", "the maximum total storage size, in bytes, available for variables that are declared with the {@code TaskPayloadWorkgroupEXT} storage class, or output variables in shader modules in the mesh shader stage, according to the formula in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#mesh-output\">Mesh Shader Output</a>.")
    uint32_t("maxMeshOutputComponents", "the maximum number of components of output variables which <b>can</b> be output from the mesh shader stage.")
    uint32_t("maxMeshOutputVertices", "the maximum number of vertices which <b>can</b> be emitted by a single mesh shader workgroup.")
    uint32_t("maxMeshOutputPrimitives", "the maximum number of primitives which <b>can</b> be emitted by a single mesh shader workgroup.")
    uint32_t("maxMeshOutputLayers", "one greater than the maximum layer index that <b>can</b> be output from the mesh shader stage.")
    uint32_t("maxMeshMultiviewViewCount", "one greater than the maximum view index that <b>can</b> be used by any mesh shader.")
    uint32_t("meshOutputPerVertexGranularity", "the granularity of vertex allocation. The number of output vertices allocated for the mesh shader stage is padded to a multiple of this number. The value can be used to calculate the required storage size for output variables in shader modules in the mesh shader stage, which <b>must</b> be less than or equal to {@code maxMeshOutputMemorySize}.")
    uint32_t("meshOutputPerPrimitiveGranularity", "the granularity of primitive allocation. The number of output primitives allocated for the mesh shader stage is padded to a multiple of this number. The value can be used to calculate the required storage size for output variables in shader modules in the mesh shader stage, which <b>must</b> be less than or equal to {@code maxMeshOutputMemorySize}.")
    uint32_t("maxPreferredTaskWorkGroupInvocations", "the maximum number of task shader invocations in a single workgroup that is preferred by the implementation for optimal performance. The value is guaranteed to be a multiple of a supported subgroup size for the task shader stage.")
    uint32_t("maxPreferredMeshWorkGroupInvocations", "the maximum number of mesh shader invocations in a single workgroup that is preferred by the implementation for optimal performance. The value is guaranteed to be a multiple of a supported subgroup size for the mesh shader stage.")
    VkBool32("prefersLocalInvocationVertexOutput", "specifies whether writes to the vertex output array in a mesh shader yield best performance when the array index matches {@code LocalInvocationIndex}.")
    VkBool32("prefersLocalInvocationPrimitiveOutput", "specifies whether writes to the primitive output array in a mesh shader yield best performance when the array index matches {@code LocalInvocationIndex}.")
    VkBool32("prefersCompactVertexOutput", "specifies whether output vertices should be compacted after custom culling in the mesh shader for best performance, otherwise keeping the vertices at their original location may be better.")
    VkBool32("prefersCompactPrimitiveOutput", "specifies whether output primitives should be compacted after custom culling in the mesh shader for best performance, otherwise the use of {@code CullPrimitiveEXT} may be better.")
}

val VkDrawMeshTasksIndirectCommandEXT = struct(Module.VULKAN, "VkDrawMeshTasksIndirectCommandEXT") {
    documentation =
        """
        Structure specifying a mesh tasks draw indirect command.

        <h5>Description</h5>
        The members of ##VkDrawMeshTasksIndirectCommandEXT have the same meaning as the similarly named parameters of #CmdDrawMeshTasksEXT().

        <h5>Valid Usage</h5>
        <ul>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS contains a shader using the {@code TaskEXT} {@code Execution} {@code Model}, {@code groupCountX} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxTaskWorkGroupCount}[0]</li>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS contains a shader using the {@code TaskEXT} {@code Execution} {@code Model}, {@code groupCountY} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxTaskWorkGroupCount}[1]</li>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS contains a shader using the {@code TaskEXT} {@code Execution} {@code Model}, {@code groupCountZ} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxTaskWorkGroupCount}[2]</li>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS contains a shader using the {@code TaskEXT} {@code Execution} {@code Model}, The product of {@code groupCountX}, {@code groupCountY} and {@code groupCountZ} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxTaskWorkGroupTotalCount}</li>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the {@code TaskEXT} {@code Execution} {@code Model}, {@code groupCountX} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxMeshWorkGroupCount}[0]</li>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the {@code TaskEXT} {@code Execution} {@code Model}, {@code groupCountY} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxMeshWorkGroupCount}[1]</li>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the {@code TaskEXT} {@code Execution} {@code Model}, {@code groupCountZ} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxMeshWorkGroupCount}[2]</li>
            <li>If the current pipeline bound to #PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the {@code TaskEXT} {@code Execution} {@code Model}, The product of {@code groupCountX}, {@code groupCountY} and {@code groupCountZ} <b>must</b> be less than or equal to ##VkPhysicalDeviceMeshShaderPropertiesEXT{@code ::maxMeshWorkGroupTotalCount}</li>
        </ul>

        <h5>See Also</h5>
        #CmdDrawMeshTasksIndirectEXT()
        """

    uint32_t("groupCountX", "the number of local workgroups to dispatch in the X dimension.")
    uint32_t("groupCountY", "the number of local workgroups to dispatch in the Y dimension.")
    uint32_t("groupCountZ", "the number of local workgroups to dispatch in the Z dimension.")
}

val VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT") {
    documentation =
        """
        Structure describing whether the implementation supports additional 2-plane 444 Y′C<sub>B</sub>C<sub>R</sub> formats.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT</li>
        </ul>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Although the formats defined by the {@link EXTYcbcr2plane444Formats VK_EXT_ycbcr_2plane_444_formats} were promoted to Vulkan 1.3 as optional formats, the ##VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure was not promoted to Vulkan 1.3.
        </div>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("ycbcr2plane444Formats", """indicates that the implementation supports the following 2-plane 444 Y′C<sub>B</sub>C<sub>R</sub> formats:

        <ul>
            <li>#FORMAT_G8_B8R8_2PLANE_444_UNORM</li>
            <li>#FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16</li>
            <li>#FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16</li>
            <li>#FORMAT_G16_B16R16_2PLANE_444_UNORM</li>
        </ul>""")
}

val VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT") {
    documentation =
        """
        Structure describing additional fragment density map features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentDensityMap2FeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFragmentDensityMap2FeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("fragmentDensityMapDeferred", "specifies whether the implementation supports deferred reads of fragment density map image views. If this feature is not enabled, #IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT <b>must</b> not be included in ##VkImageViewCreateInfo{@code ::flags}.")
}

val VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing additional fragment density map properties that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentDensityMap2PropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("subsampledLoads", "specifies if performing image data read with load operations on subsampled attachments will be resampled to the fragment density of the render pass")
    VkBool32("subsampledCoarseReconstructionEarlyAccess", "specifies if performing image data read with samplers created with {@code flags} containing #SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT in fragment shader will trigger additional reads during #PIPELINE_STAGE_VERTEX_SHADER_BIT")
    uint32_t("maxSubsampledArrayLayers", "the maximum number of {@code VkImageView} array layers for usages supporting subsampled samplers")
    uint32_t("maxDescriptorSetSubsampledSamplers", "the maximum number of subsampled samplers that <b>can</b> be included in a {@code VkPipelineLayout}")
}

val VkCopyCommandTransformInfoQCOM = struct(Module.VULKAN, "VkCopyCommandTransformInfoQCOM") {
    documentation =
        """
        Structure describing transform parameters of rotated copy command.

        <h5>Description</h5>
        Including this structure in the {@code pNext} chain of ##VkBufferImageCopy2 defines a rotation to be performed when copying between an image and a buffer. Including this structure in the {@code pNext} chain of ##VkBlitImageInfo2 defines a rotation to be performed when blitting between two images. If this structure is not specified in either case, the implementation behaves as if it was specified with a {@code transform} equal to #SURFACE_TRANSFORM_IDENTITY_BIT_KHR.

        Specifying a transform for a copy between an image and a buffer <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#copies-buffers-images-rotation-addressing">rotates the region accessed in the image around the offset</a>. Specifying a transform for a blit performs a similar transform as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#copies-images-scaling-rotation">Image Blits with Scaling and Rotation</a>.

        Rotations other than #SURFACE_TRANSFORM_IDENTITY_BIT_KHR <b>can</b> only be specified for single-plane 2D images with a 1x1x1 <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-compatibility-classes">texel block extent</a>.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code transform} <b>must</b> be #SURFACE_TRANSFORM_IDENTITY_BIT_KHR, #SURFACE_TRANSFORM_ROTATE_90_BIT_KHR, #SURFACE_TRANSFORM_ROTATE_180_BIT_KHR, or #SURFACE_TRANSFORM_ROTATE_270_BIT_KHR</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkSurfaceTransformFlagBitsKHR("transform", "a {@code VkSurfaceTransformFlagBitsKHR} value describing the transform to be applied.")
}

val VkPhysicalDeviceImageRobustnessFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceImageRobustnessFeaturesEXT", alias = VkPhysicalDeviceImageRobustnessFeatures) {
    documentation = "See ##VkPhysicalDeviceImageRobustnessFeatures."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("robustImageAccess", "")
}

val VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR") {
    documentation =
        """
        Structure describing the workgroup storage explicit layout features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("workgroupMemoryExplicitLayout", "indicates whether the implementation supports the SPIR-V {@code WorkgroupMemoryExplicitLayoutKHR} capability.")
    VkBool32("workgroupMemoryExplicitLayoutScalarBlockLayout", "indicates whether the implementation supports scalar alignment for laying out Workgroup Blocks.")
    VkBool32("workgroupMemoryExplicitLayout8BitAccess", "indicates whether objects in the {@code Workgroup} storage class with the {@code Block} decoration <b>can</b> have 8-bit integer members. If this feature is not enabled, 8-bit integer members <b>must</b> not be used in such objects. This also indicates whether shader modules <b>can</b> declare the {@code WorkgroupMemoryExplicitLayout8BitAccessKHR} capability.")
    VkBool32("workgroupMemoryExplicitLayout16BitAccess", "indicates whether objects in the {@code Workgroup} storage class with the {@code Block} decoration <b>can</b> have 16-bit integer and 16-bit floating-point members. If this feature is not enabled, 16-bit integer or 16-bit floating-point members <b>must</b> not be used in such objects. This also indicates whether shader modules <b>can</b> declare the {@code WorkgroupMemoryExplicitLayout16BitAccessKHR} capability.")
}

val VkCopyBufferInfo2KHR = struct(Module.VULKAN, "VkCopyBufferInfo2KHR", alias = VkCopyBufferInfo2) {
    documentation = "See ##VkCopyBufferInfo2."

    Expression("#STRUCTURE_TYPE_COPY_BUFFER_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBuffer("srcBuffer", "")
    VkBuffer("dstBuffer", "")
    AutoSize("pRegions")..uint32_t("regionCount", "")
    VkBufferCopy2.const.p("pRegions", "")
}

val VkCopyImageInfo2KHR = struct(Module.VULKAN, "VkCopyImageInfo2KHR", alias = VkCopyImageInfo2) {
    documentation = "See ##VkCopyImageInfo2."

    Expression("#STRUCTURE_TYPE_COPY_IMAGE_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("srcImage", "")
    VkImageLayout("srcImageLayout", "")
    VkImage("dstImage", "")
    VkImageLayout("dstImageLayout", "")
    AutoSize("pRegions")..uint32_t("regionCount", "")
    VkImageCopy2.const.p("pRegions", "")
}

val VkCopyBufferToImageInfo2KHR = struct(Module.VULKAN, "VkCopyBufferToImageInfo2KHR", alias = VkCopyBufferToImageInfo2) {
    documentation = "See ##VkCopyBufferToImageInfo2."

    Expression("#STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBuffer("srcBuffer", "")
    VkImage("dstImage", "")
    VkImageLayout("dstImageLayout", "")
    AutoSize("pRegions")..uint32_t("regionCount", "")
    VkBufferImageCopy2.const.p("pRegions", "")
}

val VkCopyImageToBufferInfo2KHR = struct(Module.VULKAN, "VkCopyImageToBufferInfo2KHR", alias = VkCopyImageToBufferInfo2) {
    documentation = "See ##VkCopyImageToBufferInfo2."

    Expression("#STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("srcImage", "")
    VkImageLayout("srcImageLayout", "")
    VkBuffer("dstBuffer", "")
    AutoSize("pRegions")..uint32_t("regionCount", "")
    VkBufferImageCopy2.const.p("pRegions", "")
}

val VkBlitImageInfo2KHR = struct(Module.VULKAN, "VkBlitImageInfo2KHR", alias = VkBlitImageInfo2) {
    documentation = "See ##VkBlitImageInfo2."

    Expression("#STRUCTURE_TYPE_BLIT_IMAGE_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("srcImage", "")
    VkImageLayout("srcImageLayout", "")
    VkImage("dstImage", "")
    VkImageLayout("dstImageLayout", "")
    AutoSize("pRegions")..uint32_t("regionCount", "")
    VkImageBlit2.const.p("pRegions", "")
    VkFilter("filter", "")
}

val VkResolveImageInfo2KHR = struct(Module.VULKAN, "VkResolveImageInfo2KHR", alias = VkResolveImageInfo2) {
    documentation = "See ##VkResolveImageInfo2."

    Expression("#STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImage("srcImage", "")
    VkImageLayout("srcImageLayout", "")
    VkImage("dstImage", "")
    VkImageLayout("dstImageLayout", "")
    AutoSize("pRegions")..uint32_t("regionCount", "")
    VkImageResolve2.const.p("pRegions", "")
}

val VkBufferCopy2KHR = struct(Module.VULKAN, "VkBufferCopy2KHR", alias = VkBufferCopy2) {
    documentation = "See ##VkBufferCopy2."

    Expression("#STRUCTURE_TYPE_BUFFER_COPY_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkDeviceSize("srcOffset", "")
    VkDeviceSize("dstOffset", "")
    VkDeviceSize("size", "")
}

val VkImageCopy2KHR = struct(Module.VULKAN, "VkImageCopy2KHR", alias = VkImageCopy2) {
    documentation = "See ##VkImageCopy2."

    Expression("#STRUCTURE_TYPE_IMAGE_COPY_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageSubresourceLayers("srcSubresource", "")
    VkOffset3D("srcOffset", "")
    VkImageSubresourceLayers("dstSubresource", "")
    VkOffset3D("dstOffset", "")
    VkExtent3D("extent", "")
}

val VkImageBlit2KHR = struct(Module.VULKAN, "VkImageBlit2KHR", alias = VkImageBlit2) {
    documentation = "See ##VkImageBlit2."

    Expression("#STRUCTURE_TYPE_IMAGE_BLIT_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageSubresourceLayers("srcSubresource", "")
    VkOffset3D("srcOffsets", "")[2]
    VkImageSubresourceLayers("dstSubresource", "")
    VkOffset3D("dstOffsets", "")[2]
}

val VkBufferImageCopy2KHR = struct(Module.VULKAN, "VkBufferImageCopy2KHR", alias = VkBufferImageCopy2) {
    documentation = "See ##VkBufferImageCopy2."

    Expression("#STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkDeviceSize("bufferOffset", "")
    uint32_t("bufferRowLength", "")
    uint32_t("bufferImageHeight", "")
    VkImageSubresourceLayers("imageSubresource", "")
    VkOffset3D("imageOffset", "")
    VkExtent3D("imageExtent", "")
}

val VkImageResolve2KHR = struct(Module.VULKAN, "VkImageResolve2KHR", alias = VkImageResolve2) {
    documentation = "See ##VkImageResolve2."

    Expression("#STRUCTURE_TYPE_IMAGE_RESOLVE_2")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageSubresourceLayers("srcSubresource", "")
    VkOffset3D("srcOffset", "")
    VkImageSubresourceLayers("dstSubresource", "")
    VkOffset3D("dstOffset", "")
    VkExtent3D("extent", "")
}

val VkPhysicalDeviceImageCompressionControlFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceImageCompressionControlFeaturesEXT") {
    documentation =
        """
        Structure describing whether image compression controls can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageCompressionControlFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceImageCompressionControlFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("imageCompressionControl", "indicates that the implementation supports providing controls for image compression at image creation time.")
}

val VkImageCompressionControlEXT = struct(Module.VULKAN, "VkImageCompressionControlEXT") {
    documentation =
        """
        Specify image compression properties.

        <h5>Description</h5>
        If enabled, fixed-rate compression is done in an implementation-defined manner and <b>may</b> be applied at block granularity. In that case, a write to an individual texel <b>may</b> modify the value of other texels in the same block.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code flags} <b>must</b> be one of #IMAGE_COMPRESSION_DEFAULT_EXT, #IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT, #IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, or #IMAGE_COMPRESSION_DISABLED_EXT</li>
            <li>If {@code flags} includes #IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, {@code pFixedRateFlags} <b>must</b> not be {@code NULL}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT</li>
        </ul>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Some combinations of compression properties may not be supported. For example, some implementations may not support different fixed-rate compression rates per plane of a multi-planar format and will not be able to enable fixed-rate compression for any plane if the requested rates differ.
        </div>
        """

    Expression("#STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageCompressionFlagsEXT("flags", "a bitmask of {@code VkImageCompressionFlagBitsEXT} describing compression controls for the image.")
    AutoSize("pFixedRateFlags", optional = true)..uint32_t("compressionControlPlaneCount", "the number of entries in the {@code pFixedRateFlags} array.")
    nullable..VkImageCompressionFixedRateFlagsEXT.p("pFixedRateFlags", "{@code NULL} or a pointer to an array of {@code VkImageCompressionFixedRateFlagsEXT} bitfields describing allowed fixed-rate compression rates of each image plane. It is ignored if {@code flags} does not include #IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT.")
}

val VkImageCompressionPropertiesEXT = struct(Module.VULKAN, "VkImageCompressionPropertiesEXT", mutable = false) {
    documentation =
        """
        Compression properties of an image.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkImageCompressionFlagsEXT("imageCompressionFlags", "returns a value describing the compression controls that apply to the image. The value will be either #IMAGE_COMPRESSION_DEFAULT_EXT to indicate no fixed-rate compression, #IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT to indicate fixed-rate compression, or #IMAGE_COMPRESSION_DISABLED_EXT to indicate no compression.")
    VkImageCompressionFixedRateFlagsEXT("imageCompressionFixedRateFlags", "returns a {@code VkImageCompressionFixedRateFlagsEXT} value describing the compression rates that apply to the specified aspect of the image.")
}

val VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT") {
    documentation =
        """
        Structure indicating support for a render feedback loop image layout.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("attachmentFeedbackLoopLayout", "indicates whether the implementation supports using #IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout for images created with #IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT.")
}

val VkPhysicalDevice4444FormatsFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevice4444FormatsFeaturesEXT") {
    documentation =
        """
        Structure describing additional 4444 formats supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDevice4444FormatsFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevice4444FormatsFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT</li>
        </ul>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Although the formats defined by the {@link EXT4444Formats VK_EXT_4444_formats} extension were promoted to Vulkan 1.3 as optional formats, the ##VkPhysicalDevice4444FormatsFeaturesEXT structure was not promoted to Vulkan 1.3.
        </div>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("formatA4R4G4B4", """indicates that the implementation <b>must</b> support using a {@code VkFormat} of #FORMAT_A4R4G4B4_UNORM_PACK16_EXT with at least the following {@code VkFormatFeatureFlagBits}:

        <ul>
            <li>#FORMAT_FEATURE_SAMPLED_IMAGE_BIT</li>
            <li>#FORMAT_FEATURE_BLIT_SRC_BIT</li>
            <li>#FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</li>
        </ul>""")
    VkBool32("formatA4B4G4R4", """indicates that the implementation <b>must</b> support using a {@code VkFormat} of #FORMAT_A4B4G4R4_UNORM_PACK16_EXT with at least the following {@code VkFormatFeatureFlagBits}:

        <ul>
            <li>#FORMAT_FEATURE_SAMPLED_IMAGE_BIT</li>
            <li>#FORMAT_FEATURE_BLIT_SRC_BIT</li>
            <li>#FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</li>
        </ul>""")
}

val VkPhysicalDeviceFaultFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceFaultFeaturesEXT") {
    documentation =
        """
        Structure indicating support for device fault reporting.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFaultFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFaultFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("deviceFault", "indicates that the implementation supports the reporting of device fault information.")
    VkBool32("deviceFaultVendorBinary", "indicates that the implementation supports the generation of vendor-specific binary crash dumps. These may provide additional information when imported into vendor-specific external tools.")
}

val VkDeviceFaultCountsEXT = struct(Module.VULKAN, "VkDeviceFaultCountsEXT") {
    documentation =
        """
        Structure specifying device fault information.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetDeviceFaultInfoEXT()
        """

    Expression("#STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("addressInfoCount", "the number of ##VkDeviceFaultAddressInfoEXT structures describing either memory accesses which <b>may</b> have caused a page fault, or the addresses of active instructions at the time of the fault.")
    uint32_t("vendorInfoCount", "the number of ##VkDeviceFaultVendorInfoEXT structures describing vendor-specific fault information.")
    VkDeviceSize("vendorBinarySize", "the size in bytes of a vendor-specific binary crash dump, which may provide additional information when imported into external tools.")
}

val VkDeviceFaultAddressInfoEXT = struct(Module.VULKAN, "VkDeviceFaultAddressInfoEXT") {
    documentation =
        """
        Structure specifying GPU virtual address information.

        <h5>Description</h5>
        The combination of {@code reportedAddress} and {@code addressPrecision} allow the possible range of addresses to be calculated, such that:

        <pre><code>
￿lower_address = (pInfo-&gt;reportedAddress &amp; ~(pInfo-&gt;addressPrecision-1))
￿upper_address = (pInfo-&gt;reportedAddress |  (pInfo-&gt;addressPrecision-1))</code></pre>

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        It is valid for the {@code reportedAddress} to contain a more precise address than indicated by {@code addressPrecision}. In this case, the value of {@code reportedAddress} should be treated as an additional hint as to the value of the address that triggered the page fault, or to the value of an instruction pointer.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code addressType} <b>must</b> be a valid {@code VkDeviceFaultAddressTypeEXT} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceFaultInfoEXT
        """

    VkDeviceFaultAddressTypeEXT("addressType", "either the type of memory operation that triggered a page fault, or the type of association between an instruction pointer and a fault.")
    VkDeviceAddress("reportedAddress", "the GPU virtual address recorded by the device.")
    VkDeviceSize("addressPrecision", "a power of two value that specifies how precisely the device can report the address.")
}

val VkDeviceFaultVendorInfoEXT = struct(Module.VULKAN, "VkDeviceFaultVendorInfoEXT") {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure specifying vendor-specific fault information.

        <h5>See Also</h5>
        ##VkDeviceFaultInfoEXT
        """

    charUTF8("description", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a human readable description of the fault.")["VK_MAX_DESCRIPTION_SIZE"]
    uint64_t("vendorFaultCode", "the vendor-specific fault code for this fault.")
    uint64_t("vendorFaultData", "the vendor-specific fault data associated with this fault.")
}

val VkDeviceFaultInfoEXT = struct(Module.VULKAN, "VkDeviceFaultInfoEXT") {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure specifying device fault information.

        <h5>Description</h5>
        An implementation <b>should</b> populate as many members of ##VkDeviceFaultInfoEXT as possible, given the information available at the time of the fault and the constraints of the implementation itself.

        Due to hardware limitations, {@code pAddressInfos} describes ranges of GPU virtual address space, rather than precise addresses. The precise memory address accessed or the precise value of the instruction pointer <b>must</b> lie within the region described.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Each element of {@code pAddressInfos} describes either:

        <ul>
            <li>A memory access which may have triggered a page fault and may have contributed to device loss</li>
            <li>The value of an active instruction pointer at the time a fault occurred. This value may be indicative of the active pipeline or shader at the time of device loss</li>
        </ul>

        Comparison of the GPU virtual addresses described by {@code pAddressInfos} to GPU virtual address ranges reported by the {@link EXTDeviceAddressBindingReport VK_EXT_device_address_binding_report} extension may allow applications to correlate between these addresses and Vulkan objects. Applications should be aware that these addresses may also correspond to resources internal to an implementation, which will not be reported via the {@link EXTDeviceAddressBindingReport VK_EXT_device_address_binding_report} extension.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>If {@code pAddressInfos} is not {@code NULL}, {@code pAddressInfos} <b>must</b> be a valid pointer to a ##VkDeviceFaultAddressInfoEXT structure</li>
            <li>If {@code pVendorInfos} is not {@code NULL}, {@code pVendorInfos} <b>must</b> be a valid pointer to a ##VkDeviceFaultVendorInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceFaultAddressInfoEXT, ##VkDeviceFaultVendorInfoEXT, #GetDeviceFaultInfoEXT()
        """

    Expression("#STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    charUTF8("description", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which is a human readable description of the fault.")["VK_MAX_DESCRIPTION_SIZE"]
    nullable..VkDeviceFaultAddressInfoEXT.p("pAddressInfos", "{@code NULL} or a pointer to an array of ##VkDeviceFaultAddressInfoEXT structures describing either memory accesses which <b>may</b> have caused a page fault, or describing active instruction pointers at the time of the fault. If not {@code NULL}, each element of {@code pAddressInfos} describes the a bounded region of GPU virtual address space containing either the GPU virtual address accessed, or the value of an active instruction pointer.")
    nullable..VkDeviceFaultVendorInfoEXT.p("pVendorInfos", "{@code NULL} or a pointer to an array of ##VkDeviceFaultVendorInfoEXT structures describing vendor-specific fault information.")
    nullable..opaque_p("pVendorBinaryData", "{@code NULL} or a pointer to {@code vendorBinarySize} number of bytes of data, which will be populated with a vendor-specific binary crash dump, as described in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#vendor-binary-crash-dumps\">Vendor Binary Crash Dumps</a>.")
}

val VkDeviceFaultVendorBinaryHeaderVersionOneEXT = struct(Module.VULKAN, "VkDeviceFaultVendorBinaryHeaderVersionOneEXT") {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure describing the layout of the vendor binary crash dump header.

        <h5>Description</h5>
        Unlike most structures declared by the Vulkan API, all fields of this structure are written with the least significant byte first, regardless of host byte-order.

        The C language specification does not define the packing of structure members. This layout assumes tight structure member packing, with members laid out in the order listed in the structure, and the intended size of the structure is 56 bytes. If a compiler produces code that diverges from that pattern, applications <b>must</b> employ another method to set values at the correct offsets.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code headerSize} <b>must</b> be 56</li>
            <li>{@code headerVersion} <b>must</b> be #DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code headerVersion} <b>must</b> be a valid {@code VkDeviceFaultVendorBinaryHeaderVersionEXT} value</li>
        </ul>
        """

    uint32_t("headerSize", "the length in bytes of the crash dump header.")
    VkDeviceFaultVendorBinaryHeaderVersionEXT("headerVersion", "a {@code VkDeviceFaultVendorBinaryHeaderVersionEXT} enum value specifying the version of the header. A consumer of the crash dump <b>should</b> use the header version to interpret the remainder of the header.")
    uint32_t("vendorID", "the ##VkPhysicalDeviceProperties{@code ::vendorID} of the implementation.")
    uint32_t("deviceID", "the ##VkPhysicalDeviceProperties{@code ::deviceID} of the implementation.")
    uint32_t("driverVersion", "the ##VkPhysicalDeviceProperties{@code ::driverVersion} of the implementation.")
    uint8_t("pipelineCacheUUID", "an array of #UUID_SIZE {@code uint8_t} values matching the ##VkPhysicalDeviceProperties{@code ::pipelineCacheUUID} property of the implementation.")["VK_UUID_SIZE"]
    uint32_t("applicationNameOffset", "zero, or an offset from the base address of the crash dump header to a null-terminated UTF-8 string containing the name of the application. If {@code applicationNameOffset} is non-zero, this string <b>must</b> match the application name specified via ##VkApplicationInfo{@code ::pApplicationName} during instance creation.")
    uint32_t("applicationVersion", "<b>must</b> be zero or the value specified by ##VkApplicationInfo{@code ::applicationVersion} during instance creation.")
    uint32_t("engineNameOffset", "zero, or an offset from the base address of the crash dump header to a null-terminated UTF-8 string containing the name of the engine (if any) used to create the application. If {@code engineNameOffset} is non-zero, this string <b>must</b> match the engine name specified via ##VkApplicationInfo{@code ::pEngineName} during instance creation.")
    uint32_t("engineVersion", "<b>must</b> be zero or the value specified by ##VkApplicationInfo{@code ::engineVersion} during instance creation.")
    uint32_t("apiVersion", "<b>must</b> be zero or the value specified by ##VkApplicationInfo{@code ::apiVersion} during instance creation.")
}

val _VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT")
val VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = struct(Module.VULKAN, "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM", alias = _VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT) {
    documentation = "See ##VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("rasterizationOrderColorAttachmentAccess", "")
    VkBool32("rasterizationOrderDepthAttachmentAccess", "")
    VkBool32("rasterizationOrderStencilAttachmentAccess", "")
}

val VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT") {
    documentation =
        """
        Structure describing whether rendering to VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 formats can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("formatRgba10x6WithoutYCbCrSampler", "indicates that #FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 <b>can</b> be used with a {@code VkImageView} with {@code subresourceRange.aspectMask} equal to #IMAGE_ASPECT_COLOR_BIT without a <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#samplers-YCbCr-conversion\">sampler Y′C<sub>B</sub>C<sub>R</sub> conversion</a> enabled.")
}

val VkDirectFBSurfaceCreateInfoEXT = struct(Module.VULKAN, "VkDirectFBSurfaceCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created DirectFB surface object.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code dfb} <b>must</b> point to a valid DirectFB {@code IDirectFB}</li>
            <li>{@code surface} <b>must</b> point to a valid DirectFB {@code IDirectFBSurface}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        #CreateDirectFBSurfaceEXT()
        """

    Expression("#STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDirectFBSurfaceCreateFlagsEXT("flags", "reserved for future use.")
    nullable..IDirectFB.p("dfb", "a pointer to the {@code IDirectFB} main interface of DirectFB.")
    nullable..IDirectFBSurface.p("surface", "a pointer to a {@code IDirectFBSurface} surface interface.")
}

val _VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT")
val VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = struct(Module.VULKAN, "VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE", alias = _VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT) {
    documentation = "See ##VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("mutableDescriptorType", "")
}

val _VkMutableDescriptorTypeListEXT = struct(Module.VULKAN, "VkMutableDescriptorTypeListEXT")
val VkMutableDescriptorTypeListVALVE = struct(Module.VULKAN, "VkMutableDescriptorTypeListVALVE", alias = _VkMutableDescriptorTypeListEXT) {
    documentation = "See ##VkMutableDescriptorTypeListEXT."

    AutoSize("pDescriptorTypes", optional = true)..uint32_t("descriptorTypeCount", "")
    VkDescriptorType.const.p("pDescriptorTypes", "")
}

val VkMutableDescriptorTypeListEXT = struct(Module.VULKAN, "VkMutableDescriptorTypeListEXT") {
    documentation =
        """
        Structure describing descriptor types that a given descriptor may mutate to.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code descriptorTypeCount} <b>must</b> not be 0 if the corresponding binding is of #DESCRIPTOR_TYPE_MUTABLE_EXT</li>
            <li>{@code pDescriptorTypes} <b>must</b> be a valid pointer to an array of {@code descriptorTypeCount} valid, unique {@code VkDescriptorType} values if the given binding is of #DESCRIPTOR_TYPE_MUTABLE_EXT type</li>
            <li>{@code descriptorTypeCount} <b>must</b> be 0 if the corresponding binding is not of #DESCRIPTOR_TYPE_MUTABLE_EXT</li>
            <li>{@code pDescriptorTypes} <b>must</b> not contain #DESCRIPTOR_TYPE_MUTABLE_EXT</li>
            <li>{@code pDescriptorTypes} <b>must</b> not contain #DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC</li>
            <li>{@code pDescriptorTypes} <b>must</b> not contain #DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</li>
            <li>{@code pDescriptorTypes} <b>must</b> not contain #DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>If {@code descriptorTypeCount} is not 0, {@code pDescriptorTypes} <b>must</b> be a valid pointer to an array of {@code descriptorTypeCount} valid {@code VkDescriptorType} values</li>
        </ul>

        <h5>See Also</h5>
        ##VkMutableDescriptorTypeCreateInfoEXT
        """

    AutoSize("pDescriptorTypes", optional = true)..uint32_t("descriptorTypeCount", "the number of elements in {@code pDescriptorTypes}.")
    VkDescriptorType.const.p("pDescriptorTypes", "{@code NULL} or a pointer to an array of {@code descriptorTypeCount} {@code VkDescriptorType} values defining which descriptor types a given binding may mutate to.")
}

val _VkMutableDescriptorTypeCreateInfoEXT = struct(Module.VULKAN, "VkMutableDescriptorTypeCreateInfoEXT")
val VkMutableDescriptorTypeCreateInfoVALVE = struct(Module.VULKAN, "VkMutableDescriptorTypeCreateInfoVALVE", alias = _VkMutableDescriptorTypeCreateInfoEXT) {
    documentation = "See ##VkMutableDescriptorTypeCreateInfoEXT."

    Expression("#STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    AutoSize("pMutableDescriptorTypeLists", optional = true)..uint32_t("mutableDescriptorTypeListCount", "")
    VkMutableDescriptorTypeListEXT.const.p("pMutableDescriptorTypeLists", "")
}

val VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT") {
    documentation =
        """
        Structure describing whether the dynamic vertex input state can be used.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("vertexInputDynamicState", """indicates that the implementation supports the following dynamic states:

        <ul>
            <li>#DYNAMIC_STATE_VERTEX_INPUT_EXT</li>
        </ul>""")
}

val VkVertexInputBindingDescription2EXT = struct(Module.VULKAN, "VkVertexInputBindingDescription2EXT") {
    documentation =
        """
        Structure specifying the extended vertex input binding description.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code binding} <b>must</b> be less than ##VkPhysicalDeviceLimits{@code ::maxVertexInputBindings}</li>
            <li>{@code stride} <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxVertexInputBindingStride}</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-vertexAttributeInstanceRateZeroDivisor">{@code vertexAttributeInstanceRateZeroDivisor}</a> feature is not enabled, {@code divisor} <b>must</b> not be 0</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-vertexAttributeInstanceRateDivisor">{@code vertexAttributeInstanceRateDivisor}</a> feature is not enabled, {@code divisor} <b>must</b> be 1</li>
            <li>{@code divisor} <b>must</b> be a value between 0 and ##VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{@code ::maxVertexAttribDivisor}, inclusive</li>
            <li>If {@code divisor} is not 1 then {@code inputRate} <b>must</b> be of type #VERTEX_INPUT_RATE_INSTANCE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT</li>
            <li>{@code inputRate} <b>must</b> be a valid {@code VkVertexInputRate} value</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetVertexInputEXT()
        """

    Expression("#STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("binding", "the binding number that this structure describes.")
    uint32_t("stride", "the byte stride between consecutive elements within the buffer.")
    VkVertexInputRate("inputRate", "a {@code VkVertexInputRate} value specifying whether vertex attribute addressing is a function of the vertex index or of the instance index.")
    uint32_t("divisor", "the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. This member <b>can</b> be set to a value other than 1 if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-vertexAttributeInstanceRateDivisor\">{@code vertexAttributeInstanceRateDivisor}</a> feature is enabled. For example, if the divisor is N, the same vertex attribute will be applied to N successive instances before moving on to the next vertex attribute. The maximum value of {@code divisor} is implementation-dependent and can be queried using ##VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{@code ::maxVertexAttribDivisor}. A value of 0 <b>can</b> be used for the divisor if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-vertexAttributeInstanceRateZeroDivisor\">{@code vertexAttributeInstanceRateZeroDivisor}</a> feature is enabled. In this case, the same vertex attribute will be applied to all instances.")
}

val VkVertexInputAttributeDescription2EXT = struct(Module.VULKAN, "VkVertexInputAttributeDescription2EXT") {
    documentation =
        """
        Structure specifying the extended vertex input attribute description.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code location} <b>must</b> be less than ##VkPhysicalDeviceLimits{@code ::maxVertexInputAttributes}</li>
            <li>{@code binding} <b>must</b> be less than ##VkPhysicalDeviceLimits{@code ::maxVertexInputBindings}</li>
            <li>{@code offset} <b>must</b> be less than or equal to ##VkPhysicalDeviceLimits{@code ::maxVertexInputAttributeOffset}</li>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#resources-buffer-view-format-features">format features</a> of {@code format} <b>must</b> contain #FORMAT_FEATURE_VERTEX_BUFFER_BIT</li>
            <li>If the {@link KHRPortabilitySubset VK_KHR_portability_subset} extension is enabled, and ##VkPhysicalDevicePortabilitySubsetFeaturesKHR{@code ::vertexAttributeAccessBeyondStride} is #FALSE, the sum of {@code offset} plus the size of the vertex attribute data described by {@code format} <b>must</b> not be greater than {@code stride} in the ##VkVertexInputBindingDescription2EXT referenced in {@code binding}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT</li>
            <li>{@code format} <b>must</b> be a valid {@code VkFormat} value</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetVertexInputEXT()
        """

    Expression("#STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("location", "the shader input location number for this attribute.")
    uint32_t("binding", "the binding number which this attribute takes its data from.")
    VkFormat("format", "the size and type of the vertex attribute data.")
    uint32_t("offset", "a byte offset of this attribute relative to the start of an element in the vertex input binding.")
}

val VkPhysicalDeviceDrmPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDrmPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure containing DRM information of a physical device.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDrmPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These are properties of the DRM information of a physical device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("hasPrimary", "a boolean indicating whether the physical device has a DRM primary node.")
    VkBool32("hasRender", "a boolean indicating whether the physical device has a DRM render node.")
    int64_t("primaryMajor", "the DRM primary node major number, if any.")
    int64_t("primaryMinor", "the DRM primary node minor number, if any.")
    int64_t("renderMajor", "the DRM render node major number, if any.")
    int64_t("renderMinor", "the DRM render node minor number, if any.")
}

val VkPhysicalDeviceAddressBindingReportFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceAddressBindingReportFeaturesEXT") {
    documentation =
        """
        Structure describing the virtual allocation reporting feature supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceAddressBindingReportFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceAddressBindingReportFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("reportAddressBinding", "indicates whether this implementation supports reporting the binding of GPU virtual address ranges to Vulkan objects.")
}

val VkDeviceAddressBindingCallbackDataEXT = struct(Module.VULKAN, "VkDeviceAddressBindingCallbackDataEXT") {
    documentation =
        """
        Structure specifying parameters returned to the callback.

        <h5>Description</h5>
        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-reportAddressBinding">{@code reportAddressBinding}</a> feature is enabled and the implementation binds or unbinds a region of virtual address space associated with a Vulkan object, the implementation <b>must</b> submit a debug message with the following properties:

        <ul>
            <li>{@code messageSeverity} equal to #DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</li>
            <li>{@code messageType} equal to #DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT</li>
            <li>##VkDebugUtilsMessengerCallbackDataEXT{@code ::pObjects} <b>must</b> identify the associated Vulkan object</li>
            <li>##VkDeviceAddressBindingCallbackDataEXT <b>must</b> be included in the {@code pNext} chain of ##VkDebugUtilsMessengerCallbackDataEXT</li>
        </ul>

        These debug messages <b>must</b> be emitted both for GPU virtual address space regions that are explicitly bound to a Vulkan object via the {@code vkBind}*Memory/{@code vkBind}*Memory2 functions, and for those that are implicitly generated via memory allocation or importing external memory.

        An implementation <b>may</b> report binding events associated with a Vulkan object via {@code VkDebugUtilsMessengerEXT} prior to the object becoming visible to an application via other Vulkan commands. For example, object creation functions <b>may</b> report binding events that occur during an objects creation. In such cases, ##VkDeviceAddressBindingCallbackDataEXT{@code ::flags} <b>must</b> include #DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT.

        Object handles reported in this manner are not <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#fundamentals-validusage-handles">valid object handles</a>, and <b>must</b> not be used as an input parameter to any Vulkan command.

        Any valid object handle returned by an object creation function <b>must</b> match the handle specified via any previously reported binding events associated with the object’s creation.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkDeviceAddressBindingFlagBitsEXT} values</li>
            <li>{@code bindingType} <b>must</b> be a valid {@code VkDeviceAddressBindingTypeEXT} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceAddressBindingFlagsEXT("flags", "a bitmask of {@code VkDeviceAddressBindingFlagBitsEXT} specifying additional information about the binding event that caused the callback to be called.")
    VkDeviceAddress("baseAddress", "a GPU-accessible virtual address identifying the start of a region of the virtual address space associated with a Vulkan object, as identified by the {@code pObjects} member of ##VkDebugUtilsMessengerCallbackDataEXT.")
    VkDeviceSize("size", "the size in bytes of a region of GPU-accessible virtual address space.")
    VkDeviceAddressBindingTypeEXT("bindingType", "a {@code VkDeviceAddressBindingTypeEXT} specifying the type of binding event that caused the callback to be called.")
}

val VkPhysicalDeviceDepthClipControlFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDepthClipControlFeaturesEXT") {
    documentation =
        """
        Structure describing additional depth clip control supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDepthClipControlFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDepthClipControlFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("depthClipControl", "indicates that the implementation supports setting ##VkPipelineViewportDepthClipControlCreateInfoEXT{@code ::negativeOneToOne} to #TRUE.")
}

val VkPipelineViewportDepthClipControlCreateInfoEXT = struct(Module.VULKAN, "VkPipelineViewportDepthClipControlCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created pipeline depth clip control state.

        <h5>Valid Usage</h5>
        <ul>
            <li>If <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-depthClipControl">{@code depthClipControl}</a> is not enabled, {@code negativeOneToOne} <b>must</b> be #FALSE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("negativeOneToOne", "sets the <code>z<sub>m</sub></code> in the <em>view volume</em> to <code>-w<sub>c</sub></code>")
}

val VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT") {
    documentation =
        """
        Structure describing whether list type primitives can support primitive restart.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("primitiveTopologyListRestart", "indicates that list type primitives, #PRIMITIVE_TOPOLOGY_POINT_LIST, #PRIMITIVE_TOPOLOGY_LINE_LIST, #PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, #PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY and #PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, <b>can</b> use the primitive restart index value in index buffers.")
    VkBool32("primitiveTopologyPatchListRestart", "indicates that the #PRIMITIVE_TOPOLOGY_PATCH_LIST topology <b>can</b> use the primitive restart index value in index buffers.")
}

val VkFormatProperties3KHR = struct(Module.VULKAN, "VkFormatProperties3KHR", mutable = false, alias = VkFormatProperties3) {
    documentation = "See ##VkFormatProperties3."

    Expression("#STRUCTURE_TYPE_FORMAT_PROPERTIES_3")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkFormatFeatureFlags2("linearTilingFeatures", "")
    VkFormatFeatureFlags2("optimalTilingFeatures", "")
    VkFormatFeatureFlags2("bufferFeatures", "")
}

val VkSubpassShadingPipelineCreateInfoHUAWEI = struct(Module.VULKAN, "VkSubpassShadingPipelineCreateInfoHUAWEI", mutable = false) {
    documentation =
        """
        Structure specifying parameters of a newly created subpass shading pipeline.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code subpass} <b>must</b> be created with #PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI bind point</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkRenderPass("renderPass", "a handle to a render pass object describing the environment in which the pipeline will be used. The pipeline <b>must</b> only be used with a render pass instance compatible with the one provided. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#renderpass-compatibility\">Render Pass Compatibility</a> for more information.")
    uint32_t("subpass", "the index of the subpass in the render pass where this pipeline will be used.")
}

val VkPhysicalDeviceSubpassShadingFeaturesHUAWEI = struct(Module.VULKAN, "VkPhysicalDeviceSubpassShadingFeaturesHUAWEI") {
    documentation =
        """
        Structure describing whether subpass shading is enabled.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceSubpassShadingFeaturesHUAWEI structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceSubpassShadingFeaturesHUAWEI <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("subpassShading", "specifies whether subpass shading is supported.")
}

val VkPhysicalDeviceSubpassShadingPropertiesHUAWEI = struct(Module.VULKAN, "VkPhysicalDeviceSubpassShadingPropertiesHUAWEI", mutable = false) {
    documentation =
        """
        Structure describing subpass shading properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceSubpassShadingPropertiesHUAWEI structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxSubpassShadingWorkgroupSizeAspectRatio", "indicates the maximum ratio between the width and height of the portion of the subpass shading shader workgroup size. {@code maxSubpassShadingWorkgroupSizeAspectRatio} <b>must</b> be a power-of-two value, and <b>must</b> be less than or equal to max({@code WorkgroupSize.x} / {@code WorkgroupSize.y}, {@code WorkgroupSize.y} / {@code WorkgroupSize.x}).")
}

val VkPhysicalDeviceInvocationMaskFeaturesHUAWEI = struct(Module.VULKAN, "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI") {
    documentation =
        """
        Structure describing invocation mask features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceInvocationMaskFeaturesHUAWEI structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceInvocationMaskFeaturesHUAWEI <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("invocationMask", "indicates that the implementation supports the use of an invocation mask image to optimize the ray dispatch.")
}

val VkMemoryGetRemoteAddressInfoNV = struct(Module.VULKAN, "VkMemoryGetRemoteAddressInfoNV") {
    documentation =
        """
        Structure describing a remote accessible address export operation.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code handleType} <b>must</b> have been included in ##VkExportMemoryAllocateInfo{@code ::handleTypes} when {@code memory} was created</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code memory} <b>must</b> be a valid {@code VkDeviceMemory} handle</li>
            <li>{@code handleType} <b>must</b> be a valid {@code VkExternalMemoryHandleTypeFlagBits} value</li>
        </ul>

        <h5>See Also</h5>
        #GetMemoryRemoteAddressNV()
        """

    Expression("#STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceMemory("memory", "the memory object from which the remote accessible address will be exported.")
    VkExternalMemoryHandleTypeFlagBits("handleType", "the type of handle requested.")
}

val VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV") {
    documentation =
        """
        Structure describing the external memory RDMA features supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceExternalMemoryRDMAFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceExternalMemoryRDMAFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("externalMemoryRDMA", "indicates whether the implementation has support for the #MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV memory property and the #EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV external memory handle type.")
}

val VkPipelineInfoEXT = struct(Module.VULKAN, "VkPipelineInfoEXT", alias = VkPipelineInfoKHR) {
    documentation = "See ##VkPipelineInfoKHR."

    Expression("#STRUCTURE_TYPE_PIPELINE_INFO_KHR")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPipeline("pipeline", "")
}

val VkPipelinePropertiesIdentifierEXT = struct(Module.VULKAN, "VkPipelinePropertiesIdentifierEXT") {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure used to retrieve pipeline properties.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint8_t("pipelineIdentifier", "an array of #UUID_SIZE {@code uint8_t} values into which the pipeline identifier will be written.")["VK_UUID_SIZE"]
}

val VkPhysicalDevicePipelinePropertiesFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePipelinePropertiesFeaturesEXT") {
    documentation =
        """
        Structure describing what pipeline properties are supported.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePipelinePropertiesFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePipelinePropertiesFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("pipelinePropertiesIdentifier", "indicates that the implementation supports querying a unique pipeline identifier.")
}

val VkPhysicalDeviceFrameBoundaryFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceFrameBoundaryFeaturesEXT") {
    documentation =
        """
        Structure describing the frame boundary features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFrameBoundaryFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFrameBoundaryFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("frameBoundary", "indicates whether the implementation supports frame boundary information.")
}

val VkFrameBoundaryEXT = struct(Module.VULKAN, "VkFrameBoundaryEXT") {
    documentation =
        """
        Add frame boundary information to queue submissions.

        <h5>Description</h5>
        The application <b>can</b> associate frame boundary information to a queue submission call by adding a ##VkFrameBoundaryEXT structure to the {@code pNext} chain of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#devsandqueues-submission">queue submission</a>, ##VkPresentInfoKHR, or ##VkBindSparseInfo.

        The frame identifier is used to associate one or more queue submission to a frame, it is thus meant to be unique within a frame lifetime, i.e. it is possible (but not recommended) to reuse frame identifiers, as long as any two frames with any chance of having overlapping queue submissions (as in the example above) use two different frame identifiers.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Since the concept of frame is application-dependent, there is no way to validate the use of frame identifier. It is good practice to use a monotonically increasing counter as the frame identifier and not reuse identifiers between frames.
        </div>

        The {@code pImages} and {@code pBuffers} arrays contain a list of images and buffers which store the "end result" of the frame. As the concept of frame is application-dependent, not all frames <b>may</b> produce their results in images or buffers, yet this is a sufficiently common case to be handled by ##VkFrameBoundaryEXT. Note that no extra information, such as image layout is being provided, since the images are meant to be used by tools which would already be tracking this required information. Having the possibility of passing a list of end-result images makes ##VkFrameBoundaryEXT as expressive as #QueuePresentKHR(), which is often the default frame boundary delimiter.

        The application <b>can</b> also associate arbitrary extra information via tag data using {@code tagName}, {@code tagSize} and {@code pTag}. This extra information is typically tool-specific.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_FRAME_BOUNDARY_EXT</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkFrameBoundaryFlagBitsEXT} values</li>
            <li>If {@code imageCount} is not 0, and {@code pImages} is not {@code NULL}, {@code pImages} <b>must</b> be a valid pointer to an array of {@code imageCount} valid {@code VkImage} handles</li>
            <li>If {@code bufferCount} is not 0, and {@code pBuffers} is not {@code NULL}, {@code pBuffers} <b>must</b> be a valid pointer to an array of {@code bufferCount} valid {@code VkBuffer} handles</li>
            <li>Both of the elements of {@code pBuffers}, and the elements of {@code pImages} that are valid handles of non-ignored parameters <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_FRAME_BOUNDARY_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFrameBoundaryFlagsEXT("flags", "a bitmask of {@code VkFrameBoundaryFlagBitsEXT} that can flag the last submission of a frame identifier.")
    uint64_t("frameID", "the frame identifier.")
    AutoSize("pImages", optional = true)..uint32_t("imageCount", "the number of images that store frame results.")
    nullable..VkImage.const.p("pImages", "a pointer to an array of VkImage objects with imageCount entries.")
    AutoSize("pBuffers", optional = true)..uint32_t("bufferCount", "the number of buffers the store the frame results.")
    nullable..VkBuffer.const.p("pBuffers", "a pointer to an array of VkBuffer objects with bufferCount entries.")
    uint64_t("tagName", "a numerical identifier for tag data.")
    size_t("tagSize", "the number of bytes of tag data.")
    nullable..opaque_const_p("pTag", "a pointer to an array of {@code tagSize} bytes containing tag data.")
}

val VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT") {
    documentation =
        """
        Structure describing whether multisampled rendering to single-sampled attachments is supported.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("multisampledRenderToSingleSampled", "indicates that the implementation supports multisampled rendering to single-sampled render pass attachments.")
}

val VkSubpassResolvePerformanceQueryEXT = struct(Module.VULKAN, "VkSubpassResolvePerformanceQueryEXT", mutable = false) {
    documentation =
        """
        Structure specifying the efficiency of subpass resolve for an attachment with a format.

        <h5>Description</h5>
        If {@code optimal} is #FALSE for a {@code VkFormat}, using a subpass resolve operation on a multisampled attachment with this format can incur additional costs, including additional memory bandwidth usage and a higher memory footprint. If an attachment with such a format is used in a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#subpass-multisampledrendertosinglesampled">multisampled-render-to-single-sampled</a> subpass, the additional memory and memory bandwidth usage can nullify the benefits of using the {@link EXTMultisampledRenderToSingleSampled VK_EXT_multisampled_render_to_single_sampled} extension.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("optimal", "specifies that a subpass resolve operation is optimally performed.")
}

val VkMultisampledRenderToSingleSampledInfoEXT = struct(Module.VULKAN, "VkMultisampledRenderToSingleSampledInfoEXT") {
    documentation =
        """
        Structure containing info for multisampled rendering to single-sampled attachments in a subpass.

        <h5>Valid Usage</h5>
        <ul>
            <li>The value of {@code rasterizationSamples} <b>must</b> not be #SAMPLE_COUNT_1_BIT</li>
            <li>If added to the {@code pNext} chain of ##VkRenderingInfo, each {@code imageView} member of any element of ##VkRenderingInfo{@code ::pColorAttachments}, ##VkRenderingInfo{@code ::pDepthAttachment}, or ##VkRenderingInfo{@code ::pStencilAttachment} that is not #NULL_HANDLE <b>must</b> have a format that supports the sample count specified in {@code rasterizationSamples}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT</li>
            <li>{@code rasterizationSamples} <b>must</b> be a valid {@code VkSampleCountFlagBits} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("multisampledRenderToSingleSampledEnable", "controls whether multisampled rendering to single-sampled attachments is performed as described <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#multisampled-render-to-single-sampled\">below</a>.")
    VkSampleCountFlagBits("rasterizationSamples", "a {@code VkSampleCountFlagBits} specifying the number of samples used in rasterization.")
}

val VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT") {
    documentation =
        """
        Structure describing what extended dynamic state can be used.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceExtendedDynamicState2FeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceExtendedDynamicState2FeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("extendedDynamicState2", """indicates that the implementation supports the following dynamic states:

        <ul>
            <li>#DYNAMIC_STATE_DEPTH_BIAS_ENABLE</li>
            <li>#DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE</li>
            <li>#DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE</li>
        </ul>""")
    VkBool32("extendedDynamicState2LogicOp", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_LOGIC_OP_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState2PatchControlPoints", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT</li>
        </ul>""")
}

val VkPhysicalDeviceColorWriteEnableFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceColorWriteEnableFeaturesEXT") {
    documentation =
        """
        Structure describing whether writes to color attachments can be enabled and disabled dynamically.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceColorWriteEnableFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceColorWriteEnableFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("colorWriteEnable", "indicates that the implementation supports the dynamic state #DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT.")
}

val VkPipelineColorWriteCreateInfoEXT = struct(Module.VULKAN, "VkPipelineColorWriteCreateInfoEXT") {
    documentation =
        """
        Structure specifying color write state of a newly created pipeline.

        <h5>Description</h5>
        When this structure is included in the {@code pNext} chain of ##VkPipelineColorBlendStateCreateInfo, it defines per-attachment color write state. If this structure is not included in the {@code pNext} chain, it is equivalent to specifying this structure with {@code attachmentCount} equal to the {@code attachmentCount} member of ##VkPipelineColorBlendStateCreateInfo, and {@code pColorWriteEnables} pointing to an array of as many #TRUE values.

        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-colorWriteEnable">{@code colorWriteEnable}</a> feature is not enabled on the device, all {@code VkBool32} elements in the {@code pColorWriteEnables} array <b>must</b> be #TRUE.

        Color Write Enable interacts with the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#framebuffer-color-write-mask">Color Write Mask</a> as follows:

        <ul>
            <li>If {@code colorWriteEnable} is #TRUE, writes to the attachment are determined by the {@code colorWriteMask}.</li>
            <li>If {@code colorWriteEnable} is #FALSE, the {@code colorWriteMask} is ignored and writes to all components of the attachment are disabled. This is equivalent to specifying a {@code colorWriteMask} of 0.</li>
        </ul>

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-colorWriteEnable">{@code colorWriteEnable}</a> feature is not enabled, all elements of {@code pColorWriteEnables} <b>must</b> be #TRUE</li>
            <li>If the pipeline is being created with #DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT, #DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT, #DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, or #DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic states not set, {@code attachmentCount} <b>must</b> be equal to the {@code attachmentCount} member of the ##VkPipelineColorBlendStateCreateInfo structure specified during pipeline creation</li>
            <li>{@code attachmentCount} <b>must</b> be less than or equal to the {@code maxColorAttachments} member of ##VkPhysicalDeviceLimits</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT</li>
            <li>If {@code attachmentCount} is not 0, {@code pColorWriteEnables} <b>must</b> be a valid pointer to an array of {@code attachmentCount} {@code VkBool32} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pColorWriteEnables", optional = true)..uint32_t("attachmentCount", "the number of {@code VkBool32} elements in {@code pColorWriteEnables}.")
    VkBool32.const.p("pColorWriteEnables", "a pointer to an array of per target attachment boolean values specifying whether color writes are enabled for the given attachment.")
}

val VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT") {
    documentation =
        """
        Structure describing support for primitives generated query.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("primitivesGeneratedQuery", "indicates whether the implementation supports the #QUERY_TYPE_PRIMITIVES_GENERATED_EXT query type.")
    VkBool32("primitivesGeneratedQueryWithRasterizerDiscard", "indicates whether the implementation supports this query when <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#primsrast-discard\">rasterization discard</a> is enabled.")
    VkBool32("primitivesGeneratedQueryWithNonZeroStreams", "indicates whether the implementation supports this query with a non-zero index in #CmdBeginQueryIndexedEXT().")
}

val VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR") {
    documentation =
        """
        Structure describing the ray tracing maintenance features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rayTracingMaintenance1", """indicates that the implementation supports the following:

        <ul>
            <li>The {@code CullMaskKHR} SPIR-V builtin using the {@code SPV_KHR_ray_cull_mask} SPIR-V extension.</li>
            <li>Additional acceleration structure property queries: #QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR and #QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR.</li>
            <li>A new access flag #ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR.</li>
            <li>A new pipeline stage flag bit #PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR</li>
        </ul>""")
    VkBool32("rayTracingPipelineTraceRaysIndirect2", "indicates whether the implementation supports the extended indirect ray tracing command #CmdTraceRaysIndirect2KHR().")
}

val VkTraceRaysIndirectCommand2KHR = struct(Module.VULKAN, "VkTraceRaysIndirectCommand2KHR") {
    documentation =
        """
        Structure specifying the parameters of an indirect trace ray command with indirect shader binding tables.

        <h5>Description</h5>
        The members of ##VkTraceRaysIndirectCommand2KHR have the same meaning as the similarly named parameters of #CmdTraceRaysKHR().

        Indirect shader binding table buffer parameters must satisfy the same memory alignment and binding requirements as their counterparts in #CmdTraceRaysIndirectKHR() and #CmdTraceRaysKHR().

        <h5>Valid Usage</h5>
        <ul>
            <li>If the buffer from which {@code raygenShaderRecordAddress} was queried is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The buffer from which the {@code raygenShaderRecordAddress} is queried <b>must</b> have been created with the #BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag</li>
            <li>{@code raygenShaderRecordAddress} <b>must</b> be a multiple of ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::shaderGroupBaseAlignment}</li>
            <li>If the buffer from which {@code missShaderBindingTableAddress} was queried is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The buffer from which the {@code missShaderBindingTableAddress} is queried <b>must</b> have been created with the #BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag</li>
            <li>{@code missShaderBindingTableAddress} <b>must</b> be a multiple of ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::shaderGroupBaseAlignment}</li>
            <li>{@code missShaderBindingTableStride} <b>must</b> be a multiple of ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::shaderGroupHandleAlignment}</li>
            <li>{@code missShaderBindingTableStride} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::maxShaderGroupStride}</li>
            <li>If the buffer from which {@code hitShaderBindingTableAddress} was queried is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The buffer from which the {@code hitShaderBindingTableAddress} is queried <b>must</b> have been created with the #BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag</li>
            <li>{@code hitShaderBindingTableAddress} <b>must</b> be a multiple of ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::shaderGroupBaseAlignment}</li>
            <li>{@code hitShaderBindingTableStride} <b>must</b> be a multiple of ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::shaderGroupHandleAlignment}</li>
            <li>{@code hitShaderBindingTableStride} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::maxShaderGroupStride}</li>
            <li>If the buffer from which {@code callableShaderBindingTableAddress} was queried is non-sparse then it <b>must</b> be bound completely and contiguously to a single {@code VkDeviceMemory} object</li>
            <li>The buffer from which the {@code callableShaderBindingTableAddress} is queried <b>must</b> have been created with the #BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag</li>
            <li>{@code callableShaderBindingTableAddress} <b>must</b> be a multiple of ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::shaderGroupBaseAlignment}</li>
            <li>{@code callableShaderBindingTableStride} <b>must</b> be a multiple of ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::shaderGroupHandleAlignment}</li>
            <li>{@code callableShaderBindingTableStride} <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::maxShaderGroupStride}</li>
            <li>If the currently bound ray tracing pipeline was created with {@code flags} that included #PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, {@code hitShaderBindingTableAddress} <b>must</b> not be zero</li>
            <li>If the currently bound ray tracing pipeline was created with {@code flags} that included #PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, {@code hitShaderBindingTableAddress} <b>must</b> not be zero</li>
            <li>If the currently bound ray tracing pipeline was created with {@code flags} that included #PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, the shader group handle identified by {@code missShaderBindingTableAddress} <b>must</b> not be set to zero</li>
            <li>If the currently bound ray tracing pipeline was created with {@code flags} that included #PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, entries in the table identified by {@code hitShaderBindingTableAddress} accessed as a result of this command in order to execute an any-hit shader <b>must</b> not be set to zero</li>
            <li>If the currently bound ray tracing pipeline was created with {@code flags} that included #PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, entries in the table identified by {@code hitShaderBindingTableAddress} accessed as a result of this command in order to execute a closest hit shader <b>must</b> not be set to zero</li>
            <li>If the currently bound ray tracing pipeline was created with {@code flags} that included #PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, entries in the table identified by {@code hitShaderBindingTableAddress} accessed as a result of this command in order to execute an intersection shader <b>must</b> not be set to zero</li>
            <li>Any non-zero hit shader group entries in the table identified by {@code hitShaderBindingTableAddress} accessed by this call from a geometry with a {@code geometryType} of #GEOMETRY_TYPE_TRIANGLES_KHR <b>must</b> have been created with #RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR</li>
            <li>Any non-zero hit shader group entries in the table identified by {@code hitShaderBindingTableAddress} accessed by this call from a geometry with a {@code geometryType} of #GEOMETRY_TYPE_AABBS_KHR <b>must</b> have been created with #RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR</li>
        </ul>

        <ul>
            <li>{@code width} <b>must</b> be less than or equal to <code>##VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] × ##VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]</code></li>
            <li>{@code height} <b>must</b> be less than or equal to <code>##VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] × ##VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]</code></li>
            <li>{@code depth} <b>must</b> be less than or equal to <code>##VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] × ##VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]</code></li>
            <li><code>width × height × depth</code> <b>must</b> be less than or equal to ##VkPhysicalDeviceRayTracingPipelinePropertiesKHR{@code ::maxRayDispatchInvocationCount}</li>
        </ul>
        """

    VkDeviceAddress("raygenShaderRecordAddress", "a {@code VkDeviceAddress} of the ray generation shader binding table record used by this command.")
    VkDeviceSize("raygenShaderRecordSize", "a {@code VkDeviceSize} number of bytes corresponding to the ray generation shader binding table record at base address {@code raygenShaderRecordAddress}.")
    VkDeviceAddress("missShaderBindingTableAddress", "a {@code VkDeviceAddress} of the first record in the miss shader binding table used by this command.")
    VkDeviceSize("missShaderBindingTableSize", "a {@code VkDeviceSize} number of bytes corresponding to the total size of the miss shader binding table at {@code missShaderBindingTableAddress} that may be accessed by this command.")
    VkDeviceSize("missShaderBindingTableStride", "a {@code VkDeviceSize} number of bytes between records of the miss shader binding table.")
    VkDeviceAddress("hitShaderBindingTableAddress", "a {@code VkDeviceAddress} of the first record in the hit shader binding table used by this command.")
    VkDeviceSize("hitShaderBindingTableSize", "a {@code VkDeviceSize} number of bytes corresponding to the total size of the hit shader binding table at {@code hitShaderBindingTableAddress} that may be accessed by this command.")
    VkDeviceSize("hitShaderBindingTableStride", "a {@code VkDeviceSize} number of bytes between records of the hit shader binding table.")
    VkDeviceAddress("callableShaderBindingTableAddress", "a {@code VkDeviceAddress} of the first record in the callable shader binding table used by this command.")
    VkDeviceSize("callableShaderBindingTableSize", "a {@code VkDeviceSize} number of bytes corresponding to the total size of the callable shader binding table at {@code callableShaderBindingTableAddress} that may be accessed by this command.")
    VkDeviceSize("callableShaderBindingTableStride", "a {@code VkDeviceSize} number of bytes between records of the callable shader binding table.")
    uint32_t("width", "the width of the ray trace query dimensions.")
    uint32_t("height", "height of the ray trace query dimensions.")
    uint32_t("depth", "depth of the ray trace query dimensions.")
}

val VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT", alias = VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR) {
    documentation = "See ##VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("globalPriorityQuery", "")
}

val VkQueueFamilyGlobalPriorityPropertiesEXT = struct(Module.VULKAN, "VkQueueFamilyGlobalPriorityPropertiesEXT", alias = VkQueueFamilyGlobalPriorityPropertiesKHR) {
    javaImport("static org.lwjgl.vulkan.KHRGlobalPriority.*")
    documentation = "See ##VkQueueFamilyGlobalPriorityPropertiesKHR."

    Expression("#STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    uint32_t("priorityCount", "")
    VkQueueGlobalPriorityKHR("priorities", "")["VK_MAX_GLOBAL_PRIORITY_SIZE_KHR"]
}

val VkPhysicalDeviceImageViewMinLodFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceImageViewMinLodFeaturesEXT") {
    documentation =
        """
        Structure describing whether clamping the min LOD of a image view is supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageViewMinLodFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceImageViewMinLodFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("minLod", "indicates whether the implementation supports clamping the minimum LOD value during <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-image-level-selection\">Image Level(s) Selection</a>, <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-gather\">Texel Gathering</a> and <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-integer-coordinate-operations\">Integer Texel Coordinate Operations</a> with a given {@code VkImageView} by ##VkImageViewMinLodCreateInfoEXT{@code ::minLod}.")
}

val VkImageViewMinLodCreateInfoEXT = struct(Module.VULKAN, "VkImageViewMinLodCreateInfoEXT") {
    documentation =
        """
        Structure describing the minimum LOD of an image view.

        <h5>Description</h5>
        If the {@code pNext} chain includes a ##VkImageViewMinLodCreateInfoEXT structure, then that structure includes a parameter specifying a value to clamp the minimum LOD value during <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#textures-image-level-selection">Image Level(s) Selection</a>, <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#textures-gather">Texel Gathering</a> and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#textures-integer-coordinate-operations">Integer Texel Coordinate Operations</a>.

        If the image view contains ##VkImageViewMinLodCreateInfoEXT and it is used as part of a sampling operation:

        <code>minLodFloat<sub>imageView</sub> = minLod</code>

        otherwise:

        <code>minLodFloat<sub>imageView</sub> = 0.0</code>

        An integer variant of this parameter is also defined for sampling operations which access integer mipmap levels:

        <code>minLodInteger<sub>imageView</sub> = ⌊minLodFloat<sub>imageView</sub>⌋</code>

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-minLod">{@code minLod}</a> feature is not enabled, {@code minLod} <b>must</b> be {@code 0.0}</li>
            <li>{@code minLod} <b>must</b> be less or equal to the index of the last mipmap level accessible to the view</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    float("minLod", "the value to clamp the minimum LOD accessible by this {@code VkImageView}.")
}

val VkPhysicalDeviceMultiDrawFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMultiDrawFeaturesEXT") {
    documentation =
        """
        Structure describing whether the implementation supports multi draw functionality.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMultiDrawFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMultiDrawFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("multiDraw", "indicates that the implementation supports #CmdDrawMultiEXT() and #CmdDrawMultiIndexedEXT().")
}

val VkPhysicalDeviceMultiDrawPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMultiDrawPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing multidraw limits of an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMultiDrawPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("maxMultiDrawCount", "indicates the maximum number of draw calls which <b>can</b> be batched into a single multidraw.")
}

val VkMultiDrawInfoEXT = struct(Module.VULKAN, "VkMultiDrawInfoEXT") {
    documentation =
        """
        Structure specifying a multi-draw command.

        <h5>Description</h5>
        The members of ##VkMultiDrawInfoEXT have the same meaning as the {@code firstVertex} and {@code vertexCount} parameters in #CmdDraw().

        <h5>See Also</h5>
        #CmdDrawMultiEXT()
        """

    uint32_t("firstVertex", "the first vertex to draw.")
    uint32_t("vertexCount", "the number of vertices to draw.")
}

val VkMultiDrawIndexedInfoEXT = struct(Module.VULKAN, "VkMultiDrawIndexedInfoEXT") {
    documentation =
        """
        Structure specifying a multi-draw command.

        <h5>Description</h5>
        The {@code firstIndex}, {@code indexCount}, and {@code vertexOffset} members of ##VkMultiDrawIndexedInfoEXT have the same meaning as the {@code firstIndex}, {@code indexCount}, and {@code vertexOffset} parameters, respectively, of #CmdDrawIndexed().

        <h5>See Also</h5>
        #CmdDrawMultiIndexedEXT()
        """

    uint32_t("firstIndex", "the first index to draw.")
    uint32_t("indexCount", "the number of vertices to draw.")
    int32_t("vertexOffset", "the value added to the vertex index before indexing into the vertex buffer for indexed multidraws.")
}

val VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT") {
    documentation =
        """
        Structure describing whether single-slice 2D views of 3D images can be used in image descriptors.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImage2DViewOf3DFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceImage2DViewOf3DFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("image2DViewOf3D", "indicates that the implementation supports using a 2D view of a 3D image in a descriptor of type #DESCRIPTOR_TYPE_STORAGE_IMAGE if the image is created using #IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT.")
    VkBool32("sampler2DViewOf3D", "indicates that the implementation supports using a 2D view of a 3D image in a descriptor of type #DESCRIPTOR_TYPE_SAMPLED_IMAGE or #DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the image is created using #IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT.")
}

val VkPhysicalDeviceShaderTileImageFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderTileImageFeaturesEXT") {
    documentation =
        """
        Structure describing tile image features supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderTileImageFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderTileImageFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderTileImageColorReadAccess", "indicates that the implementation supports the {@code TileImageColorReadAccessEXT} SPIR-V capability.")
    VkBool32("shaderTileImageDepthReadAccess", "indicates that the implementation supports the {@code TileImageDepthReadAccessEXT} SPIR-V capability.")
    VkBool32("shaderTileImageStencilReadAccess", "indicates that the implementation supports the {@code TileImageStencilReadAccessEXT} SPIR-V capability.")
}

val VkPhysicalDeviceShaderTileImagePropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderTileImagePropertiesEXT", mutable = false) {
    documentation =
        """
        Structure containing information about tile image support for a physical device.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderTileImagePropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These are properties of the tile image information of a physical device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("shaderTileImageCoherentReadAccelerated", "a boolean that will be #TRUE if coherent reads of tile image data is accelerated.")
    VkBool32("shaderTileImageReadSampleFromPixelRateInvocation", "a boolean that will be #TRUE if reading from samples from a pixel rate fragment invocation is supported when ##VkPipelineMultisampleStateCreateInfo{@code ::rasterizationSamples} &gt; 1.")
    VkBool32("shaderTileImageReadFromHelperInvocation", "a boolean that will be #TRUE if reads of tile image data from helper fragment invocations result in valid values.")
}

val VkMicromapUsageEXT = struct(Module.VULKAN, "VkMicromapUsageEXT") {
    documentation =
        """
        Structure specifying the usage information used to build a micromap.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT then {@code format} <b>must</b> be #OPACITY_MICROMAP_FORMAT_2_STATE_EXT or #OPACITY_MICROMAP_FORMAT_4_STATE_EXT</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT and {@code format} is #OPACITY_MICROMAP_FORMAT_2_STATE_EXT then {@code subdivisionLevel} <b>must</b> be less than or equal to ##VkPhysicalDeviceOpacityMicromapPropertiesEXT{@code ::maxOpacity2StateSubdivisionLevel}</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT and {@code format} is #OPACITY_MICROMAP_FORMAT_4_STATE_EXT then {@code subdivisionLevel} <b>must</b> be less than or equal to ##VkPhysicalDeviceOpacityMicromapPropertiesEXT{@code ::maxOpacity4StateSubdivisionLevel}</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV then {@code format} <b>must</b> be #DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV, #DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV or #DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV then {@code subdivisionLevel} <b>must</b> be less than or equal to ##VkPhysicalDeviceDisplacementMicromapPropertiesNV{@code ::maxDisplacementMicromapSubdivisionLevel}</li>
        </ul>

        The {@code format} is interpreted based on the {@code type} of the micromap using it.

        <h5>See Also</h5>
        ##VkAccelerationStructureTrianglesDisplacementMicromapNV, ##VkAccelerationStructureTrianglesOpacityMicromapEXT, ##VkMicromapBuildInfoEXT
        """

    uint32_t("count", "the number of triangles in the usage format defined by the {@code subdivisionLevel} and {@code format} below in the micromap")
    uint32_t("subdivisionLevel", "the subdivision level of this usage format")
    uint32_t("format", "the format of this usage format")
}

val VkMicromapBuildInfoEXT = struct(Module.VULKAN, "VkMicromapBuildInfoEXT") {
    documentation =
        """
        Structure specifying the  data used to build a micromap.

        <h5>Description</h5>
        Only one of {@code pUsageCounts} or {@code ppUsageCounts} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}. The elements of the non-{@code NULL} array describe the total counts used to build each micromap. Each element contains a {@code count} which is the number of micromap triangles of that {@code format} and {@code subdivisionLevel} contained in the micromap. Multiple elements with the same {@code format} and {@code subdivisionLevel} are allowed and the total count for that {@code format} and {@code subdivisionLevel} is the sum of the {@code count} for each element.

        Each micromap triangle refers to one element in {@code triangleArray} which contains the {@code format} and {@code subdivisionLevel} for that particular triangle as well as a {@code dataOffset} in bytes which is the location relative to {@code data} where that triangle’s micromap data begins. The data at {@code triangleArray} is laid out as a 4 byte unsigned integer for the {@code dataOffset} followed by a 2 byte unsigned integer for the subdivision level then a 2 byte unsigned integer for the format. In practice, compilers compile ##VkMicromapTriangleEXT to match this pattern.

        For opacity micromaps, the data at {@code data} is packed as either one bit per element for #OPACITY_MICROMAP_FORMAT_2_STATE_EXT or two bits per element for #OPACITY_MICROMAP_FORMAT_4_STATE_EXT and is packed from LSB to MSB in each byte. The data at each index in those bytes is interpreted as discussed in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#ray-opacity-micromap">Ray Opacity Micromap</a>.

        For displacement micromaps, the data at {@code data} is interpreted as discussed in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#displacement-micromap-encoding">Displacement Micromap Encoding</a>.

        <h5>Valid Usage</h5>
        <ul>
            <li>Only one of {@code pUsageCounts} or {@code ppUsageCounts} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}</li>
            <li>If {@code type} is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT the {@code format} member of ##VkMicromapUsageEXT <b>must</b> be a valid value from {@code VkOpacityMicromapFormatEXT}</li>
            <li>If {@code type} is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT the {@code format} member of ##VkMicromapTriangleEXT <b>must</b> be a valid value from {@code VkOpacityMicromapFormatEXT}</li>
            <li>If {@code type} is #MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV the {@code format} member of ##VkMicromapUsageEXT <b>must</b> be a valid value from {@code VkDisplacementMicromapFormatNV}</li>
            <li>If {@code type} is #MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV the {@code format} member of ##VkMicromapTriangleEXT <b>must</b> be a valid value from {@code VkDisplacementMicromapFormatNV}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code type} <b>must</b> be a valid {@code VkMicromapTypeEXT} value</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkBuildMicromapFlagBitsEXT} values</li>
            <li>If {@code usageCountsCount} is not 0, and {@code pUsageCounts} is not {@code NULL}, {@code pUsageCounts} <b>must</b> be a valid pointer to an array of {@code usageCountsCount} ##VkMicromapUsageEXT structures</li>
            <li>If {@code usageCountsCount} is not 0, and {@code ppUsageCounts} is not {@code NULL}, {@code ppUsageCounts} <b>must</b> be a valid pointer to an array of {@code usageCountsCount} valid pointers to ##VkMicromapUsageEXT structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstKHR, ##VkDeviceOrHostAddressKHR, ##VkMicromapUsageEXT, #BuildMicromapsEXT(), #CmdBuildMicromapsEXT(), #GetMicromapBuildSizesEXT()
        """

    Expression("#STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMicromapTypeEXT("type", "a {@code VkMicromapTypeEXT} value specifying the type of micromap being built.")
    VkBuildMicromapFlagsEXT("flags", "a bitmask of {@code VkBuildMicromapFlagBitsEXT} specifying additional parameters of the micromap.")
    VkBuildMicromapModeEXT("mode", "a {@code VkBuildMicromapModeEXT} value specifying the type of operation to perform.")
    VkMicromapEXT("dstMicromap", "a pointer to the target micromap for the build.")
    AutoSize("pUsageCounts", "ppUsageCounts", optional = true)..uint32_t("usageCountsCount", "specifies the number of usage counts structures that will be used to determine the size of this micromap.")
    nullable..VkMicromapUsageEXT.const.p("pUsageCounts", "a pointer to an array of ##VkMicromapUsageEXT structures.")
    nullable..VkMicromapUsageEXT.const.p.const.p("ppUsageCounts", "a pointer to an array of pointers to ##VkMicromapUsageEXT structures.")
    VkDeviceOrHostAddressConstKHR("data", "the device or host address to memory which contains the data for the micromap.")
    VkDeviceOrHostAddressKHR("scratchData", "the device or host address to memory that will be used as scratch memory for the build.")
    VkDeviceOrHostAddressConstKHR("triangleArray", "the device or host address to memory containing the ##VkMicromapTriangleEXT data")
    VkDeviceSize("triangleArrayStride", "the stride in bytes between each element of {@code triangleArray}")
}

val VkMicromapCreateInfoEXT = struct(Module.VULKAN, "VkMicromapCreateInfoEXT") {
    documentation =
        """
        Structure specifying the parameters of a newly created micromap object.

        <h5>Description</h5>
        If {@code deviceAddress} is zero, no specific address is requested.

        If {@code deviceAddress} is not zero, {@code deviceAddress} <b>must</b> be an address retrieved from an identically created micromap on the same implementation. The micromap <b>must</b> also be placed on an identically created {@code buffer} and at the same {@code offset}.

        Applications <b>should</b> avoid creating micromaps with application-provided addresses and implementation-provided addresses in the same process, to reduce the likelihood of #ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR errors.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The expected usage for this is that a trace capture/replay tool will add the #BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT flag to all buffers that use #BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, and will add #BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT to all buffers used as storage for a micromap where {@code deviceAddress} is not zero. This also means that the tool will need to add #MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT to memory allocations to allow the flag to be set where the application may not have otherwise required it. During capture the tool will save the queried opaque device addresses in the trace. During replay, the buffers will be created specifying the original address so any address values stored in the trace data will remain valid.

        Implementations are expected to separate such buffers in the GPU address space so normal allocations will avoid using these addresses. Apps/tools should avoid mixing app-provided and implementation-provided addresses for buffers created with #BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, to avoid address space allocation conflicts.
        </div>

        If the micromap will be the target of a build operation, the required size for a micromap <b>can</b> be queried with #GetMicromapBuildSizesEXT().

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code deviceAddress} is not zero, {@code createFlags} <b>must</b> include #MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT</li>
            <li>If {@code createFlags} includes #MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT, ##VkPhysicalDeviceOpacityMicromapFeaturesEXT{@code ::micromapCaptureReplay} <b>must</b> be #TRUE</li>
            <li>{@code buffer} <b>must</b> have been created with a {@code usage} value containing #BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT</li>
            <li>{@code buffer} <b>must</b> not have been created with #BUFFER_CREATE_SPARSE_RESIDENCY_BIT</li>
            <li>The sum of {@code offset} and {@code size} <b>must</b> be less than the size of {@code buffer}</li>
            <li>{@code offset} <b>must</b> be a multiple of 256 bytes</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code createFlags} <b>must</b> be a valid combination of {@code VkMicromapCreateFlagBitsEXT} values</li>
            <li>{@code buffer} <b>must</b> be a valid {@code VkBuffer} handle</li>
            <li>{@code type} <b>must</b> be a valid {@code VkMicromapTypeEXT} value</li>
        </ul>

        <h5>See Also</h5>
        #CreateMicromapEXT()
        """

    Expression("#STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMicromapCreateFlagsEXT("createFlags", "a bitmask of {@code VkMicromapCreateFlagBitsEXT} specifying additional creation parameters of the micromap.")
    VkBuffer("buffer", "the buffer on which the micromap will be stored.")
    VkDeviceSize("offset", "an offset in bytes from the base address of the buffer at which the micromap will be stored, and <b>must</b> be a multiple of 256.")
    VkDeviceSize("size", "the size required for the micromap.")
    VkMicromapTypeEXT("type", "a {@code VkMicromapTypeEXT} value specifying the type of micromap that will be created.")
    VkDeviceAddress("deviceAddress", "the device address requested for the micromap if the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#features-micromapCaptureReplay\">{@code micromapCaptureReplay}</a> feature is being used.")
}

val VkPhysicalDeviceOpacityMicromapFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceOpacityMicromapFeaturesEXT") {
    documentation =
        """
        Structure describing the ray tracing opacity micromap features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceOpacityMicromapFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceOpacityMicromapFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("micromap", "indicates whether the implementation supports the micromap array feature.")
    VkBool32("micromapCaptureReplay", "indicates whether the implementation supports capture and replay of addresses for micromap arrays.")
    VkBool32("micromapHostCommands", "indicates whether the implementation supports host side micromap array commands.")
}

val VkPhysicalDeviceOpacityMicromapPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceOpacityMicromapPropertiesEXT", mutable = false) {
    documentation =
        """
        Structure describing the opacity micromap properties of a physical device.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceOpacityMicromapPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxOpacity2StateSubdivisionLevel", "the maximum allowed {@code subdivisionLevel} when {@code format} is #OPACITY_MICROMAP_FORMAT_2_STATE_EXT")
    uint32_t("maxOpacity4StateSubdivisionLevel", "the maximum allowed {@code subdivisionLevel} when {@code format} is #OPACITY_MICROMAP_FORMAT_4_STATE_EXT")
}

val VkMicromapVersionInfoEXT = struct(Module.VULKAN, "VkMicromapVersionInfoEXT") {
    documentation =
        """
        Micromap version information.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        {@code pVersionData} is a <em>pointer</em> to an array of 2×#UUID_SIZE {@code uint8_t} values instead of two #UUID_SIZE arrays as the expected use case for this member is to be pointed at the header of a previously serialized micromap (via #CmdCopyMicromapToMemoryEXT() or #CopyMicromapToMemoryEXT()) that is loaded in memory. Using arrays would necessitate extra memory copies of the UUIDs.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pVersionData} <b>must</b> be a valid pointer to an array of 2 &times; {@code VK_UUID_SIZE} {@code uint8_t} values</li>
        </ul>

        <h5>See Also</h5>
        #GetDeviceMicromapCompatibilityEXT()
        """

    Expression("#STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint8_t.const.p("pVersionData", "a pointer to the version header of a micromap as defined in #CmdCopyMicromapToMemoryEXT()")
}

val VkCopyMicromapToMemoryInfoEXT = struct(Module.VULKAN, "VkCopyMicromapToMemoryInfoEXT") {
    documentation =
        """
        Parameters for serializing a micromap.

        <h5>Valid Usage</h5>
        <ul>
            <li>The source micromap {@code src} <b>must</b> have been constructed prior to the execution of this command</li>
            <li>The memory pointed to by {@code dst} <b>must</b> be at least as large as the serialization size of {@code src}, as reported by #WriteMicromapsPropertiesEXT() or #CmdWriteMicromapsPropertiesEXT() with a query type of #QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT</li>
            <li>{@code mode} <b>must</b> be #COPY_MICROMAP_MODE_SERIALIZE_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code src} <b>must</b> be a valid {@code VkMicromapEXT} handle</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkCopyMicromapModeEXT} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressKHR, #CmdCopyMicromapToMemoryEXT(), #CopyMicromapToMemoryEXT()
        """

    Expression("#STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMicromapEXT("src", "the source micromap for the copy")
    VkDeviceOrHostAddressKHR("dst", "the device or host address to memory which is the target for the copy")
    VkCopyMicromapModeEXT("mode", "a {@code VkCopyMicromapModeEXT} value specifying additional operations to perform during the copy.")
}

val VkCopyMemoryToMicromapInfoEXT = struct(Module.VULKAN, "VkCopyMemoryToMicromapInfoEXT") {
    documentation =
        """
        Parameters for deserializing a micromap.

        <h5>Valid Usage</h5>
        <ul>
            <li>The source memory pointed to by {@code src} <b>must</b> contain data previously serialized using #CmdCopyMicromapToMemoryEXT()</li>
            <li>{@code mode} <b>must</b> be #COPY_MICROMAP_MODE_DESERIALIZE_EXT</li>
            <li>The data in {@code src} <b>must</b> have a format compatible with the destination physical device as returned by #GetDeviceMicromapCompatibilityEXT()</li>
            <li>{@code dst} <b>must</b> have been created with a {@code size} greater than or equal to that used to serialize the data in {@code src}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code dst} <b>must</b> be a valid {@code VkMicromapEXT} handle</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkCopyMicromapModeEXT} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstKHR, #CmdCopyMemoryToMicromapEXT(), #CopyMemoryToMicromapEXT()
        """

    Expression("#STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceOrHostAddressConstKHR("src", "the device or host address to memory containing the source data for the copy.")
    VkMicromapEXT("dst", "the target micromap for the copy.")
    VkCopyMicromapModeEXT("mode", "a {@code VkCopyMicromapModeEXT} value specifying additional operations to perform during the copy.")
}

val VkCopyMicromapInfoEXT = struct(Module.VULKAN, "VkCopyMicromapInfoEXT") {
    documentation =
        """
        Parameters for copying a micromap.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code mode} <b>must</b> be #COPY_MICROMAP_MODE_COMPACT_EXT or #COPY_MICROMAP_MODE_CLONE_EXT</li>
            <li>The source acceleration structure {@code src} <b>must</b> have been constructed prior to the execution of this command</li>
            <li>If {@code mode} is #COPY_MICROMAP_MODE_COMPACT_EXT, {@code src} <b>must</b> have been constructed with #BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT in the build</li>
            <li>The {@code buffer} used to create {@code src} <b>must</b> be bound to device memory</li>
            <li>The {@code buffer} used to create {@code dst} <b>must</b> be bound to device memory</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code src} <b>must</b> be a valid {@code VkMicromapEXT} handle</li>
            <li>{@code dst} <b>must</b> be a valid {@code VkMicromapEXT} handle</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkCopyMicromapModeEXT} value</li>
            <li>Both of {@code dst}, and {@code src} <b>must</b> have been created, allocated, or retrieved from the same {@code VkDevice}</li>
        </ul>

        <h5>See Also</h5>
        #CmdCopyMicromapEXT(), #CopyMicromapEXT()
        """

    Expression("#STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkMicromapEXT("src", "the source micromap for the copy.")
    VkMicromapEXT("dst", "the target micromap for the copy.")
    VkCopyMicromapModeEXT("mode", "a {@code VkCopyMicromapModeEXT} value specifying additional operations to perform during the copy.")
}

val VkMicromapBuildSizesInfoEXT = struct(Module.VULKAN, "VkMicromapBuildSizesInfoEXT") {
    documentation =
        """
        Structure specifying build sizes for a micromap.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetMicromapBuildSizesEXT()
        """

    Expression("#STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDeviceSize("micromapSize", "the size in bytes required in a {@code VkMicromapEXT} for a build or update operation.")
    VkDeviceSize("buildScratchSize", "the size in bytes required in a scratch buffer for a build operation.")
    VkBool32("discardable", "indicates whether or not the micromap object may be destroyed after an acceleration structure build or update. A false value means that acceleration structures built with this micromap <b>may</b> contain references to the data contained therein, and the application <b>must</b> not destroy the micromap until ray traversal has concluded. A true value means that the information in the micromap will be copied by value into the acceleration structure, and the micromap <b>may</b> be destroyed after the acceleration structure build concludes.")
}

val VkAccelerationStructureTrianglesOpacityMicromapEXT = struct(Module.VULKAN, "VkAccelerationStructureTrianglesOpacityMicromapEXT") {
    documentation =
        """
        Structure specifying an opacity micromap in a bottom-level acceleration structure.

        <h5>Description</h5>
        If ##VkAccelerationStructureTrianglesOpacityMicromapEXT is included in the {@code pNext} chain of a ##VkAccelerationStructureGeometryTrianglesDataKHR structure, that geometry will reference that micromap.

        For each triangle in the geometry, the acceleration structure build fetches an index from {@code indexBuffer} using {@code indexType} and {@code indexStride}. If that value is the unsigned cast of one of the values from {@code VkOpacityMicromapSpecialIndexEXT} then that triangle behaves as described for that special value in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#ray-opacity-micromap">Ray Opacity Micromap</a>. Otherwise that triangle uses the opacity micromap information from {@code micromap} at that index plus {@code baseTriangle}.

        Only one of {@code pUsageCounts} or {@code ppUsageCounts} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}. The elements of the non-{@code NULL} array describe the total count used to build this geometry. For a given {@code format} and {@code subdivisionLevel} the number of triangles in this geometry matching those values after indirection and special index handling <b>must</b> be equal to the sum of matching {@code count} provided.

        If {@code micromap} is #NULL_HANDLE, then every value read from {@code indexBuffer} <b>must</b> be one of the values in {@code VkOpacityMicromapSpecialIndexEXT}.

        <h5>Valid Usage</h5>
        <ul>
            <li>Only one of {@code pUsageCounts} or {@code ppUsageCounts} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT</li>
            <li>{@code indexType} <b>must</b> be a valid {@code VkIndexType} value</li>
            <li>If {@code usageCountsCount} is not 0, and {@code pUsageCounts} is not {@code NULL}, {@code pUsageCounts} <b>must</b> be a valid pointer to an array of {@code usageCountsCount} ##VkMicromapUsageEXT structures</li>
            <li>If {@code usageCountsCount} is not 0, and {@code ppUsageCounts} is not {@code NULL}, {@code ppUsageCounts} <b>must</b> be a valid pointer to an array of {@code usageCountsCount} valid pointers to ##VkMicromapUsageEXT structures</li>
            <li>If {@code micromap} is not #NULL_HANDLE, {@code micromap} <b>must</b> be a valid {@code VkMicromapEXT} handle</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstKHR, ##VkMicromapUsageEXT
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkIndexType("indexType", "the type of triangle indices used when indexing this micromap")
    VkDeviceOrHostAddressConstKHR("indexBuffer", "the address containing the triangle indices")
    VkDeviceSize("indexStride", "the byte stride between triangle indices")
    uint32_t("baseTriangle", "the base value added to the non-negative triangle indices")
    AutoSize("pUsageCounts", "ppUsageCounts", optional = true)..uint32_t("usageCountsCount", "specifies the number of usage counts structures that will be used to determine the size of this micromap.")
    nullable..VkMicromapUsageEXT.const.p("pUsageCounts", "a pointer to an array of ##VkMicromapUsageEXT structures.")
    nullable..VkMicromapUsageEXT.const.p.const.p("ppUsageCounts", "a pointer to an array of pointers to ##VkMicromapUsageEXT structures.")
    VkMicromapEXT("micromap", "the handle to the micromap object to include in this geometry")
}

val VkMicromapTriangleEXT = struct(Module.VULKAN, "VkMicromapTriangleEXT") {
    documentation =
        """
        Structure specifying the micromap format and data for a triangle.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT then {@code format} <b>must</b> be #OPACITY_MICROMAP_FORMAT_2_STATE_EXT or #OPACITY_MICROMAP_FORMAT_4_STATE_EXT</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT and {@code format} is #OPACITY_MICROMAP_FORMAT_2_STATE_EXT then {@code subdivisionLevel} <b>must</b> be less than or equal to ##VkPhysicalDeviceOpacityMicromapPropertiesEXT{@code ::maxOpacity2StateSubdivisionLevel}</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_OPACITY_MICROMAP_EXT and {@code format} is #OPACITY_MICROMAP_FORMAT_4_STATE_EXT then {@code subdivisionLevel} <b>must</b> be less than or equal to ##VkPhysicalDeviceOpacityMicromapPropertiesEXT{@code ::maxOpacity4StateSubdivisionLevel}</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV then {@code format} <b>must</b> be #DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV, #DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV or #DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV</li>
            <li>If the {@code VkMicromapTypeEXT} of the micromap is #MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV then {@code subdivisionLevel} <b>must</b> be less than or equal to ##VkPhysicalDeviceDisplacementMicromapPropertiesNV{@code ::maxDisplacementMicromapSubdivisionLevel}</li>
        </ul>

        The {@code format} is interpreted based on the {@code type} of the micromap using it.
        """

    uint32_t("dataOffset", "the offset in bytes of the start of the data for this triangle. This is a byte aligned value.")
    uint16_t("subdivisionLevel", "the subdivision level of this triangle")
    uint16_t("format", "the format of this triangle")
}

val VkPhysicalDeviceDisplacementMicromapFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceDisplacementMicromapFeaturesNV") {
    documentation =
        """
        Structure describing the ray tracing displacement micromap features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDisplacementMicromapFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDisplacementMicromapFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("displacementMicromap", "indicates whether the implementation supports the displacement micromap feature.")
}

val VkPhysicalDeviceDisplacementMicromapPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceDisplacementMicromapPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing the displacement micromap properties of a physical device.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDisplacementMicromapPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxDisplacementMicromapSubdivisionLevel", "the maximum allowed {@code subdivisionLevel} for displacement micromaps.")
}

val VkAccelerationStructureTrianglesDisplacementMicromapNV = struct(Module.VULKAN, "VkAccelerationStructureTrianglesDisplacementMicromapNV") {
    documentation =
        """
        Structure specifying a displacement micromap in a bottom-level acceleration structure.

        <h5>Description</h5>
        If ##VkAccelerationStructureTrianglesDisplacementMicromapNV is included in the {@code pNext} chain of a ##VkAccelerationStructureGeometryTrianglesDataKHR structure, that geometry will reference that micromap.

        For each triangle in the geometry, the acceleration structure build fetches an index from {@code indexBuffer} using {@code indexType} and {@code indexStride}. That triangle uses the displacement micromap information from {@code micromap} at that index plus {@code baseTriangle}.

        Only one of {@code pUsageCounts} or {@code ppUsageCounts} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}. The elements of the non-{@code NULL} array describe the total count used to build this geometry. For a given {@code format} and {@code subdivisionLevel} the number of triangles in this geometry matching those values after indirection <b>must</b> be equal to the sum of matching {@code count} provided.

        <h5>Valid Usage</h5>
        <ul>
            <li>Only one of {@code pUsageCounts} or {@code ppUsageCounts} <b>can</b> be a valid pointer, the other <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV</li>
            <li>{@code displacementBiasAndScaleFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code displacementVectorFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code indexType} <b>must</b> be a valid {@code VkIndexType} value</li>
            <li>If {@code usageCountsCount} is not 0, and {@code pUsageCounts} is not {@code NULL}, {@code pUsageCounts} <b>must</b> be a valid pointer to an array of {@code usageCountsCount} ##VkMicromapUsageEXT structures</li>
            <li>If {@code usageCountsCount} is not 0, and {@code ppUsageCounts} is not {@code NULL}, {@code ppUsageCounts} <b>must</b> be a valid pointer to an array of {@code usageCountsCount} valid pointers to ##VkMicromapUsageEXT structures</li>
            <li>If {@code micromap} is not #NULL_HANDLE, {@code micromap} <b>must</b> be a valid {@code VkMicromapEXT} handle</li>
        </ul>

        <h5>See Also</h5>
        ##VkDeviceOrHostAddressConstKHR, ##VkMicromapUsageEXT
        """

    Expression("#STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkFormat("displacementBiasAndScaleFormat", "the format of displacement bias and scale used in this displacement micromap reference.")
    VkFormat("displacementVectorFormat", "the format of displacement vector used in this displacement micromap reference.")
    VkDeviceOrHostAddressConstKHR("displacementBiasAndScaleBuffer", "the address containing the bias and scale.")
    VkDeviceSize("displacementBiasAndScaleStride", "the byte stride between bias and scale values.")
    VkDeviceOrHostAddressConstKHR("displacementVectorBuffer", "the address containing the displacement vector values.")
    VkDeviceSize("displacementVectorStride", "the byte stride between displacement vector values.")
    VkDeviceOrHostAddressConstKHR("displacedMicromapPrimitiveFlags", "the address containing the primitive flags.")
    VkDeviceSize("displacedMicromapPrimitiveFlagsStride", "the byte stride between primitive flag values.")
    VkIndexType("indexType", "the type of triangle indices used when indexing this micromap.")
    VkDeviceOrHostAddressConstKHR("indexBuffer", "the address containing the triangle indices.")
    VkDeviceSize("indexStride", "the byte stride between triangle indices.")
    uint32_t("baseTriangle", "the base value added to the non-negative triangle indices.")
    AutoSize("pUsageCounts", "ppUsageCounts", optional = true)..uint32_t("usageCountsCount", "specifies the number of usage counts structures that will be used to determine the size of this micromap.")
    nullable..VkMicromapUsageEXT.const.p("pUsageCounts", "a pointer to an array of ##VkMicromapUsageEXT structures.")
    nullable..VkMicromapUsageEXT.const.p.const.p("ppUsageCounts", "a pointer to an array of pointers to ##VkMicromapUsageEXT structures.")
    VkMicromapEXT("micromap", "the handle to the micromap object to include in this geometry.")
}

val VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI = struct(Module.VULKAN, "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI") {
    documentation =
        """
        Structure describing whether cluster culling shader is enabled.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("clustercullingShader", "specifies whether cluster culling shader is supported.")
    VkBool32("multiviewClusterCullingShader", "specifies whether multiview is supported.")
}

val VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI = struct(Module.VULKAN, "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI", mutable = false) {
    documentation =
        """
        Structure describing cluster culling shader properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxWorkGroupCount", "the maximum number of local workgroups that can be launched by a single command. These three value represent the maximum local workgroup count in the X, Y and Z dimensions, respectively. In the current implementation, the values of Y and Z are both implicitly set as one. groupCountX of DrawCluster command must be less than or equal to maxWorkGroupCount[0].")[3]
    uint32_t("maxWorkGroupSize", "the maximum size of a local workgroup. These three value represent the maximum local workgroup size in the X, Y and Z dimensions, respectively. The x, y and z sizes, as specified by the {@code LocalSize} or {@code LocalSizeId} execution mode or by the object decorated by the WorkgroupSize decoration in shader modules, must be less than or equal to the corresponding limit. In the current implementation, the maximum workgroup size of the X dimension is 32, the others are 1.")[3]
    uint32_t("maxOutputClusterCount", "the maximum number of output cluster a single cluster culling shader workgroup can emit.")
    VkDeviceSize("indirectBufferOffsetAlignment", "indicates the alignment for cluster drawing command buffer stride. #CmdDrawClusterIndirectHUAWEI(){@code ::offset} must be a multiple of this value.")
}

val VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT") {
    documentation =
        """
        Structure describing whether samplers with custom border colors require the component swizzle specified in order to have defined behavior.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceBorderColorSwizzleFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceBorderColorSwizzleFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("borderColorSwizzle", "indicates that defined values are returned by sampled image operations when used with a sampler that uses a #BORDER_COLOR_FLOAT_OPAQUE_BLACK, #BORDER_COLOR_INT_OPAQUE_BLACK, #BORDER_COLOR_FLOAT_CUSTOM_EXT, or #BORDER_COLOR_INT_CUSTOM_EXT {@code borderColor} and an image view that uses a non-<a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#resources-image-views-identity-mappings\">identity component mapping</a>, when either {@code borderColorSwizzleFromImage} is enabled or the ##VkSamplerBorderColorComponentMappingCreateInfoEXT is specified.")
    VkBool32("borderColorSwizzleFromImage", "indicates that the implementation will return the correct border color values from sampled image operations under the conditions expressed above, without the application having to specify the border color component mapping when creating the sampler object. If this feature bit is not set, applications <b>can</b> chain a ##VkSamplerBorderColorComponentMappingCreateInfoEXT structure when creating samplers for use with image views that do not have an <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#resources-image-views-identity-mappings\">identity swizzle</a> and, when those samplers are combined with image views using the same component mapping, sampled image operations that use opaque black or custom border colors will return the correct border color values.")
}

val VkSamplerBorderColorComponentMappingCreateInfoEXT = struct(Module.VULKAN, "VkSamplerBorderColorComponentMappingCreateInfoEXT") {
    documentation =
        """
        Structure specifying the component mapping of the border color.

        <h5>Description</h5>
        The ##VkComponentMapping {@code components} member describes a remapping from components of the border color to components of the vector returned by shader image instructions when the border color is used.

        <h5>Valid Usage</h5>
        <ul>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-borderColorSwizzle">{@code borderColorSwizzle}</a> feature <b>must</b> be enabled</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT</li>
            <li>{@code components} <b>must</b> be a valid ##VkComponentMapping structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkComponentMapping
        """

    Expression("#STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkComponentMapping("components", "a ##VkComponentMapping structure specifying a remapping of the border color components.")
    VkBool32("srgb", "indicates that the sampler will be combined with an image view that has an image format which is sRGB encoded.")
}

val VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT") {
    documentation =
        """
        Structure describing whether the implementation supports pageable device-local memory.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("pageableDeviceLocalMemory", "indicates that the implementation supports pageable device-local memory and <b>may</b> transparently move device-local memory allocations to host-local memory to better share device-local memory with other applications.")
}

val VkPhysicalDeviceMaintenance4FeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceMaintenance4FeaturesKHR", alias = VkPhysicalDeviceMaintenance4Features) {
    documentation = "See ##VkPhysicalDeviceMaintenance4Features."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("maintenance4", "")
}

val VkPhysicalDeviceMaintenance4PropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceMaintenance4PropertiesKHR", mutable = false, alias = VkPhysicalDeviceMaintenance4Properties) {
    documentation = "See ##VkPhysicalDeviceMaintenance4Properties."

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkDeviceSize("maxBufferSize", "")
}

val VkDeviceBufferMemoryRequirementsKHR = struct(Module.VULKAN, "VkDeviceBufferMemoryRequirementsKHR", alias = VkDeviceBufferMemoryRequirements) {
    documentation = "See ##VkDeviceBufferMemoryRequirements."

    Expression("#STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkBufferCreateInfo.const.p("pCreateInfo", "")
}

val VkDeviceImageMemoryRequirementsKHR = struct(Module.VULKAN, "VkDeviceImageMemoryRequirementsKHR", alias = VkDeviceImageMemoryRequirements) {
    documentation = "See ##VkDeviceImageMemoryRequirements."

    Expression("#STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkImageCreateInfo.const.p("pCreateInfo", "")
    VkImageAspectFlagBits("planeAspect", "")
}

val VkPhysicalDeviceShaderCorePropertiesARM = struct(Module.VULKAN, "VkPhysicalDeviceShaderCorePropertiesARM", mutable = false) {
    documentation =
        """
        Structure describing shader core properties that can be supported by an implementation.

        <h5>Description</h5>
        If a throughput rate cannot be determined on the physical device, the value 0 will be returned for that rate.

        If the ##VkPhysicalDeviceShaderCorePropertiesARM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("pixelRate", "an unsigned integer value indicating the maximum number of pixels output per clock per shader core.")
    uint32_t("texelRate", "an unsigned integer value indicating the maximum number of texels per clock per shader core.")
    uint32_t("fmaRate", "an unsigned integer value indicating the maximum number of single-precision fused multiply-add operations per clock per shader core.")
}

val VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT") {
    documentation =
        """
        Structure describing whether slice-based views of 3D images can be used in storage image descriptors.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("imageSlicedViewOf3D", "indicates that the implementation supports using a sliced view of a 3D image in a descriptor of type #DESCRIPTOR_TYPE_STORAGE_IMAGE by using a ##VkImageViewSlicedCreateInfoEXT structure when creating the view.")
}

val VkImageViewSlicedCreateInfoEXT = struct(Module.VULKAN, "VkImageViewSlicedCreateInfoEXT") {
    documentation =
        """
        Specify the subset of 3D slices of an image view.

        <h5>Description</h5>
        When this structure is chained to ##VkImageViewCreateInfo the {@code sliceOffset} field is treated as a Z-offset for the sliced view and {@code sliceCount} specifies the range. Shader accesses using a Z coordinate of 0 will access the depth slice corresponding to {@code sliceOffset} in the image, and in a shader, the maximum in-bounds Z coordinate for the view is <code>sliceCount - 1</code>.

        A sliced 3D view <b>must</b> only be used with a single mip level. The slice coordinates are integer coordinates within the {@code subresourceRange.baseMipLevel} used to create the image view.

        The effective view depth is equal to {@code extent.depth} used to create the {@code image} for this view adjusted by {@code subresourceRange.baseMipLevel} as specified in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#resources-image-mip-level-sizing">Image Mip Level Sizing</a>.

        Shader access to this image view is only affected by ##VkImageViewSlicedCreateInfoEXT if it uses a descriptor of type #DESCRIPTOR_TYPE_STORAGE_IMAGE. For access using any other descriptor type, the contents of ##VkImageViewSlicedCreateInfoEXT are ignored; instead, {@code sliceOffset} is treated as being equal to 0, and {@code sliceCount} is treated as being equal to #REMAINING_3D_SLICES_EXT.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code sliceOffset} <b>must</b> be less than the effective view depth as specified in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#resources-image-mip-level-sizing">Image Mip Level Sizing</a></li>
            <li>If {@code sliceCount} is not #REMAINING_3D_SLICES_EXT, it <b>must</b> be be non-zero and <code>sliceOffset + sliceCount</code> <b>must</b> be less than or equal to the effective view depth as specified in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#resources-image-mip-level-sizing">Image Mip Level Sizing</a></li>
            <li>{@code image} <b>must</b> have been created with {@code imageType} equal to #IMAGE_TYPE_3D</li>
            <li>{@code viewType} <b>must</b> be #IMAGE_VIEW_TYPE_3D</li>
            <li>The image view <b>must</b> reference exactly 1 mip level</li>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-imageSlicedViewOf3D">imageSlicedViewOf3D</a> feature <b>must</b> be enabled on the device</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("sliceOffset", "the Z-offset for the first 3D slice accessible to the image view.")
    uint32_t("sliceCount", "the number of 3D slices accessible to the image view.")
}

val VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = struct(Module.VULKAN, "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE") {
    documentation =
        """
        Stub description of VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("descriptorSetHostMapping", "")
}

val VkDescriptorSetBindingReferenceVALVE = struct(Module.VULKAN, "VkDescriptorSetBindingReferenceVALVE") {
    documentation =
        """
        Stub description of VkDescriptorSetBindingReferenceVALVE.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code descriptorSetLayout} <b>must</b> be a valid {@code VkDescriptorSetLayout} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetDescriptorSetLayoutHostMappingInfoVALVE()
        """

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkDescriptorSetLayout("descriptorSetLayout", "")
    uint32_t("binding", "")
}

val VkDescriptorSetLayoutHostMappingInfoVALVE = struct(Module.VULKAN, "VkDescriptorSetLayoutHostMappingInfoVALVE") {
    documentation =
        """
        Stub description of VkDescriptorSetLayoutHostMappingInfoVALVE.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetDescriptorSetLayoutHostMappingInfoVALVE()
        """

    Expression("#STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    size_t("descriptorOffset", "")
    uint32_t("descriptorSize", "")
}

val VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDepthClampZeroOneFeaturesEXT") {
    documentation =
        """
        Structure describing feature to control zero to one depth clamping.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDepthClampZeroOneFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDepthClampZeroOneFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("depthClampZeroOne", "indicates that the implementation supports clamping the depth to a range of 0 to 1.")
}

val VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT") {
    documentation =
        """
        Structure describing features to disable seamless cube maps.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("nonSeamlessCubeMap", "indicates that the implementation supports #SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT.")
}

val VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM") {
    documentation =
        """
        Structure describing fragment density map offset features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("fragmentDensityMapOffset", "")
}

val VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM", mutable = false) {
    documentation =
        """
        Structure describing fragment density map offset properties that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkExtent2D("fragmentDensityOffsetGranularity", "the granularity for <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#renderpass-fragmentdensitymapoffsets\">fragment density offsets</a>.")
}

val VkSubpassFragmentDensityMapOffsetEndInfoQCOM = struct(Module.VULKAN, "VkSubpassFragmentDensityMapOffsetEndInfoQCOM") {
    documentation =
        """
        Structure specifying fragment density map offset subpass end information.

        <h5>Description</h5>
        The array elements are given per {@code layer} as defined by <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#fragmentdensitymap-fetch-density-value">Fetch Density Value</a>, where <code>index = layer</code>. Each <code>(x,y)</code> offset is in framebuffer pixels and shifts the fetch of the fragment density map by that amount. Offsets can be positive or negative.

        Offset values specified for any subpass that is not the last subpass in the render pass are ignored. If the ##VkSubpassEndInfo{@code ::pNext} chain for the last subpass of a render pass does not include ##VkSubpassFragmentDensityMapOffsetEndInfoQCOM, or if {@code fragmentDensityOffsetCount} is zero, then the offset <code>(0,0)</code> is used for <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#fragmentdensitymap-fetch-density-value">Fetch Density Value</a>.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-fragmentDensityMapOffsets">{@code fragmentDensityMapOffsets}</a> feature is not enabled or fragment density map is not enabled in the render pass, {@code fragmentDensityOffsetCount} <b>must</b> equal 0</li>
            <li>If ##VkSubpassDescription{@code ::fragmentDensityMapAttachment} is not is not #ATTACHMENT_UNUSED and was not created with #IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, {@code fragmentDensityOffsetCount} <b>must</b> equal 0</li>
            <li>If ##VkSubpassDescription{@code ::pDepthStencilAttachment} is not is not #ATTACHMENT_UNUSED and was not created with #IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, {@code fragmentDensityOffsetCount} <b>must</b> equal 0</li>
            <li>If any element of ##VkSubpassDescription{@code ::pInputAttachments} is not is not #ATTACHMENT_UNUSED and was not created with #IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, {@code fragmentDensityOffsetCount} <b>must</b> equal 0</li>
            <li>If any element of ##VkSubpassDescription{@code ::pColorAttachments} is not is not #ATTACHMENT_UNUSED and was not created with #IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, {@code fragmentDensityOffsetCount} <b>must</b> equal 0</li>
            <li>If any element of ##VkSubpassDescription{@code ::pResolveAttachments} is not is not #ATTACHMENT_UNUSED and was not created with #IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, {@code fragmentDensityOffsetCount} <b>must</b> equal 0</li>
            <li>If any element of ##VkSubpassDescription{@code ::pPreserveAttachments} is not is not #ATTACHMENT_UNUSED and was not created with #IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, {@code fragmentDensityOffsetCount} <b>must</b> equal 0</li>
            <li>If {@code fragmentDensityOffsetCount} is not 0 and multiview is enabled for the render pass, {@code fragmentDensityOffsetCount} <b>must</b> equal the {@code layerCount} that was specified in creating the fragment density map attachment view</li>
            <li>If {@code fragmentDensityOffsetCount} is not 0 and multiview is not enabled for the render pass, {@code fragmentDensityOffsetCount} <b>must</b> equal 1</li>
            <li>The {@code x} component of each element of {@code pFragmentDensityOffsets} <b>must</b> be an integer multiple of {@code fragmentDensityOffsetGranularity.width}</li>
            <li>The {@code y} component of each element of {@code pFragmentDensityOffsets} <b>must</b> be an integer multiple of {@code fragmentDensityOffsetGranularity.height}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM</li>
            <li>If {@code fragmentDensityOffsetCount} is not 0, {@code pFragmentDensityOffsets} <b>must</b> be a valid pointer to an array of {@code fragmentDensityOffsetCount} ##VkOffset2D structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkOffset2D
        """

    Expression("#STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pFragmentDensityOffsets", optional = true)..uint32_t("fragmentDensityOffsetCount", "the number of offsets being specified.")
    VkOffset2D.const.p("pFragmentDensityOffsets", "a pointer to an array of ##VkOffset2D structs, each of which describes the offset per layer.")
}

val VkCopyMemoryIndirectCommandNV = struct(Module.VULKAN, "VkCopyMemoryIndirectCommandNV") {
    documentation =
        """
        Structure specifying indirect memory region copy operation.

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code srcAddress} <b>must</b> be 4 byte aligned</li>
            <li>The {@code dstAddress} <b>must</b> be 4 byte aligned</li>
            <li>The {@code size} <b>must</b> be 4 byte aligned</li>
        </ul>
        """

    VkDeviceAddress("srcAddress", "the starting address of the source host or device memory to copy from.")
    VkDeviceAddress("dstAddress", "the starting address of the destination host or device memory to copy to.")
    VkDeviceSize("size", "the size of the copy in bytes.")
}

val VkCopyMemoryToImageIndirectCommandNV = struct(Module.VULKAN, "VkCopyMemoryToImageIndirectCommandNV") {
    documentation =
        """
        Structure specifying indirect buffer image copy operation.

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code srcAddress} <b>must</b> be 4 byte aligned</li>
            <li>{@code bufferRowLength} <b>must</b> be 0, or greater than or equal to the {@code width} member of {@code imageExtent}</li>
            <li>{@code bufferImageHeight} <b>must</b> be 0, or greater than or equal to the {@code height} member of {@code imageExtent}</li>
            <li>{@code imageOffset} <b>must</b> specify a valid offset in the destination image</li>
            <li>{@code imageExtent} <b>must</b> specify a valid region in the destination image and can be 0</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code imageSubresource} <b>must</b> be a valid ##VkImageSubresourceLayers structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent3D, ##VkImageSubresourceLayers, ##VkOffset3D
        """

    VkDeviceAddress("srcAddress", "the starting address of the source host or device memory to copy from.")
    uint32_t("bufferRowLength", "{@code bufferRowLength} and {@code bufferImageHeight} specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the {@code imageExtent}.")
    uint32_t("bufferImageHeight", "see {@code bufferRowLength}")
    VkImageSubresourceLayers("imageSubresource", "a ##VkImageSubresourceLayers used to specify the specific image subresources of the image used for the destination image data, which <b>must</b> match the values specified in {@code pImageSubresources} parameter of #CmdCopyMemoryToImageIndirectNV() during command recording.")
    VkOffset3D("imageOffset", "selects the initial {@code x}, {@code y}, {@code z} offsets in texels of the sub-region of the destination image data.")
    VkExtent3D("imageExtent", "the size in texels of the destination image in {@code width}, {@code height} and {@code depth}.")
}

val VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceCopyMemoryIndirectFeaturesNV") {
    documentation =
        """
        Structure describing indirect copy features supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCopyMemoryIndirectFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCopyMemoryIndirectFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("indirectCopy", "indicates whether <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#indirect-copies\">indirect copies</a> are supported.")
}

val VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceCopyMemoryIndirectPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing supported queues for indirect copy.

        <h5>Description</h5>
        If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-indirectCopy">{@code indirectCopy}</a> feature is supported, {@code supportedQueues} <b>must</b> return at least one supported queue.

        If the ##VkPhysicalDeviceCopyMemoryIndirectPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkQueueFlags("supportedQueues", "a bitmask of {@code VkQueueFlagBits} indicating the queues on which <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#indirect-copies\">indirect copy commands</a> are supported.")
}

val VkDecompressMemoryRegionNV = struct(Module.VULKAN, "VkDecompressMemoryRegionNV") {
    documentation =
        """
        Structure specifying decompression parameters.

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code srcAddress} <b>must</b> be 4 byte aligned</li>
            <li>The memory in range {@code srcAddress} and {@code srcAddress} + {@code compressedSize} <b>must</b> be valid and bound to a {@code VkDeviceMemory} object</li>
            <li>The {@code dstAddress} <b>must</b> be 4 byte aligned</li>
            <li>The memory in range {@code dstAddress} and {@code dstAddress} + {@code decompressedSize} <b>must</b> be valid and bound to a {@code VkDeviceMemory} object</li>
            <li>The {@code decompressedSize} <b>must</b> be large enough to hold the decompressed data based on the {@code decompressionMethod}</li>
            <li>The {@code decompressionMethod} <b>must</b> have a single bit set</li>
            <li>The {@code srcAddress} to {@code srcAddress} + {@code compressedSize} region <b>must</b> not overlap with the {@code dstAddress} and {@code dstAddress} + {@code decompressedSize} region</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code decompressionMethod} <b>must</b> be a valid combination of {@code VkMemoryDecompressionMethodFlagBitsNV} values</li>
            <li>{@code decompressionMethod} <b>must</b> not be 0</li>
        </ul>

        <h5>See Also</h5>
        #CmdDecompressMemoryNV()
        """

    VkDeviceAddress("srcAddress", "the address where compressed data is stored.")
    VkDeviceAddress("dstAddress", "the destination address where decompressed data will be written.")
    VkDeviceSize("compressedSize", "the size of compressed data in bytes.")
    VkDeviceSize("decompressedSize", "the size of decompressed data in bytes.")
    VkMemoryDecompressionMethodFlagsNV("decompressionMethod", "a bitmask of {@code VkMemoryDecompressionMethodFlagBitsNV} with a single bit set specifying the method used to decompress data.")
}

val VkPhysicalDeviceMemoryDecompressionFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceMemoryDecompressionFeaturesNV") {
    documentation =
        """
        Structure describing if memory decompression is supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMemoryDecompressionFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMemoryDecompressionFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("memoryDecompression", "indicates whether memory decompression is supported.")
}

val VkPhysicalDeviceMemoryDecompressionPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceMemoryDecompressionPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing supported memory decompression methods by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMemoryDecompressionPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkMemoryDecompressionMethodFlagsNV("decompressionMethods", "a bitmask of {@code VkMemoryDecompressionMethodFlagBitsNV} specifying memory decompression methods supported by the implementation.")
    uint64_t("maxDecompressionIndirectCount", "specifies the maximum supported count value in the {@code countBuffer} of #CmdDecompressMemoryIndirectCountNV()")
}

val VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV") {
    documentation =
        """
        Structure describing the device-generated compute features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("deviceGeneratedCompute", "indicates whether the implementation supports functionality to generate dispatch commands and push constants for the compute pipeline on the device. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#device-generated-commands\">Device-Generated Commands</a>.")
    VkBool32("deviceGeneratedComputePipelines", "indicates whether the implementation supports functionality to generate commands to bind compute pipelines on the device. See <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#device-generated-commands\">Device-Generated Commands</a>.")
    VkBool32("deviceGeneratedComputeCaptureReplay", "indicates whether the implementation supports functionality to capture compute pipeline address and reuse later for replay in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#device-generated-commands\">Device-Generated Commands</a>.")
}

val VkComputePipelineIndirectBufferInfoNV = struct(Module.VULKAN, "VkComputePipelineIndirectBufferInfoNV") {
    documentation =
        """
        Structure describing the device address where pipeline’s metadata will be saved.

        <h5>Valid Usage</h5>
        <ul>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-deviceGeneratedComputePipelines">##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV{@code ::deviceGeneratedComputePipelines}</a> feature <b>must</b> be enabled</li>
            <li>The pipeline creation flags in ##VkComputePipelineCreateInfo{@code ::flags} <b>must</b> include #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV</li>
            <li>{@code deviceAddress} <b>must</b> be aligned to the ##VkMemoryRequirements2{@code ::alignment}, as returned by #GetPipelineIndirectMemoryRequirementsNV()</li>
            <li>{@code deviceAddress} <b>must</b> have been allocated from a buffer that was created with usage #BUFFER_USAGE_TRANSFER_DST_BIT and #BUFFER_USAGE_INDIRECT_BUFFER_BIT</li>
            <li>{@code size} <b>must</b> be greater than or equal to the ##VkMemoryRequirements2{@code ::size}, as returned by #GetPipelineIndirectMemoryRequirementsNV()</li>
            <li>If {@code pipelineDeviceAddressCaptureReplay} is non-zero then the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-deviceGeneratedComputePipelines">##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV{@code ::deviceGeneratedComputeCaptureReplay}</a> feature <b>must</b> be enabled</li>
            <li>If {@code pipelineDeviceAddressCaptureReplay} is non-zero then that address <b>must</b> have been allocated with flag #MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT set</li>
            <li>If {@code pipelineDeviceAddressCaptureReplay} is non-zero, the {@code pipeline} <b>must</b> have been recreated for replay</li>
            <li>{@code pipelineDeviceAddressCaptureReplay} <b>must</b> satisfy the {@code alignment} and {@code size} requirements similar to {@code deviceAddress}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkDeviceAddress("deviceAddress", "")
    VkDeviceSize("size", "")
    VkDeviceAddress("pipelineDeviceAddressCaptureReplay", "")
}

val VkPipelineIndirectDeviceAddressInfoNV = struct(Module.VULKAN, "VkPipelineIndirectDeviceAddressInfoNV") {
    documentation =
        """
        Structure specifying the pipeline to query an address for.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pipelineBindPoint} <b>must</b> be a valid {@code VkPipelineBindPoint} value</li>
            <li>{@code pipeline} <b>must</b> be a valid {@code VkPipeline} handle</li>
        </ul>

        <h5>See Also</h5>
        #GetPipelineIndirectDeviceAddressNV()
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    VkPipelineBindPoint("pipelineBindPoint", "")
    VkPipeline("pipeline", """<b>must</b> have been created with flag #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV set

        <b>must</b> have been created with a ##VkComputePipelineIndirectBufferInfoNV structure specifying a valid address where its metadata will be saved""")
}

val VkBindPipelineIndirectCommandNV = struct(Module.VULKAN, "VkBindPipelineIndirectCommandNV") {
    documentation =
        """
        Structure specifying input data for the compute pipeline dispatch token.

        <h5>Valid Usage</h5>
        <ul>
            <li>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-deviceGeneratedComputePipelines">##VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV{@code ::deviceGeneratedComputePipelines}</a> feature <b>must</b> be enabled</li>
            <li>The referenced pipeline <b>must</b> have been created with #PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV</li>
            <li>The referenced pipeline <b>must</b> have been updated with #CmdUpdatePipelineIndirectBufferNV()</li>
            <li>The referenced pipeline’s address <b>must</b> have been queried with #GetPipelineIndirectDeviceAddressNV()</li>
        </ul>
        """

    VkDeviceAddress("pipelineAddress", "specifies the pipeline address of the compute pipeline that will be used in device generated rendering.")
}

val VkPhysicalDeviceLinearColorAttachmentFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceLinearColorAttachmentFeaturesNV") {
    documentation =
        """
        Structure describing whether <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#glossary-linear-color-attachment">Linear Color Attachment</a> rendering is supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceLinearColorAttachmentFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceLinearColorAttachmentFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("linearColorAttachment", "indicates whether the implementation supports renderable <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#glossary-linear-color-attachment\">Linear Color Attachment</a>")
}

val VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT") {
    documentation =
        """
        Structure describing whether per-swapchain image compression controls can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("imageCompressionControlSwapchain", "indicates that the implementation supports controlling image controls per swapchain and querying image compression properties per surface.")
}

val VkImageViewSampleWeightCreateInfoQCOM = struct(Module.VULKAN, "VkImageViewSampleWeightCreateInfoQCOM") {
    documentation =
        """
        Structure describing weight sampling parameters for image view.

        <h5>Description</h5>
        The {@code filterCenter} specifies the origin or center of the filter kernel, as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#textures-weightimage-filteroperation">Weight Sampling Operation</a>. The {@code numPhases} describes the number of sub-pixel filter phases as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#textures-weightimage-filterphases">Weight Sampling Phases</a>.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code filterSize.width} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-weightfilter-maxdimension">##VkPhysicalDeviceImageProcessingPropertiesQCOM{@code ::maxWeightFilterDimension.width}</a></li>
            <li>{@code filterSize.height} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-weightfilter-maxdimension">##VkPhysicalDeviceImageProcessingPropertiesQCOM{@code ::maxWeightFilterDimension.height}</a></li>
            <li>{@code filterCenter.x} <b>must</b> be less than or equal to <code>(filterSize.width - 1)</code></li>
            <li>{@code filterCenter.y} <b>must</b> be less than or equal to <code>(filterSize.height - 1)</code></li>
            <li>{@code numPhases} <b>must</b> be a power of two squared value (i.e., 1, 4, 16, 64, 256, etc.)</li>
            <li>{@code numPhases} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-weightfilter-phases">##VkPhysicalDeviceImageProcessingPropertiesQCOM{@code ::maxWeightFilterPhases}</a></li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, ##VkOffset2D
        """

    Expression("#STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkOffset2D("filterCenter", "a ##VkOffset2D describing the location of the weight filter origin.")
    VkExtent2D("filterSize", "a ##VkExtent2D specifying weight filter dimensions.")
    uint32_t("numPhases", "number of sub-pixel filter phases.")
}

val VkPhysicalDeviceImageProcessingFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceImageProcessingFeaturesQCOM") {
    documentation =
        """
        Structure describing image processing features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageProcessingFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceImageProcessingFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("textureSampleWeighted", "indicates that the implementation supports shader modules that declare the {@code TextureSampleWeightedQCOM} capability.")
    VkBool32("textureBoxFilter", "indicates that the implementation supports shader modules that declare the {@code TextureBoxFilterQCOM} capability.")
    VkBool32("textureBlockMatch", "indicates that the implementation supports shader modules that declare the {@code TextureBlockMatchQCOM} capability.")
}

val VkPhysicalDeviceImageProcessingPropertiesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceImageProcessingPropertiesQCOM", mutable = false) {
    documentation =
        """
        Structure containing image processing properties.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageProcessingPropertiesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These are properties of the image processing information of a physical device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("maxWeightFilterPhases", "the maximum value that <b>can</b> be specified for ##VkImageViewSampleWeightCreateInfoQCOM{@code ::numPhases}. in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-weightimage-filterphases\">weight image sampling</a> operations.")
    VkExtent2D("maxWeightFilterDimension", "a ##VkExtent2D describing the largest dimensions ({@code width} and {@code height}) that <b>can</b> be specified for ##VkImageViewSampleWeightCreateInfoQCOM{@code ::filterSize}.")
    VkExtent2D("maxBlockMatchRegion", "a ##VkExtent2D describing the largest dimensions ({@code width} and {@code height}) that <b>can</b> be specified for {@code blockSize} in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-blockmatch\">block matching</a> operations.")
    VkExtent2D("maxBoxFilterBlockSize", "a ##VkExtent2D describing the maximum dimensions ({@code width} and {@code height}) that <b>can</b> be specified for {@code blocksize} in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-boxfilter\">box filter sampling</a> operations.")
}

val VkExternalMemoryAcquireUnmodifiedEXT = struct(Module.VULKAN, "VkExternalMemoryAcquireUnmodifiedEXT") {
    documentation =
        """
        Structure specifying that external memory has remained unmodified since releasing ownership.

        <h5>Description</h5>
        If the application releases ownership of the subresource range to one of the special queue families reserved for external memory ownership transfers with a memory barrier structure, and later re-acquires ownership from the same queue family with a memory barrier structure, and if no range of {@code VkDeviceMemory} bound to the resource was modified at any time between the <em>release operation</em> and the <em>acquire operation</em>, then the application <b>should</b> add a ##VkExternalMemoryAcquireUnmodifiedEXT structure to the {@code pNext} chain of the <em>acquire operation</em>'s memory barrier structure because this <b>may</b> reduce the performance penalty.

        This struct is ignored if {@code acquireUnmodifiedMemory} is #FALSE. In particular, #FALSE does <em>not</em> specify that memory was modified.

        This struct is ignored if the memory barrier’s {@code srcQueueFamilyIndex} is not a special queue family reserved for external memory ownership transfers.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The method by which the application determines whether memory was modified between the <em>release operation</em> and <em>acquire operation</em> is outside the scope of Vulkan.

        For any Vulkan operation that accesses a resource, the application <b>must</b> not assume the implementation accesses the resource’s memory as read-only, even for <em>apparently</em> read-only operations such as transfer commands and shader reads.

        The validity of ##VkExternalMemoryAcquireUnmodifiedEXT{@code ::acquireUnmodifiedMemory} is independent of memory ranges outside the ranges of {@code VkDeviceMemory} bound to the resource. In particular, it is independent of any implementation-private memory associated with the resource.
        </div>

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code acquireUnmodifiedMemory} is #TRUE, and the memory barrier’s {@code srcQueueFamilyIndex} is a special queue family reserved for external memory ownership transfers (as described in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#synchronization-queue-transfers">Queue Family Ownership Transfer</a>), then each range of {@code VkDeviceMemory} bound to the resource <b>must</b> have remained unmodified during all time since the resource’s most recent release of ownership to the queue family.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("acquireUnmodifiedMemory", "specifies, if #TRUE, that no range of {@code VkDeviceMemory} bound to the resource of the memory barrier’s subresource range was modified at any time since the resource’s most recent release of ownership to the queue family specified by the memory barrier’s {@code srcQueueFamilyIndex}. If #FALSE, it specifies nothing.")
}

val VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT") {
    documentation =
        """
        Structure describing what extended dynamic state is supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceExtendedDynamicState3FeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceExtendedDynamicState3FeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("extendedDynamicState3TessellationDomainOrigin", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3DepthClampEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3PolygonMode", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_POLYGON_MODE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3RasterizationSamples", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3SampleMask", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_SAMPLE_MASK_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3AlphaToCoverageEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3AlphaToOneEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3LogicOpEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ColorBlendEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ColorBlendEquation", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ColorWriteMask", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COLOR_WRITE_MASK_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3RasterizationStream", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_RASTERIZATION_STREAM_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ConservativeRasterizationMode", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ExtraPrimitiveOverestimationSize", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3DepthClipEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3SampleLocationsEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ColorBlendAdvanced", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ProvokingVertexMode", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3LineRasterizationMode", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3LineStippleEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3DepthClipNegativeOneToOne", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT</li>
        </ul>""")
    VkBool32("extendedDynamicState3ViewportWScalingEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3ViewportSwizzle", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3CoverageToColorEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3CoverageToColorLocation", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3CoverageModulationMode", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3CoverageModulationTableEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3CoverageModulationTable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3CoverageReductionMode", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3RepresentativeFragmentTestEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV</li>
        </ul>""")
    VkBool32("extendedDynamicState3ShadingRateImageEnable", """indicates that the implementation supports the following dynamic state:

        <ul>
            <li>#DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV</li>
        </ul>""")
}

val VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT") {
    documentation =
        """
        Structure describing capabilities of extended dynamic state.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceExtendedDynamicState3PropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("dynamicPrimitiveTopologyUnrestricted", "indicates that the implementation allows {@code vkCmdSetPrimitiveTopology} to use a different <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#drawing-primitive-topology-class\">primitive topology class</a> to the one specified in the active graphics pipeline.")
}

val VkColorBlendEquationEXT = struct(Module.VULKAN, "VkColorBlendEquationEXT") {
    documentation =
        """
        Structure specifying the color blend factors and operations for an attachment.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-dualSrcBlend">{@code dualSrcBlend}</a> feature is not enabled, {@code srcColorBlendFactor} <b>must</b> not be #BLEND_FACTOR_SRC1_COLOR, #BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, #BLEND_FACTOR_SRC1_ALPHA, or #BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-dualSrcBlend">{@code dualSrcBlend}</a> feature is not enabled, {@code dstColorBlendFactor} <b>must</b> not be #BLEND_FACTOR_SRC1_COLOR, #BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, #BLEND_FACTOR_SRC1_ALPHA, or #BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-dualSrcBlend">{@code dualSrcBlend}</a> feature is not enabled, {@code srcAlphaBlendFactor} <b>must</b> not be #BLEND_FACTOR_SRC1_COLOR, #BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, #BLEND_FACTOR_SRC1_ALPHA, or #BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-dualSrcBlend">{@code dualSrcBlend}</a> feature is not enabled, {@code dstAlphaBlendFactor} <b>must</b> not be #BLEND_FACTOR_SRC1_COLOR, #BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, #BLEND_FACTOR_SRC1_ALPHA, or #BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</li>
            <li>{@code colorBlendOp} and {@code alphaBlendOp} <b>must</b> not be #BLEND_OP_ZERO_EXT, #BLEND_OP_SRC_EXT, #BLEND_OP_DST_EXT, #BLEND_OP_SRC_OVER_EXT, #BLEND_OP_DST_OVER_EXT, #BLEND_OP_SRC_IN_EXT, #BLEND_OP_DST_IN_EXT, #BLEND_OP_SRC_OUT_EXT, #BLEND_OP_DST_OUT_EXT, #BLEND_OP_SRC_ATOP_EXT, #BLEND_OP_DST_ATOP_EXT, #BLEND_OP_XOR_EXT, #BLEND_OP_MULTIPLY_EXT, #BLEND_OP_SCREEN_EXT, #BLEND_OP_OVERLAY_EXT, #BLEND_OP_DARKEN_EXT, #BLEND_OP_LIGHTEN_EXT, #BLEND_OP_COLORDODGE_EXT, #BLEND_OP_COLORBURN_EXT, #BLEND_OP_HARDLIGHT_EXT, #BLEND_OP_SOFTLIGHT_EXT, #BLEND_OP_DIFFERENCE_EXT, #BLEND_OP_EXCLUSION_EXT, #BLEND_OP_INVERT_EXT, #BLEND_OP_INVERT_RGB_EXT, #BLEND_OP_LINEARDODGE_EXT, #BLEND_OP_LINEARBURN_EXT, #BLEND_OP_VIVIDLIGHT_EXT, #BLEND_OP_LINEARLIGHT_EXT, #BLEND_OP_PINLIGHT_EXT, #BLEND_OP_HARDMIX_EXT, #BLEND_OP_HSL_HUE_EXT, #BLEND_OP_HSL_SATURATION_EXT, #BLEND_OP_HSL_COLOR_EXT, #BLEND_OP_HSL_LUMINOSITY_EXT, #BLEND_OP_PLUS_EXT, #BLEND_OP_PLUS_CLAMPED_EXT, #BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, #BLEND_OP_PLUS_DARKER_EXT, #BLEND_OP_MINUS_EXT, #BLEND_OP_MINUS_CLAMPED_EXT, #BLEND_OP_CONTRAST_EXT, #BLEND_OP_INVERT_OVG_EXT, #BLEND_OP_RED_EXT, #BLEND_OP_GREEN_EXT, or #BLEND_OP_BLUE_EXT</li>
            <li>If the {@link KHRPortabilitySubset VK_KHR_portability_subset} extension is enabled, and ##VkPhysicalDevicePortabilitySubsetFeaturesKHR{@code ::constantAlphaColorBlendFactors} is #FALSE, {@code srcColorBlendFactor} <b>must</b> not be #BLEND_FACTOR_CONSTANT_ALPHA or #BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA</li>
            <li>If the {@link KHRPortabilitySubset VK_KHR_portability_subset} extension is enabled, and ##VkPhysicalDevicePortabilitySubsetFeaturesKHR{@code ::constantAlphaColorBlendFactors} is #FALSE, {@code dstColorBlendFactor} <b>must</b> not be #BLEND_FACTOR_CONSTANT_ALPHA or #BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code srcColorBlendFactor} <b>must</b> be a valid {@code VkBlendFactor} value</li>
            <li>{@code dstColorBlendFactor} <b>must</b> be a valid {@code VkBlendFactor} value</li>
            <li>{@code colorBlendOp} <b>must</b> be a valid {@code VkBlendOp} value</li>
            <li>{@code srcAlphaBlendFactor} <b>must</b> be a valid {@code VkBlendFactor} value</li>
            <li>{@code dstAlphaBlendFactor} <b>must</b> be a valid {@code VkBlendFactor} value</li>
            <li>{@code alphaBlendOp} <b>must</b> be a valid {@code VkBlendOp} value</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetColorBlendEquationEXT()
        """

    VkBlendFactor("srcColorBlendFactor", "selects which blend factor is used to determine the source factors <code>(S<sub>r</sub>,S<sub>g</sub>,S<sub>b</sub>)</code>.")
    VkBlendFactor("dstColorBlendFactor", "selects which blend factor is used to determine the destination factors <code>(D<sub>r</sub>,D<sub>g</sub>,D<sub>b</sub>)</code>.")
    VkBlendOp("colorBlendOp", "selects which blend operation is used to calculate the RGB values to write to the color attachment.")
    VkBlendFactor("srcAlphaBlendFactor", "selects which blend factor is used to determine the source factor <code>S<sub>a</sub></code>.")
    VkBlendFactor("dstAlphaBlendFactor", "selects which blend factor is used to determine the destination factor <code>D<sub>a</sub></code>.")
    VkBlendOp("alphaBlendOp", "selects which blend operation is use to calculate the alpha values to write to the color attachment.")
}

val VkColorBlendAdvancedEXT = struct(Module.VULKAN, "VkColorBlendAdvancedEXT") {
    documentation =
        """
        Structure specifying the advanced blend operation parameters for an attachment.

        <h5>Valid Usage</h5>
        <ul>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-advancedBlendNonPremultipliedSrcColor">non-premultiplied source color</a> property is not supported, {@code srcPremultiplied} <b>must</b> be #TRUE</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-advancedBlendNonPremultipliedDstColor">non-premultiplied destination color</a> property is not supported, {@code dstPremultiplied} <b>must</b> be #TRUE</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-advancedBlendCorrelatedOverlap">correlated overlap</a> property is not supported, {@code blendOverlap} <b>must</b> be #BLEND_OVERLAP_UNCORRELATED_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code advancedBlendOp} <b>must</b> be a valid {@code VkBlendOp} value</li>
            <li>{@code blendOverlap} <b>must</b> be a valid {@code VkBlendOverlapEXT} value</li>
        </ul>

        <h5>See Also</h5>
        #CmdSetColorBlendAdvancedEXT()
        """

    VkBlendOp("advancedBlendOp", "selects which blend operation is used to calculate the RGB values to write to the color attachment.")
    VkBool32("srcPremultiplied", "specifies whether the source color of the blend operation is treated as premultiplied.")
    VkBool32("dstPremultiplied", "specifies whether the destination color of the blend operation is treated as premultiplied.")
    VkBlendOverlapEXT("blendOverlap", "a {@code VkBlendOverlapEXT} value specifying how the source and destination sample’s coverage is correlated.")
    VkBool32("clampResults", "specifies the results must be clamped to the [0,1] range before writing to the attachment, which is useful when the attachment format is not normalized fixed-point.")
}

val VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT") {
    documentation =
        """
        Structure describing whether subpass merging feedback can be supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("subpassMergeFeedback", "indicates whether the implementation supports feedback of subpass merging.")
}

val VkRenderPassCreationControlEXT = struct(Module.VULKAN, "VkRenderPassCreationControlEXT") {
    documentation =
        """
        Control about the creation of render pass or subpass.

        <h5>Description</h5>
        If a ##VkRenderPassCreationControlEXT structure is included in the {@code pNext} chain of ##VkRenderPassCreateInfo2 and its value of {@code disallowMerging} is #TRUE, the implementation will disable subpass merging for the entire render pass. If a ##VkRenderPassCreationControlEXT structure is included in the {@code pNext} chain of ##VkSubpassDescription2 and its value of {@code disallowMerging} is #TRUE, the implementation will disable merging the described subpass with previous subpasses in the render pass.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT</li>
        </ul>

        <h5>See Also</h5>
        ##VkRenderPassCreateInfo2, ##VkSubpassDescription2, #CreateRenderPass2()
        """

    Expression("#STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("disallowMerging", "a boolean value indicating whether subpass merging will be disabled.")
}

val VkRenderPassCreationFeedbackInfoEXT = struct(Module.VULKAN, "VkRenderPassCreationFeedbackInfoEXT", mutable = false) {
    documentation =
        """
        Feedback about the creation of a render pass.

        <h5>See Also</h5>
        ##VkRenderPassCreationFeedbackCreateInfoEXT
        """

    uint32_t("postMergeSubpassCount", "the subpass count after merge.")
}

val VkRenderPassCreationFeedbackCreateInfoEXT = struct(Module.VULKAN, "VkRenderPassCreationFeedbackCreateInfoEXT") {
    documentation =
        """
        Request feedback about the creation of render pass.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT</li>
            <li>{@code pRenderPassFeedback} <b>must</b> be a valid pointer to a ##VkRenderPassCreationFeedbackInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkRenderPassCreateInfo2, ##VkRenderPassCreationControlEXT, ##VkRenderPassCreationFeedbackInfoEXT, #CreateRenderPass2()
        """

    Expression("#STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkRenderPassCreationFeedbackInfoEXT.p("pRenderPassFeedback", "a pointer to a ##VkRenderPassCreationFeedbackInfoEXT structure in which feedback is returned.")
}

val VkRenderPassSubpassFeedbackInfoEXT = struct(Module.VULKAN, "VkRenderPassSubpassFeedbackInfoEXT", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Feedback about the creation of subpass.

        <h5>See Also</h5>
        ##VkRenderPassSubpassFeedbackCreateInfoEXT
        """

    VkSubpassMergeStatusEXT("subpassMergeStatus", "a {@code VkSubpassMergeStatusEXT} value specifying information about whether the subpass is merged with previous subpass and the reason why it is not merged.")
    charUTF8("description", "an array of #MAX_DESCRIPTION_SIZE {@code char} containing a null-terminated UTF-8 string which provides additional details.")["VK_MAX_DESCRIPTION_SIZE"]
    uint32_t("postMergeIndex", "the subpass index after the subpass merging.")
}

val VkRenderPassSubpassFeedbackCreateInfoEXT = struct(Module.VULKAN, "VkRenderPassSubpassFeedbackCreateInfoEXT") {
    documentation =
        """
        Request for feedback about the creation of subpass.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT</li>
            <li>{@code pSubpassFeedback} <b>must</b> be a valid pointer to a ##VkRenderPassSubpassFeedbackInfoEXT structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkRenderPassCreateInfo2, ##VkRenderPassCreationControlEXT, ##VkRenderPassSubpassFeedbackInfoEXT, ##VkSubpassDescription2, #CreateRenderPass2()
        """

    Expression("#STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkRenderPassSubpassFeedbackInfoEXT.p("pSubpassFeedback", "a pointer to a ##VkRenderPassSubpassFeedbackInfoEXT structure in which feedback is returned.")
}

val VkDirectDriverLoadingInfoLUNARG = struct(Module.VULKAN, "VkDirectDriverLoadingInfoLUNARG") {
    documentation =
        """
        Structure specifying the information required to load an additional driver.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG</li>
            <li>{@code flags} <b>must</b> be 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkDirectDriverLoadingListLUNARG
        """

    Expression("#STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDirectDriverLoadingFlagsLUNARG("flags", "reserved for future use.")
    PFN_vkGetInstanceProcAddrLUNARG("pfnGetInstanceProcAddr", "a {@code PFN_vkGetInstanceProcAddrLUNARG} pointer to the driver #GetInstanceProcAddr() function.")
}

val VkDirectDriverLoadingListLUNARG = struct(Module.VULKAN, "VkDirectDriverLoadingListLUNARG") {
    documentation =
        """
        Structure specifying additional drivers to load.

        <h5>Description</h5>
        When creating a Vulkan instance for which additional drivers are to be included, add a ##VkDirectDriverLoadingListLUNARG structure to the pNext chain of the ##VkInstanceCreateInfo structure, and include in it the list of ##VkDirectDriverLoadingInfoLUNARG structures which contain the information necessary to load additional drivers.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG</li>
            <li>{@code mode} <b>must</b> be a valid {@code VkDirectDriverLoadingModeLUNARG} value</li>
            <li>{@code pDrivers} <b>must</b> be a valid pointer to an array of {@code driverCount} valid ##VkDirectDriverLoadingInfoLUNARG structures</li>
            <li>{@code driverCount} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkDirectDriverLoadingInfoLUNARG
        """

    Expression("#STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkDirectDriverLoadingModeLUNARG("mode", "controls the mode in which to load the provided drivers.")
    AutoSize("pDrivers")..uint32_t("driverCount", "the number of driver manifest paths.")
    VkDirectDriverLoadingInfoLUNARG.const.p("pDrivers", "a pointer to an array of {@code driverCount} ##VkDirectDriverLoadingInfoLUNARG structures.")
}

val VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT") {
    documentation =
        """
        Structure describing whether querying and providing an identifier of a shader module is supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderModuleIdentifier", "indicates whether the implementation supports querying an identifier of a {@code VkShaderModule} or ##VkShaderModuleCreateInfo structure, and creating pipelines from identifiers only.")
}

val VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure describing shader module identifier properties of an implementation.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        The algorithm UUID may be the same in different ICDs if the algorithms are guaranteed to produce the same results. This may happen in driver stacks which support different kinds of hardware with shared code.

        Khronos' conformance testing can not guarantee that {@code shaderModuleIdentifierAlgorithmUUID} values are actually unique, so implementors should make their own best efforts to ensure that their UUID is unlikely to conflict with other implementations which may use a different algorithm. In particular, hard-coded values which easily conflict, such as all-0 bits, <b>should</b> never be used. Hard-coded values are acceptable if best effort is ensured that the value will not accidentally conflict.
        </div>

        If the ##VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint8_t("shaderModuleIdentifierAlgorithmUUID", "an array of #UUID_SIZE {@code uint8_t} values which uniquely represents the algorithm used to compute an identifier in #GetShaderModuleIdentifierEXT() and #GetShaderModuleCreateInfoIdentifierEXT(). Implementations <b>should</b> not change this value in different driver versions if the algorithm used to compute an identifier is the same.")["VK_UUID_SIZE"]
}

val VkPipelineShaderStageModuleIdentifierCreateInfoEXT = struct(Module.VULKAN, "VkPipelineShaderStageModuleIdentifierCreateInfoEXT") {
    documentation =
        """
        Structure specifying an identifier for a shader module.

        <h5>Description</h5>
        Any identifier <b>can</b> be used. If the pipeline being created with identifier requires compilation to complete the pipeline creation call, pipeline compilation <b>must</b> fail as defined by #PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT.

        {@code pIdentifier} and {@code identifierSize} <b>can</b> be obtained from an ##VkShaderModuleIdentifierEXT queried earlier.

        <h5>Valid Usage</h5>
        <ul>
            <li>If this structure is included in a {@code pNext} chain and {@code identifierSize} is not equal to 0, the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-shaderModuleIdentifier">{@code shaderModuleIdentifier}</a> feature <b>must</b> be enabled</li>
            <li>If this struct is included in a {@code pNext} chain of ##VkPipelineShaderStageCreateInfo and {@code identifierSize} is not equal to 0, the pipeline <b>must</b> be created with the #PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set</li>
            <li>{@code identifierSize} <b>must</b> be less-or-equal to #MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT</li>
            <li>If {@code identifierSize} is not 0, {@code pIdentifier} <b>must</b> be a valid pointer to an array of {@code identifierSize} {@code uint8_t} values</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pIdentifier", optional = true)..uint32_t("identifierSize", "the size, in bytes, of the buffer pointed to by {@code pIdentifier}.")
    uint8_t.const.p("pIdentifier", "a pointer to a buffer of opaque data specifying an identifier.")
}

val VkShaderModuleIdentifierEXT = struct(Module.VULKAN, "VkShaderModuleIdentifierEXT", mutable = false) {
    javaImport("static org.lwjgl.vulkan.EXTShaderModuleIdentifier.*")
    documentation =
        """
        A unique identifier for a shader module.

        <h5>Description</h5>
        Any returned values beyond the first {@code identifierSize} bytes are undefined. Implementations <b>must</b> return an {@code identifierSize} greater than 0, and less-or-equal to #MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT.

        Two identifiers are considered equal if {@code identifierSize} is equal and the first {@code identifierSize} bytes of {@code identifier} compare equal.

        Implementations <b>may</b> return a different {@code identifierSize} for different modules. Implementations <b>should</b> ensure that {@code identifierSize} is large enough to uniquely define a shader module.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetShaderModuleCreateInfoIdentifierEXT(), #GetShaderModuleIdentifierEXT()
        """

    Expression("#STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint32_t("identifierSize", "the size, in bytes, of valid data returned in {@code identifier}.")
    uint8_t("identifier", "a buffer of opaque data specifying an identifier.")["VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT"]
}

val VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT") {
    documentation =
        """
        Structure describing whether rasterization order attachment access can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rasterizationOrderColorAttachmentAccess", "indicates that rasterization order access to color and input attachments is supported by the implementation.")
    VkBool32("rasterizationOrderDepthAttachmentAccess", "indicates that rasterization order access to the depth aspect of depth/stencil and input attachments is supported by the implementation.")
    VkBool32("rasterizationOrderStencilAttachmentAccess", "indicates that rasterization order access to the stencil aspect of depth/stencil and input attachments is supported by the implementation.")
}

val VkPhysicalDeviceOpticalFlowFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceOpticalFlowFeaturesNV") {
    documentation =
        """
        Structure describing the optical flow features supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceOpticalFlowFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceOpticalFlowFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("opticalFlow", "indicates whether the implementation supports optical flow.")
}

val VkPhysicalDeviceOpticalFlowPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceOpticalFlowPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing properties supported by VK_NV_optical_flow.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceOpticalFlowPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkOpticalFlowGridSizeFlagsNV("supportedOutputGridSizes", "are the supported {@code VkOpticalFlowGridSizeFlagsNV} which can be specified in ##VkOpticalFlowSessionCreateInfoNV{@code ::outputGridSize}.")
    VkOpticalFlowGridSizeFlagsNV("supportedHintGridSizes", "are the supported {@code VkOpticalFlowGridSizeFlagsNV} which can be specified in ##VkOpticalFlowSessionCreateInfoNV{@code ::hintGridSize}.")
    VkBool32("hintSupported", "a boolean describing whether using hint flow vector map is supported in an optical flow session.")
    VkBool32("costSupported", "a boolean describing whether cost map generation is supported in an optical flow session.")
    VkBool32("bidirectionalFlowSupported", "a boolean describing whether bi-directional flow generation is supported in an optical flow session.")
    VkBool32("globalFlowSupported", "a boolean describing whether global flow vector map generation is supported in an optical flow session.")
    uint32_t("minWidth", "the minimum width in pixels for images used in an optical flow session.")
    uint32_t("minHeight", "the minimum height in pixels for images used in an optical flow session.")
    uint32_t("maxWidth", "the maximum width in pixels for images used in an optical flow session.")
    uint32_t("maxHeight", "the maximum height in pixels for images used in an optical flow session.")
    uint32_t("maxNumRegionsOfInterest", "the maximum number of regions of interest which can be used in an optical flow session. If this {@code maxNumRegionsOfInterest} is 0, regions of interest are not supported in an optical flow session.")
}

val VkOpticalFlowImageFormatInfoNV = struct(Module.VULKAN, "VkOpticalFlowImageFormatInfoNV") {
    documentation =
        """
        Structure describing optical flow image format info.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV</li>
            <li>{@code usage} <b>must</b> be a valid combination of {@code VkOpticalFlowUsageFlagBitsNV} values</li>
            <li>{@code usage} <b>must</b> not be 0</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceOpticalFlowImageFormatsNV()
        """

    Expression("#STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkOpticalFlowUsageFlagsNV("usage", "a bitmask of {@code VkOpticalFlowUsageFlagBitsNV} describing the intended optical flow usage of the image.")
}

val VkOpticalFlowImageFormatPropertiesNV = struct(Module.VULKAN, "VkOpticalFlowImageFormatPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing properties of an optical flow image format.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceOpticalFlowImageFormatsNV()
        """

    Expression("#STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkFormat("format", "a {@code VkFormat} that specifies the format that can be used with the specified optical flow image usages.")
}

val VkOpticalFlowSessionCreateInfoNV = struct(Module.VULKAN, "VkOpticalFlowSessionCreateInfoNV") {
    documentation =
        """
        Structure specifying parameters of a newly created optical flow session.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code width} <b>must</b> be greater than or equal to ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::minWidth} and less than or equal to ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::maxWidth}</li>
            <li>{@code height} <b>must</b> be greater than or equal to ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::minHeight} and less than or equal to ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::maxHeight}</li>
            <li>{@code imageFormat} <b>must</b> be one of the formats returned by #GetPhysicalDeviceOpticalFlowImageFormatsNV() for #OPTICAL_FLOW_USAGE_INPUT_BIT_NV</li>
            <li>{@code flowVectorFormat} <b>must</b> be one of the formats returned by #GetPhysicalDeviceOpticalFlowImageFormatsNV() for #OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV</li>
            <li>{@code costFormat} <b>must</b> be one of the formats returned by #GetPhysicalDeviceOpticalFlowImageFormatsNV() for #OPTICAL_FLOW_USAGE_COST_BIT_NV if #OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV is set in {@code flags}</li>
            <li>{@code outputGridSize} <b>must</b> be exactly one of the bits reported in ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::supportedOutputGridSizes}</li>
            <li>{@code hintGridSize} <b>must</b> be exactly one of the bits reported in ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::supportedHintGridSizes} if #OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV is set in {@code flags}</li>
            <li>#OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV <b>must</b> not be set in {@code flags} if ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::hintSupported} is #FALSE</li>
            <li>#OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV <b>must</b> not be set in {@code flags} if ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::costSupported} is #FALSE</li>
            <li>#OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV <b>must</b> not be set in {@code flags} if ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::globalFlowSupported} is #FALSE</li>
            <li>#OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV <b>must</b> not be set in {@code flags} if ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::maxNumRegionsOfInterest} is 0</li>
            <li>#OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV <b>must</b> not be set in {@code flags} if ##VkPhysicalDeviceOpticalFlowPropertiesNV{@code ::bidirectionalFlowSupported} is #FALSE</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL} or a pointer to a valid instance of ##VkOpticalFlowSessionCreatePrivateDataInfoNV</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code imageFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code flowVectorFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>If {@code costFormat} is not 0, {@code costFormat} <b>must</b> be a valid {@code VkFormat} value</li>
            <li>{@code outputGridSize} <b>must</b> be a valid combination of {@code VkOpticalFlowGridSizeFlagBitsNV} values</li>
            <li>{@code outputGridSize} <b>must</b> not be 0</li>
            <li>{@code hintGridSize} <b>must</b> be a valid combination of {@code VkOpticalFlowGridSizeFlagBitsNV} values</li>
            <li>If {@code performanceLevel} is not 0, {@code performanceLevel} <b>must</b> be a valid {@code VkOpticalFlowPerformanceLevelNV} value</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkOpticalFlowSessionCreateFlagBitsNV} values</li>
        </ul>

        <h5>See Also</h5>
        #CreateOpticalFlowSessionNV()
        """

    Expression("#STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkOpticalFlowSessionCreatePrivateDataInfoNV",
        prepend = true
    )..nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("width", "the width in pixels of the input or reference frame to be bound to this optical flow session.")
    uint32_t("height", "the height in pixels of the input or reference frame to be bound to this optical flow session.")
    VkFormat("imageFormat", "the {@code VkFormat} of the input and reference frame to be bound to this optical flow session.")
    VkFormat("flowVectorFormat", "the {@code VkFormat} of the flow vector maps (output or hint) to be bound to this optical flow session.")
    VkFormat("costFormat", "the {@code VkFormat} of the cost maps to be bound to this optical flow session.")
    VkOpticalFlowGridSizeFlagsNV("outputGridSize", "exactly one bit of {@code VkOpticalFlowGridSizeFlagsNV} specifying the grid size of the output flow and cost maps to be bound to this optical flow session. The size of the output flow and cost maps is determined by ##VkOpticalFlowSessionCreateInfoNV{@code ::width} and ##VkOpticalFlowSessionCreateInfoNV{@code ::height} divided by ##VkOpticalFlowSessionCreateInfoNV{@code ::outputGridSize}.")
    VkOpticalFlowGridSizeFlagsNV("hintGridSize", "one exactly bit of {@code VkOpticalFlowGridSizeFlagsNV} specifying the grid size of the hint flow vector maps to be bound to this optical flow session. The size of the hint maps is determined by ##VkOpticalFlowSessionCreateInfoNV{@code ::width} and ##VkOpticalFlowSessionCreateInfoNV{@code ::height} divided by ##VkOpticalFlowSessionCreateInfoNV{@code ::hintGridSize}.")
    VkOpticalFlowPerformanceLevelNV("performanceLevel", "the {@code VkOpticalFlowPerformanceLevelNV} used for this optical flow session.")
    VkOpticalFlowSessionCreateFlagsNV("flags", "are the {@code VkOpticalFlowSessionCreateFlagsNV} used for this optical flow session.")
}

val VkOpticalFlowSessionCreatePrivateDataInfoNV = struct(Module.VULKAN, "VkOpticalFlowSessionCreatePrivateDataInfoNV") {
    documentation =
        """
        Structure for NV internal use only.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV</li>
            <li>{@code pPrivateData} <b>must</b> be a pointer value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("id", "an identifier for data which is passed at a memory location specified in ##VkOpticalFlowSessionCreatePrivateDataInfoNV{@code ::pPrivateData}.")
    uint32_t("size", "the size of data in bytes which is passed at a memory location specified in ##VkOpticalFlowSessionCreatePrivateDataInfoNV{@code ::pPrivateData}.")
    opaque_const_p("pPrivateData", "a pointer to NV internal data.")
}

val VkOpticalFlowExecuteInfoNV = struct(Module.VULKAN, "VkOpticalFlowExecuteInfoNV") {
    documentation =
        """
        Structure specifying parameters of a optical flow vector calculation.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code regionCount} <b>must</b> be 0 if #OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV was not set for {@code VkOpticalFlowSessionNV} on which this command is operating</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkOpticalFlowExecuteFlagBitsNV} values</li>
            <li>If {@code regionCount} is not 0, {@code pRegions} <b>must</b> be a valid pointer to an array of {@code regionCount} ##VkRect2D structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkRect2D, #CmdOpticalFlowExecuteNV()
        """

    Expression("#STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkOpticalFlowExecuteFlagsNV("flags", "are the {@code VkOpticalFlowExecuteFlagsNV} used for this command.")
    AutoSize("pRegions", optional = true)..uint32_t("regionCount", "the number of regions of interest specified in {@code pRegions}.")
    VkRect2D.const.p("pRegions", "a pointer to {@code regionCount} ##VkRect2D regions of interest.")
}

val VkPhysicalDeviceLegacyDitheringFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceLegacyDitheringFeaturesEXT") {
    documentation =
        """
        Structure describing support for legacy dithering.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceLegacyDitheringFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceLegacyDitheringFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("legacyDithering", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#interfaces-legacy-dithering\">Legacy Dithering</a>.")
}

val VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT") {
    documentation =
        """
        Structure describing support for specifying protected access on individual pipelines.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePipelineProtectedAccessFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePipelineProtectedAccessFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("pipelineProtectedAccess", "indicates whether the implementation supports specifying protected access on individual pipelines.")
}

val VkPhysicalDeviceMaintenance5FeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceMaintenance5FeaturesKHR") {
    documentation =
        """
        Structure describing whether the implementation supports maintenance5 functionality.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMaintenance5FeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMaintenance5FeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("maintenance5", """indicates that the implementation supports the following:

        <ul>
            <li>The ability to expose support for the optional format #FORMAT_A1B5G5R5_UNORM_PACK16_KHR.</li>
            <li>The ability to expose support for the optional format #FORMAT_A8_UNORM_KHR.</li>
            <li>A property to indicate that multisample coverage operations are performed after sample counting in EarlyFragmentTests mode.</li>
            <li>Creating a {@code VkBufferView} with a subset of the associated {@code VkBuffer} usage using ##VkBufferUsageFlags2CreateInfoKHR.</li>
            <li>A new function #CmdBindIndexBuffer2KHR(), allowing a range of memory to be bound as an index buffer.</li>
            <li>#GetDeviceProcAddr() will return {@code NULL} for function pointers of core functions for versions higher than the version requested by the application.</li>
            <li>#CmdBindVertexBuffers2() supports using #WHOLE_SIZE in the {@code pSizes} parameter.</li>
            <li>If {@code PointSize} is not written, a default value of {@code 1.0} is used for the size of points.</li>
            <li>##VkShaderModuleCreateInfo <b>can</b> be added as a chained structure to pipeline creation via ##VkPipelineShaderStageCreateInfo, rather than having to create a shader module.</li>
            <li>A function #GetRenderingAreaGranularityKHR() to query the optimal render area for a dynamic rendering instance.</li>
            <li>A property to indicate that depth/stencil texturing operations with #COMPONENT_SWIZZLE_ONE have defined behavior.</li>
            <li>#GetDeviceImageSubresourceLayoutKHR() allows an application to perform a #GetImageSubresourceLayout() query without having to create an image.</li>
            <li>#REMAINING_ARRAY_LAYERS as the {@code layerCount} member of ##VkImageSubresourceLayers.</li>
            <li>A property to indicate whether {@code PointSize} controls the final rasterization of polygons if <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#primsrast-polygonmode">polygon mode</a> is #POLYGON_MODE_POINT.</li>
            <li>Two properties to indicate the non-strict line rasterization algorithm used.</li>
            <li>Two new flags words {@code VkPipelineCreateFlagBits2KHR} and {@code VkBufferUsageFlagBits2KHR}.</li>
            <li>Physical-device-level functions <b>can</b> now be called with any value in the valid range for a type beyond the defined enumerants, such that applications can avoid checking individual features, extensions, or versions before querying supported properties of a particular enumerant.</li>
            <li>Copies between images of any type are allowed, with 1D images treated as 2D images with a height of 1.</li>
        </ul>""")
}

val VkPhysicalDeviceMaintenance5PropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceMaintenance5PropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing various implementation-defined properties introduced with VK_KHR_maintenance5.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMaintenance5PropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkBool32("earlyFragmentMultisampleCoverageAfterSampleCounting", "a boolean value indicating whether the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-shader\">fragment shading</a> and <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-covg\">multisample coverage</a> operations are performed after <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-samplecount\">sample counting</a> for <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-shader\">fragment shaders</a> with {@code EarlyFragmentTests} execution mode.")
    VkBool32("earlyFragmentSampleMaskTestBeforeSampleCounting", "a boolean value indicating whether the <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-samplemask\">sample mask test</a> operation is performed before <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-samplecount\">sample counting</a> for <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#fragops-shader\">fragment shaders</a> using the {@code EarlyFragmentTests} execution mode.")
    VkBool32("depthStencilSwizzleOneSupport", "a boolean indicating that depth/stencil texturing operations with #COMPONENT_SWIZZLE_ONE have defined behavior.")
    VkBool32("polygonModePointSize", "a boolean value indicating whether the point size of the final rasterization of polygons with #POLYGON_MODE_POINT is controlled by {@code PointSize}.")
    VkBool32("nonStrictSinglePixelWideLinesUseParallelogram", "a boolean value indicating whether non-strict lines with a width of 1.0 are rasterized as parallelograms or using Bresenham’s algorithm.")
    VkBool32("nonStrictWideLinesUseParallelogram", "a boolean value indicating whether non-strict lines with a width greater than 1.0 are rasterized as parallelograms or using Bresenham’s algorithm.")
}

val VkRenderingAreaInfoKHR = struct(Module.VULKAN, "VkRenderingAreaInfoKHR") {
    documentation =
        """
        Structure describing rendering area granularity query info.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        #GetRenderingAreaGranularityKHR()
        """

    Expression("#STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("viewMask", "the viewMask used for rendering.")
    AutoSize("pColorAttachmentFormats", optional = true)..uint32_t("colorAttachmentCount", "the number of entries in {@code pColorAttachmentFormats}")
    nullable..VkFormat.const.p("pColorAttachmentFormats", "a pointer to an array of {@code VkFormat} values defining the format of color attachments used in the render pass instance.")
    VkFormat("depthAttachmentFormat", "a {@code VkFormat} value defining the format of the depth attachment used in the render pass instance.")
    VkFormat("stencilAttachmentFormat", "a {@code VkFormat} value defining the format of the stencil attachment used in the render pass instance.")
}

val VkDeviceImageSubresourceInfoKHR = struct(Module.VULKAN, "VkDeviceImageSubresourceInfoKHR") {
    documentation =
        """
        Image creation information for querying subresource layout.

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code aspectMask} member of {@code pSubresource} <b>must</b> only have a single bit set</li>
            <li>The {@code mipLevel} member of {@code pSubresource} <b>must</b> be less than the {@code mipLevels} specified in ##VkImageCreateInfo when {@code image} was created</li>
            <li>The {@code arrayLayer} member of {@code pSubresource} <b>must</b> be less than the {@code arrayLayers} specified in ##VkImageCreateInfo when {@code image} was created</li>
            <li>If {@code format} of the {@code image} is a color format, {@code tiling} of the {@code image} is #IMAGE_TILING_LINEAR or #IMAGE_TILING_OPTIMAL, and does not have a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-requiring-sampler-ycbcr-conversion">multi-planar image format</a>, the {@code aspectMask} member of {@code pSubresource} <b>must</b> be #IMAGE_ASPECT_COLOR_BIT</li>
            <li>If {@code format} of the {@code image} has a depth component, the {@code aspectMask} member of {@code pSubresource} <b>must</b> contain #IMAGE_ASPECT_DEPTH_BIT</li>
            <li>If {@code format} of the {@code image} has a stencil component, the {@code aspectMask} member of {@code pSubresource} <b>must</b> contain #IMAGE_ASPECT_STENCIL_BIT</li>
            <li>If {@code format} of the {@code image} does not contain a stencil or depth component, the {@code aspectMask} member of {@code pSubresource} <b>must</b> not contain #IMAGE_ASPECT_DEPTH_BIT or #IMAGE_ASPECT_STENCIL_BIT</li>
            <li>If the {@code tiling} of the {@code image} is #IMAGE_TILING_LINEAR and has a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-requiring-sampler-ycbcr-conversion">multi-planar image format</a>, then the {@code aspectMask} member of {@code pSubresource} <b>must</b> be a single valid <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#formats-planes-image-aspect">multi-planar aspect mask</a> bit</li>
            <li>If {@code image} was created with the #EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then {@code image} <b>must</b> be bound to memory</li>
            <li>If the {@code tiling} of the {@code image} is #IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the {@code aspectMask} member of {@code pSubresource} <b>must</b> be <code>VK_IMAGE_ASPECT_MEMORY_PLANE<em>_i_</em>BIT_EXT</code> and the index <em>i</em> <b>must</b> be less than the ##VkDrmFormatModifierPropertiesEXT{@code ::drmFormatModifierPlaneCount} associated with the image’s {@code format} and ##VkImageDrmFormatModifierPropertiesEXT{@code ::drmFormatModifier}</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code pCreateInfo} <b>must</b> be a valid pointer to a valid ##VkImageCreateInfo structure</li>
            <li>{@code pSubresource} <b>must</b> be a valid pointer to a valid ##VkImageSubresource2KHR structure</li>
        </ul>

        <h5>See Also</h5>
        ##VkImageCreateInfo, ##VkImageSubresource2KHR, #GetDeviceImageSubresourceLayoutKHR()
        """

    Expression("#STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkImageCreateInfo.const.p("pCreateInfo", "a pointer to a ##VkImageCreateInfo structure containing parameters affecting creation of the image to query.")
    VkImageSubresource2KHR.const.p("pSubresource", "pSubresource is a pointer to a ##VkImageSubresource2KHR structure selecting a specific image subresource for the query.")
}

val VkPipelineCreateFlags2CreateInfoKHR = struct(Module.VULKAN, "VkPipelineCreateFlags2CreateInfoKHR") {
    documentation =
        """
        Extended pipeline create flags.

        <h5>Description</h5>
        If this structure is included in the {@code pNext} chain of a pipeline creation structure, {@code flags} is used instead of the corresponding {@code flags} value passed in that creation structure, allowing additional creation flags to be specified.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkPipelineCreateFlagBits2KHR} values</li>
            <li>{@code flags} <b>must</b> not be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkPipelineCreateFlags2KHR("flags", "a bitmask of {@code VkPipelineCreateFlagBits2KHR} specifying how a pipeline will be generated.")
}

val VkBufferUsageFlags2CreateInfoKHR = struct(Module.VULKAN, "VkBufferUsageFlags2CreateInfoKHR") {
    documentation =
        """
        Extended buffer usage flags.

        <h5>Description</h5>
        If this structure is included in the {@code pNext} chain of a buffer creation structure, {@code usage} is used instead of the corresponding {@code usage} value passed in that creation structure, allowing additional usage flags to be specified. If this structure is included in the {@code pNext} chain of a buffer query structure, the usage flags of the buffer are returned in {@code usage} of this structure, and the usage flags representable in {@code usage} of the buffer query structure are also returned in that field.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR</li>
            <li>{@code usage} <b>must</b> be a valid combination of {@code VkBufferUsageFlagBits2KHR} values</li>
            <li>{@code usage} <b>must</b> not be 0</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBufferUsageFlags2KHR("usage", "a bitmask of {@code VkBufferUsageFlagBits2KHR} specifying allowed usages of the buffer.")
}

val VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR") {
    documentation =
        """
        Structure describing support for fetching vertex positions of hit triangles.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rayTracingPositionFetch", "indicates that the implementation supports fetching the object space vertex positions of a hit triangle.")
}

val VkPhysicalDeviceShaderObjectFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderObjectFeaturesEXT") {
    documentation =
        """
        Structure describing whether shader objects can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderObjectFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderObjectFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("shaderObject", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#shaders-objects\">shader objects</a>.")
}

val VkPhysicalDeviceShaderObjectPropertiesEXT = struct(Module.VULKAN, "VkPhysicalDeviceShaderObjectPropertiesEXT", mutable = false) {
    javaImport("static org.lwjgl.vulkan.VK10.*")
    documentation =
        """
        Structure describing shader object properties supported by an implementation.

        <h5>Description</h5>
        The purpose and usage of the values of this structure are described in greater detail in <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#shaders-objects-binary-compatibility">Binary Shader Compatibility</a>.

        If the ##VkPhysicalDeviceShaderObjectPropertiesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint8_t("shaderBinaryUUID", "an array of #UUID_SIZE {@code uint8_t} values representing a universally unique identifier for one or more implementations whose shader binaries are guaranteed to be compatible with each other.")["VK_UUID_SIZE"]
    uint32_t("shaderBinaryVersion", "an unsigned integer incremented to represent backwards compatible differences between implementations with the same {@code shaderBinaryUUID}.")
}

val VkShaderCreateInfoEXT = struct(Module.VULKAN, "VkShaderCreateInfoEXT") {
    documentation =
        """
        Structure specifying parameters of a newly created shader.

        <h5>Valid Usage</h5>
        <ul>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code codeSize} <b>must</b> be a multiple of 4</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code pCode} <b>must</b> point to valid SPIR-V code, formatted and packed as described by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirv-spec">Khronos SPIR-V Specification</a></li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code pCode} <b>must</b> adhere to the validation rules described by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-module-validation">Validation Rules within a Module</a> section of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-capabilities">SPIR-V Environment</a> appendix</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code pCode} <b>must</b> declare the {@code Shader} capability for SPIR-V code</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code pCode} <b>must</b> not declare any capability that is not supported by the API, as described by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-module-validation">Capabilities</a> section of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-capabilities">SPIR-V Environment</a> appendix</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code pCode} declares any of the capabilities listed in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-capabilities-table">SPIR-V Environment</a> appendix, one of the corresponding requirements <b>must</b> be satisfied</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code pCode} <b>must</b> not declare any SPIR-V extension that is not supported by the API, as described by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-extensions">Extension</a> section of the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-capabilities">SPIR-V Environment</a> appendix</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code pCode} declares any of the SPIR-V extensions listed in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirvenv-extensions-table">SPIR-V Environment</a> appendix, one of the corresponding requirements <b>must</b> be satisfied</li>
            <li>If {@code stage} is not #SHADER_STAGE_TASK_BIT_EXT, #SHADER_STAGE_MESH_BIT_EXT, #SHADER_STAGE_VERTEX_BIT, #SHADER_STAGE_TESSELLATION_CONTROL_BIT, #SHADER_STAGE_TESSELLATION_EVALUATION_BIT, #SHADER_STAGE_GEOMETRY_BIT, or #SHADER_STAGE_FRAGMENT_BIT, {@code flags} <b>must</b> not include #SHADER_CREATE_LINK_STAGE_BIT_EXT</li>
            <li>If {@code stage} is not #SHADER_STAGE_FRAGMENT_BIT, {@code flags} <b>must</b> not include #SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-attachmentFragmentShadingRate">{@code attachmentFragmentShadingRate}</a> feature is not enabled, {@code flags} <b>must</b> not include #SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT</li>
            <li>If {@code stage} is not #SHADER_STAGE_FRAGMENT_BIT, {@code flags} <b>must</b> not include #SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-fragmentDensityMap">{@code fragmentDensityMap}</a> feature is not enabled, {@code flags} <b>must</b> not include #SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT</li>
            <li>If {@code flags} includes #SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT, {@code stage} <b>must</b> be one of #SHADER_STAGE_MESH_BIT_EXT, #SHADER_STAGE_TASK_BIT_EXT, or #SHADER_STAGE_COMPUTE_BIT</li>
            <li>If {@code stage} is not #SHADER_STAGE_COMPUTE_BIT, {@code flags} <b>must</b> not include #SHADER_CREATE_DISPATCH_BASE_BIT_EXT</li>
            <li>If {@code stage} is not #SHADER_STAGE_MESH_BIT_EXT, {@code flags} <b>must</b> not include #SHADER_CREATE_NO_TASK_SHADER_BIT_EXT</li>
            <li>If {@code flags} includes both #SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT and #SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT, the local workgroup size in the X dimension of the shader <b>must</b> be a multiple of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxSubgroupSize">{@code maxSubgroupSize}</a></li>
            <li>If {@code flags} includes #SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT but not #SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT and no ##VkShaderRequiredSubgroupSizeCreateInfoEXT structure is included in the {@code pNext} chain, the local workgroup size in the X dimension of the shader <b>must</b> be a multiple of <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-subgroup-size">{@code subgroupSize}</a></li>
            <li>{@code stage} <b>must</b> not be #SHADER_STAGE_ALL_GRAPHICS or #SHADER_STAGE_ALL</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-tessellationShader">{@code tessellationShader}</a> feature is not enabled, {@code stage} <b>must</b> not be #SHADER_STAGE_TESSELLATION_CONTROL_BIT or #SHADER_STAGE_TESSELLATION_EVALUATION_BIT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-geometryShader">{@code geometryShader}</a> feature is not enabled, {@code stage} <b>must</b> not be #SHADER_STAGE_GEOMETRY_BIT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-taskShader">{@code taskShader}</a> feature is not enabled, {@code stage} <b>must</b> not be #SHADER_STAGE_TASK_BIT_EXT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-meshShader">{@code meshShader}</a> feature is not enabled, {@code stage} <b>must</b> not be #SHADER_STAGE_MESH_BIT_EXT</li>
            <li>{@code stage} <b>must</b> not be #SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI</li>
            <li>{@code stage} <b>must</b> not be #SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI</li>
            <li>If {@code stage} is #SHADER_STAGE_VERTEX_BIT, {@code nextStage} <b>must</b> not include any bits other than #SHADER_STAGE_TESSELLATION_CONTROL_BIT, #SHADER_STAGE_GEOMETRY_BIT, and #SHADER_STAGE_FRAGMENT_BIT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-tessellationShader">{@code tessellationShader}</a> feature is not enabled, {@code nextStage} <b>must</b> not include #SHADER_STAGE_TESSELLATION_CONTROL_BIT or #SHADER_STAGE_TESSELLATION_EVALUATION_BIT</li>
            <li>If the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#features-geometryShader">{@code geometryShader}</a> feature is not enabled, {@code nextStage} <b>must</b> not include #SHADER_STAGE_GEOMETRY_BIT</li>
            <li>If {@code stage} is #SHADER_STAGE_TESSELLATION_CONTROL_BIT, {@code nextStage} <b>must</b> not include any bits other than #SHADER_STAGE_TESSELLATION_EVALUATION_BIT</li>
            <li>If {@code stage} is #SHADER_STAGE_TESSELLATION_EVALUATION_BIT, {@code nextStage} <b>must</b> not include any bits other than #SHADER_STAGE_GEOMETRY_BIT and #SHADER_STAGE_FRAGMENT_BIT</li>
            <li>If {@code stage} is #SHADER_STAGE_GEOMETRY_BIT, {@code nextStage} <b>must</b> not include any bits other than #SHADER_STAGE_FRAGMENT_BIT</li>
            <li>If {@code stage} is #SHADER_STAGE_FRAGMENT_BIT or #SHADER_STAGE_COMPUTE_BIT, {@code nextStage} <b>must</b> be 0</li>
            <li>If {@code stage} is #SHADER_STAGE_TASK_BIT_EXT, {@code nextStage} <b>must</b> not include any bits other than #SHADER_STAGE_MESH_BIT_EXT</li>
            <li>If {@code stage} is #SHADER_STAGE_MESH_BIT_EXT, {@code nextStage} <b>must</b> not include any bits other than #SHADER_STAGE_FRAGMENT_BIT</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code pName} <b>must</b> be the name of an {@code OpEntryPoint} in {@code pCode} with an execution model that matches {@code stage}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_BINARY_EXT, {@code pCode} <b>must</b> be aligned to 16 bytes</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, {@code pCode} <b>must</b> be aligned to 4 bytes</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and the identified entry point includes any variable in its interface that is declared with the {@code ClipDistance} {@code BuiltIn} decoration, that variable <b>must</b> not have an array size greater than ##VkPhysicalDeviceLimits{@code ::maxClipDistances}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and the identified entry point includes any variable in its interface that is declared with the {@code CullDistance} {@code BuiltIn} decoration, that variable <b>must</b> not have an array size greater than ##VkPhysicalDeviceLimits{@code ::maxCullDistances}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and the identified entry point includes any variables in its interface that are declared with the {@code ClipDistance} or {@code CullDistance} {@code BuiltIn} decoration, those variables <b>must</b> not have array sizes which sum to more than ##VkPhysicalDeviceLimits{@code ::maxCombinedClipAndCullDistances}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and the identified entry point includes any variable in its interface that is declared with the {@code SampleMask} {@code BuiltIn} decoration, that variable <b>must</b> not have an array size greater than ##VkPhysicalDeviceLimits{@code ::maxSampleMaskWords}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_VERTEX_BIT, the identified entry point <b>must</b> not include any input variable in its interface that is decorated with {@code CullDistance}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_TESSELLATION_CONTROL_BIT or #SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified entry point has an {@code OpExecutionMode} instruction specifying a patch size with {@code OutputVertices}, the patch size <b>must</b> be greater than 0 and less than or equal to ##VkPhysicalDeviceLimits{@code ::maxTessellationPatchSize}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_GEOMETRY_BIT, the identified entry point <b>must</b> have an {@code OpExecutionMode} instruction specifying a maximum output vertex count that is greater than 0 and less than or equal to ##VkPhysicalDeviceLimits{@code ::maxGeometryOutputVertices}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_GEOMETRY_BIT, the identified entry point <b>must</b> have an {@code OpExecutionMode} instruction specifying an invocation count that is greater than 0 and less than or equal to ##VkPhysicalDeviceLimits{@code ::maxGeometryShaderInvocations}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#pipelines-graphics-subsets-pre-rasterization">pre-rasterization shader stage</a>, and the identified entry point writes to {@code Layer} for any primitive, it <b>must</b> write the same value to {@code Layer} for all vertices of a given primitive</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is a <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#pipelines-graphics-subsets-pre-rasterization">pre-rasterization shader stage</a>, and the identified entry point writes to {@code ViewportIndex} for any primitive, it <b>must</b> write the same value to {@code ViewportIndex} for all vertices of a given primitive</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_FRAGMENT_BIT, the identified entry point <b>must</b> not include any output variables in its interface decorated with {@code CullDistance}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to {@code FragDepth} in any execution path, all execution paths that are not exclusive to helper invocations <b>must</b> either discard the fragment, or write or initialize the value of {@code FragDepth}</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, the shader code in {@code pCode} <b>must</b> be valid as described by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#spirv-spec">Khronos SPIR-V Specification</a> after applying the specializations provided in {@code pSpecializationInfo}, if any, and then converting all specialization constants into fixed constants</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_TESSELLATION_EVALUATION_BIT, {@code pCode} <b>must</b> contain an {@code OpExecutionMode} instruction specifying the type of subdivision</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_TESSELLATION_EVALUATION_BIT, {@code pCode} <b>must</b> contain an {@code OpExecutionMode} instruction specifying the orientation of triangles generated by the tessellator</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_TESSELLATION_EVALUATION_BIT, {@code pCode} <b>must</b> contain an {@code OpExecutionMode} instruction specifying the spacing of segments on the edges of tessellated primitives</li>
            <li>If {@code codeType} is #SHADER_CODE_TYPE_SPIRV_EXT, and {@code stage} is #SHADER_STAGE_TESSELLATION_EVALUATION_BIT, {@code pCode} <b>must</b> contain an {@code OpExecutionMode} instruction specifying the output patch size</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT</li>
            <li>{@code pNext} <b>must</b> be {@code NULL} or a pointer to a valid instance of ##VkPipelineShaderStageRequiredSubgroupSizeCreateInfo</li>
            <li>The {@code sType} value of each struct in the {@code pNext} chain <b>must</b> be unique</li>
            <li>{@code flags} <b>must</b> be a valid combination of {@code VkShaderCreateFlagBitsEXT} values</li>
            <li>{@code stage} <b>must</b> be a valid {@code VkShaderStageFlagBits} value</li>
            <li>{@code nextStage} <b>must</b> be a valid combination of {@code VkShaderStageFlagBits} values</li>
            <li>{@code codeType} <b>must</b> be a valid {@code VkShaderCodeTypeEXT} value</li>
            <li>{@code pCode} <b>must</b> be a valid pointer to an array of {@code codeSize} bytes</li>
            <li>If {@code pName} is not {@code NULL}, {@code pName} <b>must</b> be a null-terminated UTF-8 string</li>
            <li>If {@code setLayoutCount} is not 0, and {@code pSetLayouts} is not {@code NULL}, {@code pSetLayouts} <b>must</b> be a valid pointer to an array of {@code setLayoutCount} valid {@code VkDescriptorSetLayout} handles</li>
            <li>If {@code pushConstantRangeCount} is not 0, and {@code pPushConstantRanges} is not {@code NULL}, {@code pPushConstantRanges} <b>must</b> be a valid pointer to an array of {@code pushConstantRangeCount} valid ##VkPushConstantRange structures</li>
            <li>If {@code pSpecializationInfo} is not {@code NULL}, {@code pSpecializationInfo} <b>must</b> be a valid pointer to a valid ##VkSpecializationInfo structure</li>
            <li>{@code codeSize} <b>must</b> be greater than 0</li>
        </ul>

        <h5>See Also</h5>
        ##VkPushConstantRange, ##VkSpecializationInfo, #CreateShadersEXT()
        """

    Expression("#STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    PointerSetter(
        "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo", "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT", "VkShaderRequiredSubgroupSizeCreateInfoEXT",
        prepend = true
    )..nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkShaderCreateFlagsEXT("flags", "a bitmask of {@code VkShaderCreateFlagBitsEXT} describing additional parameters of the shader.")
    VkShaderStageFlagBits("stage", "a {@code VkShaderStageFlagBits} value specifying a single shader stage.")
    VkShaderStageFlags("nextStage", "a bitmask of {@code VkShaderStageFlagBits} specifying zero or stages which <b>may</b> be used as a logically next bound stage when drawing with the shader bound.")
    VkShaderCodeTypeEXT("codeType", "a {@code VkShaderCodeTypeEXT} value specifying the type of the shader code pointed to be {@code pCode}.")
    AutoSize("pCode")..size_t("codeSize", "the size in bytes of the shader code pointed to be {@code pCode}.")
    void.const.p("pCode", "a pointer to the shader code to use to create the shader.")
    nullable..charUTF8.const.p("pName", "a pointer to a null-terminated UTF-8 string specifying the entry point name of the shader for this stage.")
    AutoSize("pSetLayouts", optional = true)..uint32_t("setLayoutCount", "the number of descriptor set layouts pointed to by {@code pSetLayouts}.")
    nullable..VkDescriptorSetLayout.const.p("pSetLayouts", "a pointer to an array of {@code VkDescriptorSetLayout} objects used by the shader stage.")
    AutoSize("pPushConstantRanges", optional = true)..uint32_t("pushConstantRangeCount", "the number of push constant ranges pointed to by {@code pPushConstantRanges}.")
    nullable..VkPushConstantRange.const.p("pPushConstantRanges", "a pointer to an array of ##VkPushConstantRange structures used by the shader stage.")
    nullable..VkSpecializationInfo.const.p("pSpecializationInfo", "a pointer to a ##VkSpecializationInfo structure, as described in <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#pipelines-specialization-constants\">Specialization Constants</a>, or {@code NULL}.")
}

val VkShaderRequiredSubgroupSizeCreateInfoEXT = struct(Module.VULKAN, "VkShaderRequiredSubgroupSizeCreateInfoEXT", mutable = false, alias = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo) {
    documentation = "See ##VkPipelineShaderStageRequiredSubgroupSizeCreateInfo."

    Expression("#STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    uint32_t("requiredSubgroupSize", "")
}

val VkPhysicalDeviceTilePropertiesFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceTilePropertiesFeaturesQCOM") {
    documentation =
        """
        Structure describing tile properties features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceTilePropertiesFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceTilePropertiesFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("tileProperties", "indicates that the implementation supports queries for returning tile properties.")
}

val VkTilePropertiesQCOM = struct(Module.VULKAN, "VkTilePropertiesQCOM") {
    documentation =
        """
        Structure holding available tile properties.

        <h5>Description</h5>
        All tiles will be tightly packed around the first tile, with edges being multiples of tile width and/or height from the origin.

        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Reported value for {@code apronSize} will be zero and its functionality will be described in a future extension.
        </div>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_TILE_PROPERTIES_QCOM</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D, ##VkExtent3D, ##VkOffset2D, #GetDynamicRenderingTilePropertiesQCOM(), #GetFramebufferTilePropertiesQCOM()
        """

    Expression("#STRUCTURE_TYPE_TILE_PROPERTIES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExtent3D("tileSize", "the dimensions of a tile, with width and height describing the width and height of a tile in pixels, and depth corresponding to the number of slices the tile spans.")
    VkExtent2D("apronSize", "the dimension of the apron.")
    VkOffset2D("origin", "the top-left corner of the first tile in attachment space.")
}

val VkPhysicalDeviceAmigoProfilingFeaturesSEC = struct(Module.VULKAN, "VkPhysicalDeviceAmigoProfilingFeaturesSEC") {
    documentation =
        """
        Stub description of VkPhysicalDeviceAmigoProfilingFeaturesSEC.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("amigoProfiling", "")
}

val VkAmigoProfilingSubmitInfoSEC = struct(Module.VULKAN, "VkAmigoProfilingSubmitInfoSEC") {
    documentation =
        """
        Stub description of VkAmigoProfilingSubmitInfoSEC.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC")..VkStructureType("sType", "")
    nullable..opaque_const_p("pNext", "")
    uint64_t("firstDrawTimestamp", "")
    uint64_t("swapBufferTimestamp", "")
}

val VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM") {
    documentation =
        """
        Structure describing multiview per view viewports features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("multiviewPerViewViewports", "indicates that the implementation supports multiview per-view viewports.")
}

val VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV", mutable = false) {
    documentation =
        """
        Structure describing shader module identifier properties of an implementation.

        <h5>Description</h5>
        <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
        Because the extension changes how hits are managed there is a compatibility reason to expose the extension even when an implementation does not have sorting active.
        </div>

        If the ##VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV")..VkStructureType("sType", "").mutable()
    nullable..opaque_p("pNext", "").mutable()
    VkRayTracingInvocationReorderModeNV("rayTracingInvocationReorderReorderingHint", "a hint indicating if the implementation will actually reorder at the reorder calls.")
}

val VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV") {
    documentation =
        """
        Structure describing feature to control ray tracing invocation reordering.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("rayTracingInvocationReorder", "indicates that the implementation supports {@code SPV_NV_shader_invocation_reorder}.")
}

val VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT") {
    documentation =
        """
        Structure describing whether the mutable descriptor type is supported.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("mutableDescriptorType", """indicates that the implementation <b>must</b> support using the {@code VkDescriptorType} of #DESCRIPTOR_TYPE_MUTABLE_EXT with at least the following descriptor types, where any combination of the types <b>must</b> be supported:

        <ul>
            <li>#DESCRIPTOR_TYPE_SAMPLED_IMAGE</li>
            <li>#DESCRIPTOR_TYPE_STORAGE_IMAGE</li>
            <li>#DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER</li>
            <li>#DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER</li>
            <li>#DESCRIPTOR_TYPE_UNIFORM_BUFFER</li>
            <li>#DESCRIPTOR_TYPE_STORAGE_BUFFER</li>
        </ul>

        Additionally, {@code mutableDescriptorType} indicates that:

        <ul>
            <li>Non-uniform descriptor indexing <b>must</b> be supported if all descriptor types in a ##VkMutableDescriptorTypeListEXT for #DESCRIPTOR_TYPE_MUTABLE_EXT have the corresponding non-uniform indexing features enabled in ##VkPhysicalDeviceDescriptorIndexingFeatures.</li>
            <li>#DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT with {@code descriptorType} of #DESCRIPTOR_TYPE_MUTABLE_EXT relaxes the list of required descriptor types to the descriptor types which have the corresponding update-after-bind feature enabled in ##VkPhysicalDeviceDescriptorIndexingFeatures.</li>
            <li>Dynamically uniform descriptor indexing <b>must</b> be supported if all descriptor types in a ##VkMutableDescriptorTypeListEXT for #DESCRIPTOR_TYPE_MUTABLE_EXT have the corresponding dynamic indexing features enabled.</li>
            <li>#DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT <b>must</b> be supported.</li>
            <li>#DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT <b>must</b> be supported.</li>
        </ul>""")
}

val VkMutableDescriptorTypeCreateInfoEXT = struct(Module.VULKAN, "VkMutableDescriptorTypeCreateInfoEXT") {
    documentation =
        """
        Structure describing the list of possible active descriptor types for mutable type descriptors.

        <h5>Description</h5>
        If {@code mutableDescriptorTypeListCount} is zero or if this structure is not included in the {@code pNext} chain, the ##VkMutableDescriptorTypeListEXT for each element is considered to be zero or {@code NULL} for each member. Otherwise, the descriptor set layout binding at ##VkDescriptorSetLayoutCreateInfo{@code ::pBindings}[i] uses the descriptor type lists in ##VkMutableDescriptorTypeCreateInfoEXT{@code ::pMutableDescriptorTypeLists}[i].

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT</li>
            <li>If {@code mutableDescriptorTypeListCount} is not 0, {@code pMutableDescriptorTypeLists} <b>must</b> be a valid pointer to an array of {@code mutableDescriptorTypeListCount} valid ##VkMutableDescriptorTypeListEXT structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkMutableDescriptorTypeListEXT
        """

    Expression("#STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pMutableDescriptorTypeLists", optional = true)..uint32_t("mutableDescriptorTypeListCount", "the number of elements in {@code pMutableDescriptorTypeLists}.")
    VkMutableDescriptorTypeListEXT.const.p("pMutableDescriptorTypeLists", "a pointer to an array of ##VkMutableDescriptorTypeListEXT structures.")
}

val VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = struct(Module.VULKAN, "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM") {
    documentation =
        """
        Structure describing the shader core builtins features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("shaderCoreBuiltins", "indicates whether the implementation supports the SPIR-V {@code CoreBuiltinsARM} capability.")
}

val VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = struct(Module.VULKAN, "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM", mutable = false) {
    documentation =
        """
        Structure describing shader core builtins properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    uint64_t("shaderCoreMask", "a bitfield where each bit set represents the presence of a shader core whose ID is the bit position. The highest ID for any shader core on the device is the position of the most significant bit set.")
    uint32_t("shaderCoreCount", "the number of shader cores on the device.")
    uint32_t("shaderWarpsPerCore", "the maximum number of simultaneously executing warps on a shader core.")
}

val VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT") {
    documentation =
        """
        Structure describing whether querying shader group handles from a pipeline library is supported by the implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("pipelineLibraryGroupHandles", "indicates whether the implementation supports querying group handles directly from a ray tracing pipeline library, and guarantees bitwise identical group handles for such libraries when linked into other pipelines.")
}

val VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT") {
    documentation =
        """
        Structure describing the dynamic rendering unused attachment features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("dynamicRenderingUnusedAttachments", "indicates that the implementation supports binding graphics pipelines within a render pass instance where any pipeline ##VkPipelineRenderingCreateInfo{@code ::pColorAttachmentFormats} element with a format other than #FORMAT_UNDEFINED is allowed with a corresponding ##VkRenderingInfo{@code ::pColorAttachments} element with a {@code imageView} equal to #NULL_HANDLE, or any pipeline ##VkPipelineRenderingCreateInfo{@code ::pColorAttachmentFormats} element with a #FORMAT_UNDEFINED format is allowed with a corresponding ##VkRenderingInfo{@code ::pColorAttachments} element with a non-#NULL_HANDLE {@code imageView}. Also a ##VkPipelineRenderingCreateInfo{@code ::depthAttachmentFormat} other than #FORMAT_UNDEFINED is allowed with a #NULL_HANDLE ##VkRenderingInfo{@code ::pDepthAttachment}, or a ##VkPipelineRenderingCreateInfo{@code ::depthAttachmentFormat} of #FORMAT_UNDEFINED is allowed with a non-#NULL_HANDLE ##VkRenderingInfo{@code ::pDepthAttachment}. Also a ##VkPipelineRenderingCreateInfo{@code ::stencilAttachmentFormat} other than #FORMAT_UNDEFINED is allowed with a #NULL_HANDLE ##VkRenderingInfo{@code ::pStencilAttachment}, or a ##VkPipelineRenderingCreateInfo{@code ::stencilAttachmentFormat} of #FORMAT_UNDEFINED is allowed with a non-#NULL_HANDLE ##VkRenderingInfo{@code ::pStencilAttachment}. Any writes to a ##VkRenderingInfo{@code ::pColorAttachments}, ##VkRenderingInfo{@code ::pDepthAttachment}, or ##VkRenderingInfo{@code ::pStencilAttachment} with #NULL_HANDLE are discarded.")
}

val VkCooperativeMatrixPropertiesKHR = struct(Module.VULKAN, "VkCooperativeMatrixPropertiesKHR") {
    documentation =
        """
        Structure specifying cooperative matrix properties.

        <h5>Description</h5>
        If some types are preferred over other types (e.g. for performance), they <b>should</b> appear earlier in the list enumerated by #GetPhysicalDeviceCooperativeMatrixPropertiesKHR().

        At least one entry in the list <b>must</b> have power of two values for all of {@code MSize}, {@code KSize}, and {@code NSize}.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR</li>
            <li>{@code pNext} <b>must</b> be {@code NULL}</li>
            <li>{@code AType} <b>must</b> be a valid {@code VkComponentTypeKHR} value</li>
            <li>{@code BType} <b>must</b> be a valid {@code VkComponentTypeKHR} value</li>
            <li>{@code CType} <b>must</b> be a valid {@code VkComponentTypeKHR} value</li>
            <li>{@code ResultType} <b>must</b> be a valid {@code VkComponentTypeKHR} value</li>
            <li>{@code scope} <b>must</b> be a valid {@code VkScopeKHR} value</li>
        </ul>

        <h5>See Also</h5>
        #GetPhysicalDeviceCooperativeMatrixPropertiesKHR()
        """

    Expression("#STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    uint32_t("MSize", "the number of rows in matrices {@code A}, {@code C}, and {@code Result}.")
    uint32_t("NSize", "the number of columns in matrices {@code B}, {@code C}, {@code Result}.")
    uint32_t("KSize", "the number of columns in matrix {@code A} and rows in matrix {@code B}.")
    VkComponentTypeKHR("AType", "the component type of matrix {@code A}, of type {@code VkComponentTypeKHR}.")
    VkComponentTypeKHR("BType", "the component type of matrix {@code B}, of type {@code VkComponentTypeKHR}.")
    VkComponentTypeKHR("CType", "the component type of matrix {@code C}, of type {@code VkComponentTypeKHR}.")
    VkComponentTypeKHR("ResultType", "the component type of matrix {@code Result}, of type {@code VkComponentTypeKHR}.")
    VkBool32("saturatingAccumulation", "indicates whether the {@code SaturatingAccumulation} operand to {@code OpCooperativeMatrixMulAddKHR} <b>must</b> be present.")
    VkScopeKHR("scope", "the scope of all the matrix types, of type {@code VkScopeKHR}.")
}

val VkPhysicalDeviceCooperativeMatrixFeaturesKHR = struct(Module.VULKAN, "VkPhysicalDeviceCooperativeMatrixFeaturesKHR") {
    documentation =
        """
        Structure describing cooperative matrix features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCooperativeMatrixFeaturesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCooperativeMatrixFeaturesKHR <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("cooperativeMatrix", "indicates that the implementation supports the {@code CooperativeMatrixKHR} SPIR-V capability.")
    VkBool32("cooperativeMatrixRobustBufferAccess", "indicates that the implementation supports robust buffer access for SPIR-V {@code OpCooperativeMatrixLoadKHR} and {@code OpCooperativeMatrixStoreKHR} instructions.")
}

val VkPhysicalDeviceCooperativeMatrixPropertiesKHR = struct(Module.VULKAN, "VkPhysicalDeviceCooperativeMatrixPropertiesKHR", mutable = false) {
    documentation =
        """
        Structure describing cooperative matrix properties supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCooperativeMatrixPropertiesKHR structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkShaderStageFlags("cooperativeMatrixSupportedStages", "a bitfield of {@code VkShaderStageFlagBits} describing the shader stages that cooperative matrix instructions are supported in. {@code cooperativeMatrixSupportedStages} will have the #SHADER_STAGE_COMPUTE_BIT bit set if any of the physical device’s queues support #QUEUE_COMPUTE_BIT.")
}

val VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM") {
    documentation =
        """
        Structure describing multiview per view render areas features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("multiviewPerViewRenderAreas", "indicates that the implementation supports multiview per-view render areas.")
}

val VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = struct(Module.VULKAN, "VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM") {
    documentation =
        """
        Set the multiview per view render areas for a render pass instance.

        <h5>Description</h5>
        If {@code perViewRenderAreaCount} is not zero, then the elements of {@code pPerViewRenderAreas} override the value of ##VkRenderPassBeginInfo{@code ::renderArea} or ##VkRenderingInfo{@code ::renderArea} and define per-view render areas for the individual views of a multiview render pass. The render area for the view with <em>view index</em> {@code i} is specified by {@code pPerViewRenderAreas}[i].

        The per-view render areas define per-view regions of attachments that are loaded, stored, and resolved according to the {@code loadOp}, {@code storeOp}, and {@code resolveMode} values of the render pass instance. When per-view render areas are defined, the value of ##VkRenderPassBeginInfo{@code ::renderArea} or ##VkRenderingInfo{@code ::renderArea} <b>must</b> be set to a render area that includes the union of all per-view render areas, <b>may</b> be used by the implementation for optimizations, but does not affect loads, stores, or resolves.

        If this structure is present and if {@code perViewRenderAreaCount} is not zero, then {@code perViewRenderAreaCount} <b>must</b> be at least least one greater than the most significant bit set in any any element of ##VkRenderPassMultiviewCreateInfo{@code ::pViewMasks}. or ##VkRenderingInfo{@code ::viewMask}

        If this structure is not present or if {@code perViewRenderAreaCount} is zero, ##VkRenderPassBeginInfo{@code ::renderArea} or ##VkRenderingInfo{@code ::renderArea} is used for all views.

        <h5>Valid Usage</h5>
        <ul>
            <li>The {@code offset.x} member of any element of {@code pPerViewRenderAreas} <b>must</b> be greater than or equal to 0</li>
            <li>The {@code offset.y} member of any element of {@code pPerViewRenderAreas} <b>must</b> be greater than or equal to 0</li>
            <li>The sum of the {@code offset.x} and {@code extent.width} members of any element of {@code pPerViewRenderAreas} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFramebufferWidth">{@code maxFramebufferWidth}</a></li>
            <li>The sum of the {@code offset.y} and {@code extent.height} members of any element of {@code pPerViewRenderAreas} <b>must</b> be less than or equal to <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\#limits-maxFramebufferHeight">{@code maxFramebufferHeight}</a></li>
            <li>If this structure is in the {@code pNext} chain of ##VkRenderPassBeginInfo and if the render pass object included an element in ##VkRenderPassMultiviewCreateInfo{@code ::pViewMasks} that set bit {@code n}, then {@code perViewRenderAreaCount} <b>must</b> be at least equal to {@code n+1}.</li>
            <li>If this structure is in the {@code pNext} chain of ##VkRenderingInfo and if ##VkRenderingInfo{@code ::viewMask} set bit {@code n}, then {@code perViewRenderAreaCount} <b>must</b> be at least equal to {@code n+1}.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM</li>
            <li>If {@code perViewRenderAreaCount} is not 0, {@code pPerViewRenderAreas} <b>must</b> be a valid pointer to an array of {@code perViewRenderAreaCount} ##VkRect2D structures</li>
        </ul>

        <h5>See Also</h5>
        ##VkRect2D
        """

    Expression("#STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    AutoSize("pPerViewRenderAreas", optional = true)..uint32_t("perViewRenderAreaCount", "the number of elements in the {@code pPerViewRenderAreas} array.")
    VkRect2D.const.p("pPerViewRenderAreas", "a pointer to an array of ##VkRect2D structures defining the render area for each view.")
}

val VkPhysicalDeviceImageProcessing2FeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceImageProcessing2FeaturesQCOM") {
    documentation =
        """
        Structure describing image processing features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageProcessing2FeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceImageProcessing2FeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("textureBlockMatch2", "indicates that the implementation supports shader modules that declare the {@code TextureBlockMatch2QCOM} capability.")
}

val VkPhysicalDeviceImageProcessing2PropertiesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceImageProcessing2PropertiesQCOM", mutable = false) {
    documentation =
        """
        Structure containing image processing2 properties.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceImageProcessing2PropertiesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceProperties2 structure passed to #GetPhysicalDeviceProperties2(), it is filled in with each corresponding implementation-dependent property.

        These are properties of the image processing2 information of a physical device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkExtent2D("maxBlockMatchWindow", "a ##VkExtent2D describing the largest dimensions ({@code width} and {@code height}) that <b>can</b> be specified for the block match window.")
}

val VkSamplerBlockMatchWindowCreateInfoQCOM = struct(Module.VULKAN, "VkSamplerBlockMatchWindowCreateInfoQCOM") {
    documentation =
        """
        Structure specifying the block match window parameters.

        <h5>Valid Usage</h5>
        <ul>
            <li>{@code WindowExtent} <b>must</b> not be larger than ##VkPhysicalDeviceImageProcessing2PropertiesQCOM{@code ::maxBlockMatchWindow}.</li>
        </ul>

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM</li>
            <li>{@code windowCompareMode} <b>must</b> be a valid {@code VkBlockMatchWindowCompareModeQCOM} value</li>
        </ul>

        <h5>See Also</h5>
        ##VkExtent2D
        """

    Expression("#STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkExtent2D("windowExtent", "a ##VkExtent2D specifying a the width and height of the block match window.")
    VkBlockMatchWindowCompareModeQCOM("windowCompareMode", "a {@code VkBlockMatchWindowCompareModeQCOM} specifying the compare mode.")
}

val VkPhysicalDeviceCubicWeightsFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceCubicWeightsFeaturesQCOM") {
    documentation =
        """
        Structure describing cubic weight selection features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCubicWeightsFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCubicWeightsFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("selectableCubicWeights", "indicates that the implementation supports the selection of filter cubic weights.")
}

val VkSamplerCubicWeightsCreateInfoQCOM = struct(Module.VULKAN, "VkSamplerCubicWeightsCreateInfoQCOM") {
    documentation =
        """
        Structure specifying sampler cubic weights.

        <h5>Description</h5>
        If the {@code pNext} chain of ##VkSamplerCreateInfo includes a ##VkSamplerCubicWeightsCreateInfoQCOM structure, then that structure specifies which cubic weights are used.

        If that structure is not present, {@code cubicWeights} is considered to be #CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM</li>
            <li>{@code cubicWeights} <b>must</b> be a valid {@code VkCubicFilterWeightsQCOM} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkCubicFilterWeightsQCOM("cubicWeights", "a {@code VkCubicFilterWeightsQCOM} value controlling which cubic weights are used.")
}

val VkBlitImageCubicWeightsInfoQCOM = struct(Module.VULKAN, "VkBlitImageCubicWeightsInfoQCOM") {
    documentation =
        """
        Structure specifying image blit cubic weight info.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM</li>
            <li>{@code cubicWeights} <b>must</b> be a valid {@code VkCubicFilterWeightsQCOM} value</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_const_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkCubicFilterWeightsQCOM("cubicWeights", "a {@code VkCubicFilterWeightsQCOM} value controlling cubic filter weights for the blit.")
}

val VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM") {
    documentation =
        """
        Structure describing Y′C<sub>B</sub>C<sub>R</sub> degamma features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceYcbcrDegammaFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceYcbcrDegammaFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("ycbcrDegamma", "indicates whether the implementation supports <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-ycbcr-degamma\">Y′C<sub>B</sub>C<sub>R</sub> degamma</a>.")
}

val VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = struct(Module.VULKAN, "VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM") {
    documentation =
        """
        Structure specifying Y′C<sub>B</sub>C<sub>R</sub> degamma parameters.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("enableYDegamma", "indicates <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-ycbcr-degamma\">sRGB to linear</a> conversion is enabled for the G component.")
    VkBool32("enableCbCrDegamma", "indicates <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-ycbcr-degamma\">sRGB to linear</a> conversion is enabled for the R and B components.")
}

val VkPhysicalDeviceCubicClampFeaturesQCOM = struct(Module.VULKAN, "VkPhysicalDeviceCubicClampFeaturesQCOM") {
    documentation =
        """
        Structure describing cubic clamp features that can be supported by an implementation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceCubicClampFeaturesQCOM structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceCubicClampFeaturesQCOM <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM")..VkStructureType("sType", "")
    nullable..opaque_p("pNext", "")
    VkBool32("cubicRangeClamp", "indicates that the implementation supports cubic filtering in combination with a <a href=\"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html\\#textures-texel-range-clamp\">texel range clamp</a>.")
}

val VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = struct(Module.VULKAN, "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT") {
    documentation =
        """
        Structure describing if dynamic feedback loops can be used.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("attachmentFeedbackLoopDynamicState", "specifies whether dynamic feedback loops are supported.")
}

val VkPhysicalDeviceLayeredDriverPropertiesMSFT = struct(Module.VULKAN, "VkPhysicalDeviceLayeredDriverPropertiesMSFT", mutable = false) {
    documentation =
        """
        Structure containing information about driver layering for a physical device.

        <h5>Description</h5>
        These are properties of the driver layering information of a physical device.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.").mutable()
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.").mutable()
    VkLayeredDriverUnderlyingApiMSFT("underlyingAPI", "a {@code VkLayeredDriverUnderlyingApiMSFT} value indicating which underlying API is used to implement the layered driver, or #LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT if the driver is not layered.")
}

val VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = struct(Module.VULKAN, "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV") {
    documentation =
        """
        Structure describing feature to allow descriptor pool overallocation.

        <h5>Description</h5>
        If the ##VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV structure is included in the {@code pNext} chain of the ##VkPhysicalDeviceFeatures2 structure passed to #GetPhysicalDeviceFeatures2(), it is filled in to indicate whether each corresponding feature is supported. ##VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV <b>can</b> also be used in the {@code pNext} chain of ##VkDeviceCreateInfo to selectively enable these features.

        <h5>Valid Usage (Implicit)</h5>
        <ul>
            <li>{@code sType} <b>must</b> be #STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV</li>
        </ul>
        """

    Expression("#STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV")..VkStructureType("sType", "a {@code VkStructureType} value identifying this structure.")
    nullable..opaque_p("pNext", "{@code NULL} or a pointer to a structure extending this structure.")
    VkBool32("descriptorPoolOverallocation", "indicates that the implementation allows the application to opt into descriptor pool overallocation by creating the descriptor pool with #DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV and/or #DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV flags.")
}